/* esm.sh - esbuild bundle(three@0.136.0) es2022 production */
var Dl = "136",
    Vy = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
    Gy = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
    Pu = 0,
    Xl = 1,
    Iu = 2,
    Wy = 3,
    qy = 0,
    jh = 1,
    Du = 2,
    us = 3,
    Ci = 0,
    it = 1,
    Li = 2,
    Qh = 1,
    Xy = 2,
    Mn = 0,
    fs = 1,
    Jl = 2,
    Yl = 3,
    Zl = 4,
    Fu = 5,
    wi = 100,
    Nu = 101,
    zu = 102,
    $l = 103,
    jl = 104,
    Bu = 200,
    Uu = 201,
    Ou = 202,
    Hu = 203,
    Kh = 204,
    eu = 205,
    ku = 206,
    Vu = 207,
    Gu = 208,
    Wu = 209,
    qu = 210,
    Xu = 0,
    Ju = 1,
    Yu = 2,
    Pa = 3,
    Zu = 4,
    $u = 5,
    ju = 6,
    Qu = 7,
    Go = 0,
    Ku = 1,
    ed = 2,
    wn = 0,
    td = 1,
    nd = 2,
    id = 3,
    sd = 4,
    rd = 5,
    Fl = 300,
    Yi = 301,
    Zi = 302,
    Gr = 303,
    Wr = 304,
    js = 306,
    Wo = 307,
    qr = 1e3,
    yt = 1001,
    Xr = 1002,
    st = 1003,
    Ia = 1004,
    Jy = 1004,
    Da = 1005,
    Yy = 1005,
    tt = 1006,
    tu = 1007,
    Zy = 1007,
    $i = 1008,
    $y = 1008,
    an = 1009,
    od = 1010,
    ad = 1011,
    ys = 1012,
    ld = 1013,
    Vr = 1014,
    on = 1015,
    Xn = 1016,
    cd = 1017,
    hd = 1018,
    ud = 1019,
    Ai = 1020,
    dd = 1021,
    Jn = 1022,
    lt = 1023,
    fd = 1024,
    pd = 1025,
    Yn = 1026,
    Pi = 1027,
    md = 1028,
    gd = 1029,
    xd = 1030,
    yd = 1031,
    vd = 1032,
    _d = 1033,
    Ql = 33776,
    Kl = 33777,
    ec = 33778,
    tc = 33779,
    nc = 35840,
    ic = 35841,
    sc = 35842,
    rc = 35843,
    Md = 36196,
    oc = 37492,
    ac = 37496,
    wd = 37808,
    bd = 37809,
    Sd = 37810,
    Td = 37811,
    Ed = 37812,
    Ad = 37813,
    Rd = 37814,
    Cd = 37815,
    Ld = 37816,
    Pd = 37817,
    Id = 37818,
    Dd = 37819,
    Fd = 37820,
    Nd = 37821,
    zd = 36492,
    Bd = 37840,
    Ud = 37841,
    Od = 37842,
    Hd = 37843,
    kd = 37844,
    Vd = 37845,
    Gd = 37846,
    Wd = 37847,
    qd = 37848,
    Xd = 37849,
    Jd = 37850,
    Yd = 37851,
    Zd = 37852,
    $d = 37853,
    jd = 2200,
    Qd = 2201,
    Kd = 2202,
    Jr = 2300,
    Yr = 2301,
    Zo = 2302,
    bi = 2400,
    Si = 2401,
    Zr = 2402,
    Nl = 2500,
    nu = 2501,
    ef = 0,
    jy = 1,
    Qy = 2,
    Ot = 3e3,
    ji = 3001,
    tf = 3200,
    nf = 3201,
    Qi = 0,
    sf = 1,
    Ky = 0,
    $o = 7680,
    e0 = 7681,
    t0 = 7682,
    n0 = 7683,
    i0 = 34055,
    s0 = 34056,
    r0 = 5386,
    o0 = 512,
    a0 = 513,
    l0 = 514,
    c0 = 515,
    h0 = 516,
    u0 = 517,
    d0 = 518,
    rf = 519,
    vs = 35044,
    _s = 35048,
    f0 = 35040,
    p0 = 35045,
    m0 = 35049,
    g0 = 35041,
    x0 = 35046,
    y0 = 35050,
    v0 = 35042,
    _0 = "100",
    lc = "300 es",
    cn = class {
        addEventListener(e, t) {
            this._listeners === void 0 && (this._listeners = {});
            let n = this._listeners;
            n[e] === void 0 && (n[e] = []),
                n[e].indexOf(t) === -1 && n[e].push(t);
        }
        hasEventListener(e, t) {
            if (this._listeners === void 0) return !1;
            let n = this._listeners;
            return n[e] !== void 0 && n[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
            if (this._listeners === void 0) return;
            let i = this._listeners[e];
            if (i !== void 0) {
                let s = i.indexOf(t);
                s !== -1 && i.splice(s, 1);
            }
        }
        dispatchEvent(e) {
            if (this._listeners === void 0) return;
            let n = this._listeners[e.type];
            if (n !== void 0) {
                e.target = this;
                let i = n.slice(0);
                for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
                e.target = null;
            }
        }
    },
    pt = [];
for (let r = 0; r < 256; r++) pt[r] = (r < 16 ? "0" : "") + r.toString(16);
var er = 1234567,
    Zn = Math.PI / 180,
    Ms = 180 / Math.PI;
function Ct() {
    let r = (Math.random() * 4294967295) | 0,
        e = (Math.random() * 4294967295) | 0,
        t = (Math.random() * 4294967295) | 0,
        n = (Math.random() * 4294967295) | 0;
    return (
        pt[r & 255] +
        pt[(r >> 8) & 255] +
        pt[(r >> 16) & 255] +
        pt[(r >> 24) & 255] +
        "-" +
        pt[e & 255] +
        pt[(e >> 8) & 255] +
        "-" +
        pt[((e >> 16) & 15) | 64] +
        pt[(e >> 24) & 255] +
        "-" +
        pt[(t & 63) | 128] +
        pt[(t >> 8) & 255] +
        "-" +
        pt[(t >> 16) & 255] +
        pt[(t >> 24) & 255] +
        pt[n & 255] +
        pt[(n >> 8) & 255] +
        pt[(n >> 16) & 255] +
        pt[(n >> 24) & 255]
    ).toUpperCase();
}
function mt(r, e, t) {
    return Math.max(e, Math.min(t, r));
}
function zl(r, e) {
    return ((r % e) + e) % e;
}
function of(r, e, t, n, i) {
    return n + ((r - e) * (i - n)) / (t - e);
}
function af(r, e, t) {
    return r !== e ? (t - r) / (e - r) : 0;
}
function ps(r, e, t) {
    return (1 - t) * r + t * e;
}
function lf(r, e, t, n) {
    return ps(r, e, 1 - Math.exp(-t * n));
}
function cf(r, e = 1) {
    return e - Math.abs(zl(r, e * 2) - e);
}
function hf(r, e, t) {
    return r <= e
        ? 0
        : r >= t
        ? 1
        : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function uf(r, e, t) {
    return r <= e
        ? 0
        : r >= t
        ? 1
        : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function df(r, e) {
    return r + Math.floor(Math.random() * (e - r + 1));
}
function ff(r, e) {
    return r + Math.random() * (e - r);
}
function pf(r) {
    return r * (0.5 - Math.random());
}
function mf(r) {
    return (
        r !== void 0 && (er = r % 2147483647),
        (er = (er * 16807) % 2147483647),
        (er - 1) / 2147483646
    );
}
function gf(r) {
    return r * Zn;
}
function xf(r) {
    return r * Ms;
}
function Fa(r) {
    return (r & (r - 1)) === 0 && r !== 0;
}
function iu(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function su(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function yf(r, e, t, n, i) {
    let s = Math.cos,
        o = Math.sin,
        a = s(t / 2),
        l = o(t / 2),
        c = s((e + n) / 2),
        h = o((e + n) / 2),
        u = s((e - n) / 2),
        d = o((e - n) / 2),
        f = s((n - e) / 2),
        m = o((n - e) / 2);
    switch (i) {
        case "XYX":
            r.set(a * h, l * u, l * d, a * c);
            break;
        case "YZY":
            r.set(l * d, a * h, l * u, a * c);
            break;
        case "ZXZ":
            r.set(l * u, l * d, a * h, a * c);
            break;
        case "XZX":
            r.set(a * h, l * m, l * f, a * c);
            break;
        case "YXY":
            r.set(l * f, a * h, l * m, a * c);
            break;
        case "ZYZ":
            r.set(l * m, l * f, a * h, a * c);
            break;
        default:
            console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    i
            );
    }
}
var M0 = Object.freeze({
        __proto__: null,
        DEG2RAD: Zn,
        RAD2DEG: Ms,
        generateUUID: Ct,
        clamp: mt,
        euclideanModulo: zl,
        mapLinear: of,
        inverseLerp: af,
        lerp: ps,
        damp: lf,
        pingpong: cf,
        smoothstep: hf,
        smootherstep: uf,
        randInt: df,
        randFloat: ff,
        randFloatSpread: pf,
        seededRandom: mf,
        degToRad: gf,
        radToDeg: xf,
        isPowerOfTwo: Fa,
        ceilPowerOfTwo: iu,
        floorPowerOfTwo: su,
        setQuaternionFromProperEuler: yf,
    }),
    W = class {
        constructor(e = 0, t = 0) {
            (this.x = e), (this.y = t);
        }
        get width() {
            return this.x;
        }
        set width(e) {
            this.x = e;
        }
        get height() {
            return this.y;
        }
        set height(e) {
            this.y = e;
        }
        set(e, t) {
            return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
            return (this.x = e), (this.y = e), this;
        }
        setX(e) {
            return (this.x = e), this;
        }
        setY(e) {
            return (this.y = e), this;
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e);
            }
            return this;
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e);
            }
        }
        clone() {
            return new this.constructor(this.x, this.y);
        }
        copy(e) {
            return (this.x = e.x), (this.y = e.y), this;
        }
        add(e, t) {
            return t !== void 0
                ? (console.warn(
                      "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                  ),
                  this.addVectors(e, t))
                : ((this.x += e.x), (this.y += e.y), this);
        }
        addScalar(e) {
            return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
            return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
            return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e, t) {
            return t !== void 0
                ? (console.warn(
                      "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                  ),
                  this.subVectors(e, t))
                : ((this.x -= e.x), (this.y -= e.y), this);
        }
        subScalar(e) {
            return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
            return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
            return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
            return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
            return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
            let t = this.x,
                n = this.y,
                i = e.elements;
            return (
                (this.x = i[0] * t + i[3] * n + i[6]),
                (this.y = i[1] * t + i[4] * n + i[7]),
                this
            );
        }
        min(e) {
            return (
                (this.x = Math.min(this.x, e.x)),
                (this.y = Math.min(this.y, e.y)),
                this
            );
        }
        max(e) {
            return (
                (this.x = Math.max(this.x, e.x)),
                (this.y = Math.max(this.y, e.y)),
                this
            );
        }
        clamp(e, t) {
            return (
                (this.x = Math.max(e.x, Math.min(t.x, this.x))),
                (this.y = Math.max(e.y, Math.min(t.y, this.y))),
                this
            );
        }
        clampScalar(e, t) {
            return (
                (this.x = Math.max(e, Math.min(t, this.x))),
                (this.y = Math.max(e, Math.min(t, this.y))),
                this
            );
        }
        clampLength(e, t) {
            let n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
                Math.max(e, Math.min(t, n))
            );
        }
        floor() {
            return (
                (this.x = Math.floor(this.x)),
                (this.y = Math.floor(this.y)),
                this
            );
        }
        ceil() {
            return (
                (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
        }
        round() {
            return (
                (this.x = Math.round(this.x)),
                (this.y = Math.round(this.y)),
                this
            );
        }
        roundToZero() {
            return (
                (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                this
            );
        }
        negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
            return this.x * e.x + this.y * e.y;
        }
        cross(e) {
            return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
            let t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n;
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
            return (
                (this.x += (e.x - this.x) * t),
                (this.y += (e.y - this.y) * t),
                this
            );
        }
        lerpVectors(e, t, n) {
            return (
                (this.x = e.x + (t.x - e.x) * n),
                (this.y = e.y + (t.y - e.y) * n),
                this
            );
        }
        equals(e) {
            return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
            return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
            return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t, n) {
            return (
                n !== void 0 &&
                    console.warn(
                        "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                    ),
                (this.x = e.getX(t)),
                (this.y = e.getY(t)),
                this
            );
        }
        rotateAround(e, t) {
            let n = Math.cos(t),
                i = Math.sin(t),
                s = this.x - e.x,
                o = this.y - e.y;
            return (
                (this.x = s * n - o * i + e.x),
                (this.y = s * i + o * n + e.y),
                this
            );
        }
        random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
            yield this.x, yield this.y;
        }
    };
W.prototype.isVector2 = !0;
var rt = class {
    constructor() {
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            arguments.length > 0 &&
                console.error(
                    "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
                );
    }
    set(e, t, n, i, s, o, a, l, c) {
        let h = this.elements;
        return (
            (h[0] = e),
            (h[1] = i),
            (h[2] = a),
            (h[3] = t),
            (h[4] = s),
            (h[5] = l),
            (h[6] = n),
            (h[7] = o),
            (h[8] = c),
            this
        );
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
        let t = this.elements,
            n = e.elements;
        return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
        );
    }
    extractBasis(e, t, n) {
        return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        );
    }
    setFromMatrix4(e) {
        let t = e.elements;
        return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        );
    }
    multiply(e) {
        return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
        let n = e.elements,
            i = t.elements,
            s = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            h = n[4],
            u = n[7],
            d = n[2],
            f = n[5],
            m = n[8],
            x = i[0],
            v = i[3],
            g = i[6],
            p = i[1],
            _ = i[4],
            y = i[7],
            w = i[2],
            A = i[5],
            C = i[8];
        return (
            (s[0] = o * x + a * p + l * w),
            (s[3] = o * v + a * _ + l * A),
            (s[6] = o * g + a * y + l * C),
            (s[1] = c * x + h * p + u * w),
            (s[4] = c * v + h * _ + u * A),
            (s[7] = c * g + h * y + u * C),
            (s[2] = d * x + f * p + m * w),
            (s[5] = d * v + f * _ + m * A),
            (s[8] = d * g + f * y + m * C),
            this
        );
    }
    multiplyScalar(e) {
        let t = this.elements;
        return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
        );
    }
    determinant() {
        let e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8];
        return (
            t * o * h -
            t * a * c -
            n * s * h +
            n * a * l +
            i * s * c -
            i * o * l
        );
    }
    invert() {
        let e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            h = e[8],
            u = h * o - a * c,
            d = a * l - h * s,
            f = c * s - o * l,
            m = t * u + n * d + i * f;
        if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        let x = 1 / m;
        return (
            (e[0] = u * x),
            (e[1] = (i * c - h * n) * x),
            (e[2] = (a * n - i * o) * x),
            (e[3] = d * x),
            (e[4] = (h * t - i * l) * x),
            (e[5] = (i * s - a * t) * x),
            (e[6] = f * x),
            (e[7] = (n * l - c * t) * x),
            (e[8] = (o * t - n * s) * x),
            this
        );
    }
    transpose() {
        let e,
            t = this.elements;
        return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
        );
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
        let t = this.elements;
        return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
        );
    }
    setUvTransform(e, t, n, i, s, o, a) {
        let l = Math.cos(s),
            c = Math.sin(s);
        return (
            this.set(
                n * l,
                n * c,
                -n * (l * o + c * a) + o + e,
                -i * c,
                i * l,
                -i * (-c * o + l * a) + a + t,
                0,
                0,
                1
            ),
            this
        );
    }
    scale(e, t) {
        let n = this.elements;
        return (
            (n[0] *= e),
            (n[3] *= e),
            (n[6] *= e),
            (n[1] *= t),
            (n[4] *= t),
            (n[7] *= t),
            this
        );
    }
    rotate(e) {
        let t = Math.cos(e),
            n = Math.sin(e),
            i = this.elements,
            s = i[0],
            o = i[3],
            a = i[6],
            l = i[1],
            c = i[4],
            h = i[7];
        return (
            (i[0] = t * s + n * l),
            (i[3] = t * o + n * c),
            (i[6] = t * a + n * h),
            (i[1] = -n * s + t * l),
            (i[4] = -n * o + t * c),
            (i[7] = -n * a + t * h),
            this
        );
    }
    translate(e, t) {
        let n = this.elements;
        return (
            (n[0] += e * n[2]),
            (n[3] += e * n[5]),
            (n[6] += e * n[8]),
            (n[1] += t * n[2]),
            (n[4] += t * n[5]),
            (n[7] += t * n[8]),
            this
        );
    }
    equals(e) {
        let t = this.elements,
            n = e.elements;
        for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
        return !0;
    }
    fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
        return this;
    }
    toArray(e = [], t = 0) {
        let n = this.elements;
        return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
        );
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
};
rt.prototype.isMatrix3 = !0;
function ru(r) {
    if (r.length === 0) return -1 / 0;
    let e = r[0];
    for (let t = 1, n = r.length; t < n; ++t) r[t] > e && (e = r[t]);
    return e;
}
var vf = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
};
function Ti(r, e) {
    return new vf[r](e);
}
function qo(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
var ii,
    En = class {
        static getDataURL(e) {
            if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
                return e.src;
            let t;
            if (e instanceof HTMLCanvasElement) t = e;
            else {
                ii === void 0 && (ii = qo("canvas")),
                    (ii.width = e.width),
                    (ii.height = e.height);
                let n = ii.getContext("2d");
                e instanceof ImageData
                    ? n.putImageData(e, 0, 0)
                    : n.drawImage(e, 0, 0, e.width, e.height),
                    (t = ii);
            }
            return t.width > 2048 || t.height > 2048
                ? (console.warn(
                      "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                      e
                  ),
                  t.toDataURL("image/jpeg", 0.6))
                : t.toDataURL("image/png");
        }
    },
    _f = 0,
    ft = class r extends cn {
        constructor(
            e = r.DEFAULT_IMAGE,
            t = r.DEFAULT_MAPPING,
            n = yt,
            i = yt,
            s = tt,
            o = $i,
            a = lt,
            l = an,
            c = 1,
            h = Ot
        ) {
            super(),
                Object.defineProperty(this, "id", { value: _f++ }),
                (this.uuid = Ct()),
                (this.name = ""),
                (this.image = e),
                (this.mipmaps = []),
                (this.mapping = t),
                (this.wrapS = n),
                (this.wrapT = i),
                (this.magFilter = s),
                (this.minFilter = o),
                (this.anisotropy = c),
                (this.format = a),
                (this.internalFormat = null),
                (this.type = l),
                (this.offset = new W(0, 0)),
                (this.repeat = new W(1, 1)),
                (this.center = new W(0, 0)),
                (this.rotation = 0),
                (this.matrixAutoUpdate = !0),
                (this.matrix = new rt()),
                (this.generateMipmaps = !0),
                (this.premultiplyAlpha = !1),
                (this.flipY = !0),
                (this.unpackAlignment = 4),
                (this.encoding = h),
                (this.userData = {}),
                (this.version = 0),
                (this.onUpdate = null),
                (this.isRenderTargetTexture = !1);
        }
        updateMatrix() {
            this.matrix.setUvTransform(
                this.offset.x,
                this.offset.y,
                this.repeat.x,
                this.repeat.y,
                this.rotation,
                this.center.x,
                this.center.y
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return (
                (this.name = e.name),
                (this.image = e.image),
                (this.mipmaps = e.mipmaps.slice(0)),
                (this.mapping = e.mapping),
                (this.wrapS = e.wrapS),
                (this.wrapT = e.wrapT),
                (this.magFilter = e.magFilter),
                (this.minFilter = e.minFilter),
                (this.anisotropy = e.anisotropy),
                (this.format = e.format),
                (this.internalFormat = e.internalFormat),
                (this.type = e.type),
                this.offset.copy(e.offset),
                this.repeat.copy(e.repeat),
                this.center.copy(e.center),
                (this.rotation = e.rotation),
                (this.matrixAutoUpdate = e.matrixAutoUpdate),
                this.matrix.copy(e.matrix),
                (this.generateMipmaps = e.generateMipmaps),
                (this.premultiplyAlpha = e.premultiplyAlpha),
                (this.flipY = e.flipY),
                (this.unpackAlignment = e.unpackAlignment),
                (this.encoding = e.encoding),
                (this.userData = JSON.parse(JSON.stringify(e.userData))),
                this
            );
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string";
            if (!t && e.textures[this.uuid] !== void 0)
                return e.textures[this.uuid];
            let n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON",
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment,
            };
            if (this.image !== void 0) {
                let i = this.image;
                if (
                    (i.uuid === void 0 && (i.uuid = Ct()),
                    !t && e.images[i.uuid] === void 0)
                ) {
                    let s;
                    if (Array.isArray(i)) {
                        s = [];
                        for (let o = 0, a = i.length; o < a; o++)
                            i[o].isDataTexture
                                ? s.push(jo(i[o].image))
                                : s.push(jo(i[o]));
                    } else s = jo(i);
                    e.images[i.uuid] = { uuid: i.uuid, url: s };
                }
                n.image = i.uuid;
            }
            return (
                JSON.stringify(this.userData) !== "{}" &&
                    (n.userData = this.userData),
                t || (e.textures[this.uuid] = n),
                n
            );
        }
        dispose() {
            this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
            if (this.mapping !== Fl) return e;
            if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
                switch (this.wrapS) {
                    case qr:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case yt:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case Xr:
                        Math.abs(Math.floor(e.x) % 2) === 1
                            ? (e.x = Math.ceil(e.x) - e.x)
                            : (e.x = e.x - Math.floor(e.x));
                        break;
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                    case qr:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case yt:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case Xr:
                        Math.abs(Math.floor(e.y) % 2) === 1
                            ? (e.y = Math.ceil(e.y) - e.y)
                            : (e.y = e.y - Math.floor(e.y));
                        break;
                }
            return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
    };
ft.DEFAULT_IMAGE = void 0;
ft.DEFAULT_MAPPING = Fl;
ft.prototype.isTexture = !0;
function jo(r) {
    return (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && r instanceof ImageBitmap)
        ? En.getDataURL(r)
        : r.data
        ? {
              data: Array.prototype.slice.call(r.data),
              width: r.width,
              height: r.height,
              type: r.data.constructor.name,
          }
        : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
var Ve = class {
    constructor(e = 0, t = 0, n = 0, i = 1) {
        (this.x = e), (this.y = t), (this.z = n), (this.w = i);
    }
    get width() {
        return this.z;
    }
    set width(e) {
        this.z = e;
    }
    get height() {
        return this.w;
    }
    set height(e) {
        this.w = e;
    }
    set(e, t, n, i) {
        return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setZ(e) {
        return (this.z = e), this;
    }
    setW(e) {
        return (this.w = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
        return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = e.w !== void 0 ? e.w : 1),
            this
        );
    }
    add(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x),
              (this.y += e.y),
              (this.z += e.z),
              (this.w += e.w),
              this);
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
    }
    addVectors(e, t) {
        return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
        );
    }
    addScaledVector(e, t) {
        return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
        );
    }
    sub(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x),
              (this.y -= e.y),
              (this.z -= e.z),
              (this.w -= e.w),
              this);
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
    }
    subVectors(e, t) {
        return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
        );
    }
    multiply(e) {
        return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
        );
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
    }
    applyMatrix4(e) {
        let t = this.x,
            n = this.y,
            i = this.z,
            s = this.w,
            o = e.elements;
        return (
            (this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s),
            (this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s),
            (this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s),
            (this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s),
            this
        );
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        let t = Math.sqrt(1 - e.w * e.w);
        return (
            t < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
        );
    }
    setAxisAngleFromRotationMatrix(e) {
        let t,
            n,
            i,
            s,
            l = e.elements,
            c = l[0],
            h = l[4],
            u = l[8],
            d = l[1],
            f = l[5],
            m = l[9],
            x = l[2],
            v = l[6],
            g = l[10];
        if (
            Math.abs(h - d) < 0.01 &&
            Math.abs(u - x) < 0.01 &&
            Math.abs(m - v) < 0.01
        ) {
            if (
                Math.abs(h + d) < 0.1 &&
                Math.abs(u + x) < 0.1 &&
                Math.abs(m + v) < 0.1 &&
                Math.abs(c + f + g - 3) < 0.1
            )
                return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            let _ = (c + 1) / 2,
                y = (f + 1) / 2,
                w = (g + 1) / 2,
                A = (h + d) / 4,
                C = (u + x) / 4,
                I = (m + v) / 4;
            return (
                _ > y && _ > w
                    ? _ < 0.01
                        ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
                        : ((n = Math.sqrt(_)), (i = A / n), (s = C / n))
                    : y > w
                    ? y < 0.01
                        ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
                        : ((i = Math.sqrt(y)), (n = A / i), (s = I / i))
                    : w < 0.01
                    ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
                    : ((s = Math.sqrt(w)), (n = C / s), (i = I / s)),
                this.set(n, i, s, t),
                this
            );
        }
        let p = Math.sqrt(
            (v - m) * (v - m) + (u - x) * (u - x) + (d - h) * (d - h)
        );
        return (
            Math.abs(p) < 0.001 && (p = 1),
            (this.x = (v - m) / p),
            (this.y = (u - x) / p),
            (this.z = (d - h) / p),
            (this.w = Math.acos((c + f + g - 1) / 2)),
            this
        );
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
        );
    }
    clampLength(e, t) {
        let n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
        );
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
        );
    }
    ceil() {
        return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
        );
    }
    round() {
        return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
        );
    }
    roundToZero() {
        return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
        );
    }
    negate() {
        return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
        );
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
        return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
        );
    }
    length() {
        return Math.sqrt(
            this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
        );
    }
    manhattanLength() {
        return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
        );
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
        );
    }
    lerpVectors(e, t, n) {
        return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
        );
    }
    equals(e) {
        return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        );
    }
    fromArray(e, t = 0) {
        return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
        );
    }
    fromBufferAttribute(e, t, n) {
        return (
            n !== void 0 &&
                console.warn(
                    "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
        );
    }
    random() {
        return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
        );
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
    }
};
Ve.prototype.isVector4 = !0;
var St = class extends cn {
    constructor(e, t, n = {}) {
        super(),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Ve(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Ve(0, 0, e, t)),
            (this.texture = new ft(
                void 0,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.image = { width: e, height: t, depth: 1 }),
            (this.texture.generateMipmaps =
                n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
            (this.texture.internalFormat =
                n.internalFormat !== void 0 ? n.internalFormat : null),
            (this.texture.minFilter =
                n.minFilter !== void 0 ? n.minFilter : tt),
            (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
            (this.stencilBuffer =
                n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
            (this.depthTexture =
                n.depthTexture !== void 0 ? n.depthTexture : null);
    }
    setTexture(e) {
        (e.image = {
            width: this.width,
            height: this.height,
            depth: this.depth,
        }),
            (this.texture = e);
    }
    setSize(e, t, n = 1) {
        (this.width !== e || this.height !== t || this.depth !== n) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = n),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(e) {
        return (
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.image = { ...this.texture.image }),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            this
        );
    }
    dispose() {
        this.dispatchEvent({ type: "dispose" });
    }
};
St.prototype.isWebGLRenderTarget = !0;
var Na = class extends St {
    constructor(e, t, n) {
        super(e, t);
        let i = this.texture;
        this.texture = [];
        for (let s = 0; s < n; s++) this.texture[s] = i.clone();
    }
    setSize(e, t, n = 1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, s = this.texture.length; i < s; i++)
                (this.texture[i].image.width = e),
                    (this.texture[i].image.height = t),
                    (this.texture[i].image.depth = n);
            this.dispose();
        }
        return (
            this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
        );
    }
    copy(e) {
        this.dispose(),
            (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.depthTexture = e.depthTexture),
            (this.texture.length = 0);
        for (let t = 0, n = e.texture.length; t < n; t++)
            this.texture[t] = e.texture[t].clone();
        return this;
    }
};
Na.prototype.isWebGLMultipleRenderTargets = !0;
var ws = class extends St {
    constructor(e, t, n = {}) {
        super(e, t, n),
            (this.samples = 4),
            (this.ignoreDepthForMultisampleCopy =
                n.ignoreDepth !== void 0 ? n.ignoreDepth : !0),
            (this.useRenderToTexture =
                n.useRenderToTexture !== void 0 ? n.useRenderToTexture : !1),
            (this.useRenderbuffer = this.useRenderToTexture === !1);
    }
    copy(e) {
        return (
            super.copy.call(this, e),
            (this.samples = e.samples),
            (this.useRenderToTexture = e.useRenderToTexture),
            (this.useRenderbuffer = e.useRenderbuffer),
            this
        );
    }
};
ws.prototype.isWebGLMultisampleRenderTarget = !0;
var dt = class {
    constructor(e = 0, t = 0, n = 0, i = 1) {
        (this._x = e), (this._y = t), (this._z = n), (this._w = i);
    }
    static slerp(e, t, n, i) {
        return (
            console.warn(
                "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
            ),
            n.slerpQuaternions(e, t, i)
        );
    }
    static slerpFlat(e, t, n, i, s, o, a) {
        let l = n[i + 0],
            c = n[i + 1],
            h = n[i + 2],
            u = n[i + 3],
            d = s[o + 0],
            f = s[o + 1],
            m = s[o + 2],
            x = s[o + 3];
        if (a === 0) {
            (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
            return;
        }
        if (a === 1) {
            (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = m), (e[t + 3] = x);
            return;
        }
        if (u !== x || l !== d || c !== f || h !== m) {
            let v = 1 - a,
                g = l * d + c * f + h * m + u * x,
                p = g >= 0 ? 1 : -1,
                _ = 1 - g * g;
            if (_ > Number.EPSILON) {
                let w = Math.sqrt(_),
                    A = Math.atan2(w, g * p);
                (v = Math.sin(v * A) / w), (a = Math.sin(a * A) / w);
            }
            let y = a * p;
            if (
                ((l = l * v + d * y),
                (c = c * v + f * y),
                (h = h * v + m * y),
                (u = u * v + x * y),
                v === 1 - a)
            ) {
                let w = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
                (l *= w), (c *= w), (h *= w), (u *= w);
            }
        }
        (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
    }
    static multiplyQuaternionsFlat(e, t, n, i, s, o) {
        let a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            u = s[o],
            d = s[o + 1],
            f = s[o + 2],
            m = s[o + 3];
        return (
            (e[t] = a * m + h * u + l * f - c * d),
            (e[t + 1] = l * m + h * d + c * u - a * f),
            (e[t + 2] = c * m + h * f + a * d - l * u),
            (e[t + 3] = h * m - a * u - l * d - c * f),
            e
        );
    }
    get x() {
        return this._x;
    }
    set x(e) {
        (this._x = e), this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(e) {
        (this._y = e), this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(e) {
        (this._z = e), this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(e) {
        (this._w = e), this._onChangeCallback();
    }
    set(e, t, n, i) {
        return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
        );
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
        return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
        );
    }
    setFromEuler(e, t) {
        if (!(e && e.isEuler))
            throw new Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
        let n = e._x,
            i = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            h = a(i / 2),
            u = a(s / 2),
            d = l(n / 2),
            f = l(i / 2),
            m = l(s / 2);
        switch (o) {
            case "XYZ":
                (this._x = d * h * u + c * f * m),
                    (this._y = c * f * u - d * h * m),
                    (this._z = c * h * m + d * f * u),
                    (this._w = c * h * u - d * f * m);
                break;
            case "YXZ":
                (this._x = d * h * u + c * f * m),
                    (this._y = c * f * u - d * h * m),
                    (this._z = c * h * m - d * f * u),
                    (this._w = c * h * u + d * f * m);
                break;
            case "ZXY":
                (this._x = d * h * u - c * f * m),
                    (this._y = c * f * u + d * h * m),
                    (this._z = c * h * m + d * f * u),
                    (this._w = c * h * u - d * f * m);
                break;
            case "ZYX":
                (this._x = d * h * u - c * f * m),
                    (this._y = c * f * u + d * h * m),
                    (this._z = c * h * m - d * f * u),
                    (this._w = c * h * u + d * f * m);
                break;
            case "YZX":
                (this._x = d * h * u + c * f * m),
                    (this._y = c * f * u + d * h * m),
                    (this._z = c * h * m - d * f * u),
                    (this._w = c * h * u - d * f * m);
                break;
            case "XZY":
                (this._x = d * h * u - c * f * m),
                    (this._y = c * f * u - d * h * m),
                    (this._z = c * h * m + d * f * u),
                    (this._w = c * h * u + d * f * m);
                break;
            default:
                console.warn(
                    "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                        o
                );
        }
        return t !== !1 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
        let n = t / 2,
            i = Math.sin(n);
        return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
        );
    }
    setFromRotationMatrix(e) {
        let t = e.elements,
            n = t[0],
            i = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            h = t[6],
            u = t[10],
            d = n + a + u;
        if (d > 0) {
            let f = 0.5 / Math.sqrt(d + 1);
            (this._w = 0.25 / f),
                (this._x = (h - l) * f),
                (this._y = (s - c) * f),
                (this._z = (o - i) * f);
        } else if (n > a && n > u) {
            let f = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (h - l) / f),
                (this._x = 0.25 * f),
                (this._y = (i + o) / f),
                (this._z = (s + c) / f);
        } else if (a > u) {
            let f = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (s - c) / f),
                (this._x = (i + o) / f),
                (this._y = 0.25 * f),
                (this._z = (l + h) / f);
        } else {
            let f = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (o - i) / f),
                (this._x = (s + c) / f),
                (this._y = (l + h) / f),
                (this._z = 0.25 * f);
        }
        return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return (
            n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(e.x) > Math.abs(e.z)
                      ? ((this._x = -e.y),
                        (this._y = e.x),
                        (this._z = 0),
                        (this._w = n))
                      : ((this._x = 0),
                        (this._y = -e.z),
                        (this._z = e.y),
                        (this._w = n)))
                : ((this._x = e.y * t.z - e.z * t.y),
                  (this._y = e.z * t.x - e.x * t.z),
                  (this._z = e.x * t.y - e.y * t.x),
                  (this._w = n)),
            this.normalize()
        );
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(mt(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
        let n = this.angleTo(e);
        if (n === 0) return this;
        let i = Math.min(1, t / n);
        return this.slerp(e, i), this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        return this.conjugate();
    }
    conjugate() {
        return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
        );
    }
    dot(e) {
        return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        );
    }
    lengthSq() {
        return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
    }
    length() {
        return Math.sqrt(
            this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
        );
    }
    normalize() {
        let e = this.length();
        return (
            e === 0
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((e = 1 / e),
                  (this._x = this._x * e),
                  (this._y = this._y * e),
                  (this._z = this._z * e),
                  (this._w = this._w * e)),
            this._onChangeCallback(),
            this
        );
    }
    multiply(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(e, t))
            : this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
        let n = e._x,
            i = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            h = t._w;
        return (
            (this._x = n * h + o * a + i * c - s * l),
            (this._y = i * h + o * l + s * a - n * c),
            (this._z = s * h + o * c + n * l - i * a),
            (this._w = o * h - n * a - i * l - s * c),
            this._onChangeCallback(),
            this
        );
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        let n = this._x,
            i = this._y,
            s = this._z,
            o = this._w,
            a = o * e._w + n * e._x + i * e._y + s * e._z;
        if (
            (a < 0
                ? ((this._w = -e._w),
                  (this._x = -e._x),
                  (this._y = -e._y),
                  (this._z = -e._z),
                  (a = -a))
                : this.copy(e),
            a >= 1)
        )
            return (
                (this._w = o), (this._x = n), (this._y = i), (this._z = s), this
            );
        let l = 1 - a * a;
        if (l <= Number.EPSILON) {
            let f = 1 - t;
            return (
                (this._w = f * o + t * this._w),
                (this._x = f * n + t * this._x),
                (this._y = f * i + t * this._y),
                (this._z = f * s + t * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
            );
        }
        let c = Math.sqrt(l),
            h = Math.atan2(c, a),
            u = Math.sin((1 - t) * h) / c,
            d = Math.sin(t * h) / c;
        return (
            (this._w = o * u + this._w * d),
            (this._x = n * u + this._x * d),
            (this._y = i * u + this._y * d),
            (this._z = s * u + this._z * d),
            this._onChangeCallback(),
            this
        );
    }
    slerpQuaternions(e, t, n) {
        this.copy(e).slerp(t, n);
    }
    random() {
        let e = Math.random(),
            t = Math.sqrt(1 - e),
            n = Math.sqrt(e),
            i = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
        return this.set(
            t * Math.cos(i),
            n * Math.sin(s),
            n * Math.cos(s),
            t * Math.sin(i)
        );
    }
    equals(e) {
        return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
        );
    }
    fromArray(e, t = 0) {
        return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
        );
    }
    toArray(e = [], t = 0) {
        return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
        );
    }
    fromBufferAttribute(e, t) {
        return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
        );
    }
    _onChange(e) {
        return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
};
dt.prototype.isQuaternion = !0;
var M = class {
    constructor(e = 0, t = 0, n = 0) {
        (this.x = e), (this.y = t), (this.z = n);
    }
    set(e, t, n) {
        return (
            n === void 0 && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
        );
    }
    setScalar(e) {
        return (this.x = e), (this.y = e), (this.z = e), this;
    }
    setX(e) {
        return (this.x = e), this;
    }
    setY(e) {
        return (this.y = e), this;
    }
    setZ(e) {
        return (this.z = e), this;
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e);
        }
        return this;
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
        return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
    }
    add(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(e, t))
            : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
    }
    addScalar(e) {
        return (this.x += e), (this.y += e), (this.z += e), this;
    }
    addVectors(e, t) {
        return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
        );
    }
    addScaledVector(e, t) {
        return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
        );
    }
    sub(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(e, t))
            : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
    }
    subScalar(e) {
        return (this.x -= e), (this.y -= e), (this.z -= e), this;
    }
    subVectors(e, t) {
        return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
        );
    }
    multiply(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(e, t))
            : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
    }
    multiplyScalar(e) {
        return (this.x *= e), (this.y *= e), (this.z *= e), this;
    }
    multiplyVectors(e, t) {
        return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
        );
    }
    applyEuler(e) {
        return (
            (e && e.isEuler) ||
                console.error(
                    "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                ),
            this.applyQuaternion(cc.setFromEuler(e))
        );
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(cc.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
        let t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements;
        return (
            (this.x = s[0] * t + s[3] * n + s[6] * i),
            (this.y = s[1] * t + s[4] * n + s[7] * i),
            (this.z = s[2] * t + s[5] * n + s[8] * i),
            this
        );
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
        let t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
        return (
            (this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o),
            (this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o),
            (this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o),
            this
        );
    }
    applyQuaternion(e) {
        let t = this.x,
            n = this.y,
            i = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * i - a * n,
            h = l * n + a * t - s * i,
            u = l * i + s * n - o * t,
            d = -s * t - o * n - a * i;
        return (
            (this.x = c * l + d * -s + h * -a - u * -o),
            (this.y = h * l + d * -o + u * -s - c * -a),
            (this.z = u * l + d * -a + c * -o - h * -s),
            this
        );
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
        );
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
        );
    }
    transformDirection(e) {
        let t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements;
        return (
            (this.x = s[0] * t + s[4] * n + s[8] * i),
            (this.y = s[1] * t + s[5] * n + s[9] * i),
            (this.z = s[2] * t + s[6] * n + s[10] * i),
            this.normalize()
        );
    }
    divide(e) {
        return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e);
    }
    min(e) {
        return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
        );
    }
    max(e) {
        return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
        );
    }
    clamp(e, t) {
        return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
        );
    }
    clampScalar(e, t) {
        return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
        );
    }
    clampLength(e, t) {
        let n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
        );
    }
    floor() {
        return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
        );
    }
    ceil() {
        return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
        );
    }
    round() {
        return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
        );
    }
    roundToZero() {
        return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
        );
    }
    negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
        return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
        );
    }
    lerpVectors(e, t, n) {
        return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
        );
    }
    cross(e, t) {
        return t !== void 0
            ? (console.warn(
                  "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(e, t))
            : this.crossVectors(this, e);
    }
    crossVectors(e, t) {
        let n = e.x,
            i = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
        return (
            (this.x = i * l - s * a),
            (this.y = s * o - n * l),
            (this.z = n * a - i * o),
            this
        );
    }
    projectOnVector(e) {
        let t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        let n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n);
    }
    projectOnPlane(e) {
        return Qo.copy(this).projectOnVector(e), this.sub(Qo);
    }
    reflect(e) {
        return this.sub(Qo.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
        let t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        let n = this.dot(e) / t;
        return Math.acos(mt(n, -1, 1));
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
        let t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
        return t * t + n * n + i * i;
    }
    manhattanDistanceTo(e) {
        return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
        );
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, n) {
        let i = Math.sin(t) * e;
        return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
        );
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, n) {
        return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
        );
    }
    setFromMatrixPosition(e) {
        let t = e.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
    }
    setFromMatrixScale(e) {
        let t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
        return (this.x = t), (this.y = n), (this.z = i), this;
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3);
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
        return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
    }
    fromBufferAttribute(e, t, n) {
        return (
            n !== void 0 &&
                console.warn(
                    "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                ),
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
        );
    }
    random() {
        return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
        );
    }
    randomDirection() {
        let e = (Math.random() - 0.5) * 2,
            t = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - e ** 2);
        return (
            (this.x = n * Math.cos(t)),
            (this.y = n * Math.sin(t)),
            (this.z = e),
            this
        );
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
    }
};
M.prototype.isVector3 = !0;
var Qo = new M(),
    cc = new dt(),
    Tt = class {
        constructor(
            e = new M(1 / 0, 1 / 0, 1 / 0),
            t = new M(-1 / 0, -1 / 0, -1 / 0)
        ) {
            (this.min = e), (this.max = t);
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
            let t = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                s = -1 / 0,
                o = -1 / 0,
                a = -1 / 0;
            for (let l = 0, c = e.length; l < c; l += 3) {
                let h = e[l],
                    u = e[l + 1],
                    d = e[l + 2];
                h < t && (t = h),
                    u < n && (n = u),
                    d < i && (i = d),
                    h > s && (s = h),
                    u > o && (o = u),
                    d > a && (a = d);
            }
            return this.min.set(t, n, i), this.max.set(s, o, a), this;
        }
        setFromBufferAttribute(e) {
            let t = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                s = -1 / 0,
                o = -1 / 0,
                a = -1 / 0;
            for (let l = 0, c = e.count; l < c; l++) {
                let h = e.getX(l),
                    u = e.getY(l),
                    d = e.getZ(l);
                h < t && (t = h),
                    u < n && (n = u),
                    d < i && (i = d),
                    h > s && (s = h),
                    u > o && (o = u),
                    d > a && (a = d);
            }
            return this.min.set(t, n, i), this.max.set(s, o, a), this;
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this;
        }
        setFromCenterAndSize(e, t) {
            let n = ts.copy(t).multiplyScalar(0.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e) {
            return this.makeEmpty(), this.expandByObject(e);
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
            return (
                (this.min.x = this.min.y = this.min.z = 1 / 0),
                (this.max.x = this.max.y = this.max.z = -1 / 0),
                this
            );
        }
        isEmpty() {
            return (
                this.max.x < this.min.x ||
                this.max.y < this.min.y ||
                this.max.z < this.min.z
            );
        }
        getCenter(e) {
            return this.isEmpty()
                ? e.set(0, 0, 0)
                : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
            return this.isEmpty()
                ? e.set(0, 0, 0)
                : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e) {
            e.updateWorldMatrix(!1, !1);
            let t = e.geometry;
            t !== void 0 &&
                (t.boundingBox === null && t.computeBoundingBox(),
                Ko.copy(t.boundingBox),
                Ko.applyMatrix4(e.matrixWorld),
                this.union(Ko));
            let n = e.children;
            for (let i = 0, s = n.length; i < s; i++) this.expandByObject(n[i]);
            return this;
        }
        containsPoint(e) {
            return !(
                e.x < this.min.x ||
                e.x > this.max.x ||
                e.y < this.min.y ||
                e.y > this.max.y ||
                e.z < this.min.z ||
                e.z > this.max.z
            );
        }
        containsBox(e) {
            return (
                this.min.x <= e.min.x &&
                e.max.x <= this.max.x &&
                this.min.y <= e.min.y &&
                e.max.y <= this.max.y &&
                this.min.z <= e.min.z &&
                e.max.z <= this.max.z
            );
        }
        getParameter(e, t) {
            return t.set(
                (e.x - this.min.x) / (this.max.x - this.min.x),
                (e.y - this.min.y) / (this.max.y - this.min.y),
                (e.z - this.min.z) / (this.max.z - this.min.z)
            );
        }
        intersectsBox(e) {
            return !(
                e.max.x < this.min.x ||
                e.min.x > this.max.x ||
                e.max.y < this.min.y ||
                e.min.y > this.max.y ||
                e.max.z < this.min.z ||
                e.min.z > this.max.z
            );
        }
        intersectsSphere(e) {
            return (
                this.clampPoint(e.center, ts),
                ts.distanceToSquared(e.center) <= e.radius * e.radius
            );
        }
        intersectsPlane(e) {
            let t, n;
            return (
                e.normal.x > 0
                    ? ((t = e.normal.x * this.min.x),
                      (n = e.normal.x * this.max.x))
                    : ((t = e.normal.x * this.max.x),
                      (n = e.normal.x * this.min.x)),
                e.normal.y > 0
                    ? ((t += e.normal.y * this.min.y),
                      (n += e.normal.y * this.max.y))
                    : ((t += e.normal.y * this.max.y),
                      (n += e.normal.y * this.min.y)),
                e.normal.z > 0
                    ? ((t += e.normal.z * this.min.z),
                      (n += e.normal.z * this.max.z))
                    : ((t += e.normal.z * this.max.z),
                      (n += e.normal.z * this.min.z)),
                t <= -e.constant && n >= -e.constant
            );
        }
        intersectsTriangle(e) {
            if (this.isEmpty()) return !1;
            this.getCenter(ns),
                tr.subVectors(this.max, ns),
                si.subVectors(e.a, ns),
                ri.subVectors(e.b, ns),
                oi.subVectors(e.c, ns),
                dn.subVectors(ri, si),
                fn.subVectors(oi, ri),
                Bn.subVectors(si, oi);
            let t = [
                0,
                -dn.z,
                dn.y,
                0,
                -fn.z,
                fn.y,
                0,
                -Bn.z,
                Bn.y,
                dn.z,
                0,
                -dn.x,
                fn.z,
                0,
                -fn.x,
                Bn.z,
                0,
                -Bn.x,
                -dn.y,
                dn.x,
                0,
                -fn.y,
                fn.x,
                0,
                -Bn.y,
                Bn.x,
                0,
            ];
            return !ea(t, si, ri, oi, tr) ||
                ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !ea(t, si, ri, oi, tr))
                ? !1
                : (nr.crossVectors(dn, fn),
                  (t = [nr.x, nr.y, nr.z]),
                  ea(t, si, ri, oi, tr));
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
            return ts.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
            return (
                this.getCenter(e.center),
                (e.radius = this.getSize(ts).length() * 0.5),
                e
            );
        }
        intersect(e) {
            return (
                this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            );
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
            return this.isEmpty()
                ? this
                : (Kt[0]
                      .set(this.min.x, this.min.y, this.min.z)
                      .applyMatrix4(e),
                  Kt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                  Kt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                  Kt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                  Kt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                  Kt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                  Kt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                  Kt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                  this.setFromPoints(Kt),
                  this);
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        }
    };
Tt.prototype.isBox3 = !0;
var Kt = [
        new M(),
        new M(),
        new M(),
        new M(),
        new M(),
        new M(),
        new M(),
        new M(),
    ],
    ts = new M(),
    Ko = new Tt(),
    si = new M(),
    ri = new M(),
    oi = new M(),
    dn = new M(),
    fn = new M(),
    Bn = new M(),
    ns = new M(),
    tr = new M(),
    nr = new M(),
    Un = new M();
function ea(r, e, t, n, i) {
    for (let s = 0, o = r.length - 3; s <= o; s += 3) {
        Un.fromArray(r, s);
        let a =
                i.x * Math.abs(Un.x) +
                i.y * Math.abs(Un.y) +
                i.z * Math.abs(Un.z),
            l = e.dot(Un),
            c = t.dot(Un),
            h = n.dot(Un);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
    }
    return !0;
}
var Mf = new Tt(),
    hc = new M(),
    ir = new M(),
    ta = new M(),
    hn = class {
        constructor(e = new M(), t = -1) {
            (this.center = e), (this.radius = t);
        }
        set(e, t) {
            return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
            let n = this.center;
            t !== void 0 ? n.copy(t) : Mf.setFromPoints(e).getCenter(n);
            let i = 0;
            for (let s = 0, o = e.length; s < o; s++)
                i = Math.max(i, n.distanceToSquared(e[s]));
            return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
            return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
            return this.radius < 0;
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
            return (
                e.distanceToSquared(this.center) <= this.radius * this.radius
            );
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
            let t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
            return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
            let n = this.center.distanceToSquared(e);
            return (
                t.copy(e),
                n > this.radius * this.radius &&
                    (t.sub(this.center).normalize(),
                    t.multiplyScalar(this.radius).add(this.center)),
                t
            );
        }
        getBoundingBox(e) {
            return this.isEmpty()
                ? (e.makeEmpty(), e)
                : (e.set(this.center, this.center),
                  e.expandByScalar(this.radius),
                  e);
        }
        applyMatrix4(e) {
            return (
                this.center.applyMatrix4(e),
                (this.radius = this.radius * e.getMaxScaleOnAxis()),
                this
            );
        }
        translate(e) {
            return this.center.add(e), this;
        }
        expandByPoint(e) {
            ta.subVectors(e, this.center);
            let t = ta.lengthSq();
            if (t > this.radius * this.radius) {
                let n = Math.sqrt(t),
                    i = (n - this.radius) * 0.5;
                this.center.add(ta.multiplyScalar(i / n)), (this.radius += i);
            }
            return this;
        }
        union(e) {
            return (
                this.center.equals(e.center) === !0
                    ? ir.set(0, 0, 1).multiplyScalar(e.radius)
                    : ir
                          .subVectors(e.center, this.center)
                          .normalize()
                          .multiplyScalar(e.radius),
                this.expandByPoint(hc.copy(e.center).add(ir)),
                this.expandByPoint(hc.copy(e.center).sub(ir)),
                this
            );
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    },
    en = new M(),
    na = new M(),
    sr = new M(),
    pn = new M(),
    ia = new M(),
    rr = new M(),
    sa = new M(),
    un = class {
        constructor(e = new M(), t = new M(0, 0, -1)) {
            (this.origin = e), (this.direction = t);
        }
        set(e, t) {
            return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
            return (
                this.origin.copy(e.origin),
                this.direction.copy(e.direction),
                this
            );
        }
        at(e, t) {
            return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
            return this.origin.copy(this.at(e, en)), this;
        }
        closestPointToPoint(e, t) {
            t.subVectors(e, this.origin);
            let n = t.dot(this.direction);
            return n < 0
                ? t.copy(this.origin)
                : t.copy(this.direction).multiplyScalar(n).add(this.origin);
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
            let t = en.subVectors(e, this.origin).dot(this.direction);
            return t < 0
                ? this.origin.distanceToSquared(e)
                : (en.copy(this.direction).multiplyScalar(t).add(this.origin),
                  en.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
            na.copy(e).add(t).multiplyScalar(0.5),
                sr.copy(t).sub(e).normalize(),
                pn.copy(this.origin).sub(na);
            let s = e.distanceTo(t) * 0.5,
                o = -this.direction.dot(sr),
                a = pn.dot(this.direction),
                l = -pn.dot(sr),
                c = pn.lengthSq(),
                h = Math.abs(1 - o * o),
                u,
                d,
                f,
                m;
            if (h > 0)
                if (((u = o * l - a), (d = o * a - l), (m = s * h), u >= 0))
                    if (d >= -m)
                        if (d <= m) {
                            let x = 1 / h;
                            (u *= x),
                                (d *= x),
                                (f =
                                    u * (u + o * d + 2 * a) +
                                    d * (o * u + d + 2 * l) +
                                    c);
                        } else
                            (d = s),
                                (u = Math.max(0, -(o * d + a))),
                                (f = -u * u + d * (d + 2 * l) + c);
                    else
                        (d = -s),
                            (u = Math.max(0, -(o * d + a))),
                            (f = -u * u + d * (d + 2 * l) + c);
                else
                    d <= -m
                        ? ((u = Math.max(0, -(-o * s + a))),
                          (d = u > 0 ? -s : Math.min(Math.max(-s, -l), s)),
                          (f = -u * u + d * (d + 2 * l) + c))
                        : d <= m
                        ? ((u = 0),
                          (d = Math.min(Math.max(-s, -l), s)),
                          (f = d * (d + 2 * l) + c))
                        : ((u = Math.max(0, -(o * s + a))),
                          (d = u > 0 ? s : Math.min(Math.max(-s, -l), s)),
                          (f = -u * u + d * (d + 2 * l) + c));
            else
                (d = o > 0 ? -s : s),
                    (u = Math.max(0, -(o * d + a))),
                    (f = -u * u + d * (d + 2 * l) + c);
            return (
                n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
                i && i.copy(sr).multiplyScalar(d).add(na),
                f
            );
        }
        intersectSphere(e, t) {
            en.subVectors(e.center, this.origin);
            let n = en.dot(this.direction),
                i = en.dot(en) - n * n,
                s = e.radius * e.radius;
            if (i > s) return null;
            let o = Math.sqrt(s - i),
                a = n - o,
                l = n + o;
            return a < 0 && l < 0
                ? null
                : a < 0
                ? this.at(l, t)
                : this.at(a, t);
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
            let t = e.normal.dot(this.direction);
            if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
            let n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
            let n = this.distanceToPlane(e);
            return n === null ? null : this.at(n, t);
        }
        intersectsPlane(e) {
            let t = e.distanceToPoint(this.origin);
            return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
            let n,
                i,
                s,
                o,
                a,
                l,
                c = 1 / this.direction.x,
                h = 1 / this.direction.y,
                u = 1 / this.direction.z,
                d = this.origin;
            return (
                c >= 0
                    ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
                    : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
                h >= 0
                    ? ((s = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h))
                    : ((s = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
                n > o ||
                s > i ||
                ((s > n || n !== n) && (n = s),
                (o < i || i !== i) && (i = o),
                u >= 0
                    ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
                    : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
                n > l || a > i) ||
                ((a > n || n !== n) && (n = a),
                (l < i || i !== i) && (i = l),
                i < 0)
                    ? null
                    : this.at(n >= 0 ? n : i, t)
            );
        }
        intersectsBox(e) {
            return this.intersectBox(e, en) !== null;
        }
        intersectTriangle(e, t, n, i, s) {
            ia.subVectors(t, e), rr.subVectors(n, e), sa.crossVectors(ia, rr);
            let o = this.direction.dot(sa),
                a;
            if (o > 0) {
                if (i) return null;
                a = 1;
            } else if (o < 0) (a = -1), (o = -o);
            else return null;
            pn.subVectors(this.origin, e);
            let l = a * this.direction.dot(rr.crossVectors(pn, rr));
            if (l < 0) return null;
            let c = a * this.direction.dot(ia.cross(pn));
            if (c < 0 || l + c > o) return null;
            let h = -a * pn.dot(sa);
            return h < 0 ? null : this.at(h / o, s);
        }
        applyMatrix4(e) {
            return (
                this.origin.applyMatrix4(e),
                this.direction.transformDirection(e),
                this
            );
        }
        equals(e) {
            return (
                e.origin.equals(this.origin) &&
                e.direction.equals(this.direction)
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
    },
    me = class r {
        constructor() {
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                arguments.length > 0 &&
                    console.error(
                        "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
                    );
        }
        set(e, t, n, i, s, o, a, l, c, h, u, d, f, m, x, v) {
            let g = this.elements;
            return (
                (g[0] = e),
                (g[4] = t),
                (g[8] = n),
                (g[12] = i),
                (g[1] = s),
                (g[5] = o),
                (g[9] = a),
                (g[13] = l),
                (g[2] = c),
                (g[6] = h),
                (g[10] = u),
                (g[14] = d),
                (g[3] = f),
                (g[7] = m),
                (g[11] = x),
                (g[15] = v),
                this
            );
        }
        identity() {
            return (
                this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
        }
        clone() {
            return new r().fromArray(this.elements);
        }
        copy(e) {
            let t = this.elements,
                n = e.elements;
            return (
                (t[0] = n[0]),
                (t[1] = n[1]),
                (t[2] = n[2]),
                (t[3] = n[3]),
                (t[4] = n[4]),
                (t[5] = n[5]),
                (t[6] = n[6]),
                (t[7] = n[7]),
                (t[8] = n[8]),
                (t[9] = n[9]),
                (t[10] = n[10]),
                (t[11] = n[11]),
                (t[12] = n[12]),
                (t[13] = n[13]),
                (t[14] = n[14]),
                (t[15] = n[15]),
                this
            );
        }
        copyPosition(e) {
            let t = this.elements,
                n = e.elements;
            return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
            let t = e.elements;
            return (
                this.set(
                    t[0],
                    t[3],
                    t[6],
                    0,
                    t[1],
                    t[4],
                    t[7],
                    0,
                    t[2],
                    t[5],
                    t[8],
                    0,
                    0,
                    0,
                    0,
                    1
                ),
                this
            );
        }
        extractBasis(e, t, n) {
            return (
                e.setFromMatrixColumn(this, 0),
                t.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            );
        }
        makeBasis(e, t, n) {
            return (
                this.set(
                    e.x,
                    t.x,
                    n.x,
                    0,
                    e.y,
                    t.y,
                    n.y,
                    0,
                    e.z,
                    t.z,
                    n.z,
                    0,
                    0,
                    0,
                    0,
                    1
                ),
                this
            );
        }
        extractRotation(e) {
            let t = this.elements,
                n = e.elements,
                i = 1 / ai.setFromMatrixColumn(e, 0).length(),
                s = 1 / ai.setFromMatrixColumn(e, 1).length(),
                o = 1 / ai.setFromMatrixColumn(e, 2).length();
            return (
                (t[0] = n[0] * i),
                (t[1] = n[1] * i),
                (t[2] = n[2] * i),
                (t[3] = 0),
                (t[4] = n[4] * s),
                (t[5] = n[5] * s),
                (t[6] = n[6] * s),
                (t[7] = 0),
                (t[8] = n[8] * o),
                (t[9] = n[9] * o),
                (t[10] = n[10] * o),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                this
            );
        }
        makeRotationFromEuler(e) {
            (e && e.isEuler) ||
                console.error(
                    "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
                );
            let t = this.elements,
                n = e.x,
                i = e.y,
                s = e.z,
                o = Math.cos(n),
                a = Math.sin(n),
                l = Math.cos(i),
                c = Math.sin(i),
                h = Math.cos(s),
                u = Math.sin(s);
            if (e.order === "XYZ") {
                let d = o * h,
                    f = o * u,
                    m = a * h,
                    x = a * u;
                (t[0] = l * h),
                    (t[4] = -l * u),
                    (t[8] = c),
                    (t[1] = f + m * c),
                    (t[5] = d - x * c),
                    (t[9] = -a * l),
                    (t[2] = x - d * c),
                    (t[6] = m + f * c),
                    (t[10] = o * l);
            } else if (e.order === "YXZ") {
                let d = l * h,
                    f = l * u,
                    m = c * h,
                    x = c * u;
                (t[0] = d + x * a),
                    (t[4] = m * a - f),
                    (t[8] = o * c),
                    (t[1] = o * u),
                    (t[5] = o * h),
                    (t[9] = -a),
                    (t[2] = f * a - m),
                    (t[6] = x + d * a),
                    (t[10] = o * l);
            } else if (e.order === "ZXY") {
                let d = l * h,
                    f = l * u,
                    m = c * h,
                    x = c * u;
                (t[0] = d - x * a),
                    (t[4] = -o * u),
                    (t[8] = m + f * a),
                    (t[1] = f + m * a),
                    (t[5] = o * h),
                    (t[9] = x - d * a),
                    (t[2] = -o * c),
                    (t[6] = a),
                    (t[10] = o * l);
            } else if (e.order === "ZYX") {
                let d = o * h,
                    f = o * u,
                    m = a * h,
                    x = a * u;
                (t[0] = l * h),
                    (t[4] = m * c - f),
                    (t[8] = d * c + x),
                    (t[1] = l * u),
                    (t[5] = x * c + d),
                    (t[9] = f * c - m),
                    (t[2] = -c),
                    (t[6] = a * l),
                    (t[10] = o * l);
            } else if (e.order === "YZX") {
                let d = o * l,
                    f = o * c,
                    m = a * l,
                    x = a * c;
                (t[0] = l * h),
                    (t[4] = x - d * u),
                    (t[8] = m * u + f),
                    (t[1] = u),
                    (t[5] = o * h),
                    (t[9] = -a * h),
                    (t[2] = -c * h),
                    (t[6] = f * u + m),
                    (t[10] = d - x * u);
            } else if (e.order === "XZY") {
                let d = o * l,
                    f = o * c,
                    m = a * l,
                    x = a * c;
                (t[0] = l * h),
                    (t[4] = -u),
                    (t[8] = c * h),
                    (t[1] = d * u + x),
                    (t[5] = o * h),
                    (t[9] = f * u - m),
                    (t[2] = m * u - f),
                    (t[6] = a * h),
                    (t[10] = x * u + d);
            }
            return (
                (t[3] = 0),
                (t[7] = 0),
                (t[11] = 0),
                (t[12] = 0),
                (t[13] = 0),
                (t[14] = 0),
                (t[15] = 1),
                this
            );
        }
        makeRotationFromQuaternion(e) {
            return this.compose(wf, e, bf);
        }
        lookAt(e, t, n) {
            let i = this.elements;
            return (
                At.subVectors(e, t),
                At.lengthSq() === 0 && (At.z = 1),
                At.normalize(),
                mn.crossVectors(n, At),
                mn.lengthSq() === 0 &&
                    (Math.abs(n.z) === 1 ? (At.x += 1e-4) : (At.z += 1e-4),
                    At.normalize(),
                    mn.crossVectors(n, At)),
                mn.normalize(),
                or.crossVectors(At, mn),
                (i[0] = mn.x),
                (i[4] = or.x),
                (i[8] = At.x),
                (i[1] = mn.y),
                (i[5] = or.y),
                (i[9] = At.y),
                (i[2] = mn.z),
                (i[6] = or.z),
                (i[10] = At.z),
                this
            );
        }
        multiply(e, t) {
            return t !== void 0
                ? (console.warn(
                      "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                  ),
                  this.multiplyMatrices(e, t))
                : this.multiplyMatrices(this, e);
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
            let n = e.elements,
                i = t.elements,
                s = this.elements,
                o = n[0],
                a = n[4],
                l = n[8],
                c = n[12],
                h = n[1],
                u = n[5],
                d = n[9],
                f = n[13],
                m = n[2],
                x = n[6],
                v = n[10],
                g = n[14],
                p = n[3],
                _ = n[7],
                y = n[11],
                w = n[15],
                A = i[0],
                C = i[4],
                I = i[8],
                k = i[12],
                z = i[1],
                P = i[5],
                b = i[9],
                E = i[13],
                D = i[2],
                U = i[6],
                F = i[10],
                O = i[14],
                ne = i[3],
                ce = i[7],
                G = i[11],
                q = i[15];
            return (
                (s[0] = o * A + a * z + l * D + c * ne),
                (s[4] = o * C + a * P + l * U + c * ce),
                (s[8] = o * I + a * b + l * F + c * G),
                (s[12] = o * k + a * E + l * O + c * q),
                (s[1] = h * A + u * z + d * D + f * ne),
                (s[5] = h * C + u * P + d * U + f * ce),
                (s[9] = h * I + u * b + d * F + f * G),
                (s[13] = h * k + u * E + d * O + f * q),
                (s[2] = m * A + x * z + v * D + g * ne),
                (s[6] = m * C + x * P + v * U + g * ce),
                (s[10] = m * I + x * b + v * F + g * G),
                (s[14] = m * k + x * E + v * O + g * q),
                (s[3] = p * A + _ * z + y * D + w * ne),
                (s[7] = p * C + _ * P + y * U + w * ce),
                (s[11] = p * I + _ * b + y * F + w * G),
                (s[15] = p * k + _ * E + y * O + w * q),
                this
            );
        }
        multiplyScalar(e) {
            let t = this.elements;
            return (
                (t[0] *= e),
                (t[4] *= e),
                (t[8] *= e),
                (t[12] *= e),
                (t[1] *= e),
                (t[5] *= e),
                (t[9] *= e),
                (t[13] *= e),
                (t[2] *= e),
                (t[6] *= e),
                (t[10] *= e),
                (t[14] *= e),
                (t[3] *= e),
                (t[7] *= e),
                (t[11] *= e),
                (t[15] *= e),
                this
            );
        }
        determinant() {
            let e = this.elements,
                t = e[0],
                n = e[4],
                i = e[8],
                s = e[12],
                o = e[1],
                a = e[5],
                l = e[9],
                c = e[13],
                h = e[2],
                u = e[6],
                d = e[10],
                f = e[14],
                m = e[3],
                x = e[7],
                v = e[11],
                g = e[15];
            return (
                m *
                    (+s * l * u -
                        i * c * u -
                        s * a * d +
                        n * c * d +
                        i * a * f -
                        n * l * f) +
                x *
                    (+t * l * f -
                        t * c * d +
                        s * o * d -
                        i * o * f +
                        i * c * h -
                        s * l * h) +
                v *
                    (+t * c * u -
                        t * a * f -
                        s * o * u +
                        n * o * f +
                        s * a * h -
                        n * c * h) +
                g *
                    (-i * a * h -
                        t * l * u +
                        t * a * d +
                        i * o * u -
                        n * o * d +
                        n * l * h)
            );
        }
        transpose() {
            let e = this.elements,
                t;
            return (
                (t = e[1]),
                (e[1] = e[4]),
                (e[4] = t),
                (t = e[2]),
                (e[2] = e[8]),
                (e[8] = t),
                (t = e[6]),
                (e[6] = e[9]),
                (e[9] = t),
                (t = e[3]),
                (e[3] = e[12]),
                (e[12] = t),
                (t = e[7]),
                (e[7] = e[13]),
                (e[13] = t),
                (t = e[11]),
                (e[11] = e[14]),
                (e[14] = t),
                this
            );
        }
        setPosition(e, t, n) {
            let i = this.elements;
            return (
                e.isVector3
                    ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
                    : ((i[12] = e), (i[13] = t), (i[14] = n)),
                this
            );
        }
        invert() {
            let e = this.elements,
                t = e[0],
                n = e[1],
                i = e[2],
                s = e[3],
                o = e[4],
                a = e[5],
                l = e[6],
                c = e[7],
                h = e[8],
                u = e[9],
                d = e[10],
                f = e[11],
                m = e[12],
                x = e[13],
                v = e[14],
                g = e[15],
                p =
                    u * v * c -
                    x * d * c +
                    x * l * f -
                    a * v * f -
                    u * l * g +
                    a * d * g,
                _ =
                    m * d * c -
                    h * v * c -
                    m * l * f +
                    o * v * f +
                    h * l * g -
                    o * d * g,
                y =
                    h * x * c -
                    m * u * c +
                    m * a * f -
                    o * x * f -
                    h * a * g +
                    o * u * g,
                w =
                    m * u * l -
                    h * x * l -
                    m * a * d +
                    o * x * d +
                    h * a * v -
                    o * u * v,
                A = t * p + n * _ + i * y + s * w;
            if (A === 0)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            let C = 1 / A;
            return (
                (e[0] = p * C),
                (e[1] =
                    (x * d * s -
                        u * v * s -
                        x * i * f +
                        n * v * f +
                        u * i * g -
                        n * d * g) *
                    C),
                (e[2] =
                    (a * v * s -
                        x * l * s +
                        x * i * c -
                        n * v * c -
                        a * i * g +
                        n * l * g) *
                    C),
                (e[3] =
                    (u * l * s -
                        a * d * s -
                        u * i * c +
                        n * d * c +
                        a * i * f -
                        n * l * f) *
                    C),
                (e[4] = _ * C),
                (e[5] =
                    (h * v * s -
                        m * d * s +
                        m * i * f -
                        t * v * f -
                        h * i * g +
                        t * d * g) *
                    C),
                (e[6] =
                    (m * l * s -
                        o * v * s -
                        m * i * c +
                        t * v * c +
                        o * i * g -
                        t * l * g) *
                    C),
                (e[7] =
                    (o * d * s -
                        h * l * s +
                        h * i * c -
                        t * d * c -
                        o * i * f +
                        t * l * f) *
                    C),
                (e[8] = y * C),
                (e[9] =
                    (m * u * s -
                        h * x * s -
                        m * n * f +
                        t * x * f +
                        h * n * g -
                        t * u * g) *
                    C),
                (e[10] =
                    (o * x * s -
                        m * a * s +
                        m * n * c -
                        t * x * c -
                        o * n * g +
                        t * a * g) *
                    C),
                (e[11] =
                    (h * a * s -
                        o * u * s -
                        h * n * c +
                        t * u * c +
                        o * n * f -
                        t * a * f) *
                    C),
                (e[12] = w * C),
                (e[13] =
                    (h * x * i -
                        m * u * i +
                        m * n * d -
                        t * x * d -
                        h * n * v +
                        t * u * v) *
                    C),
                (e[14] =
                    (m * a * i -
                        o * x * i -
                        m * n * l +
                        t * x * l +
                        o * n * v -
                        t * a * v) *
                    C),
                (e[15] =
                    (o * u * i -
                        h * a * i +
                        h * n * l -
                        t * u * l -
                        o * n * d +
                        t * a * d) *
                    C),
                this
            );
        }
        scale(e) {
            let t = this.elements,
                n = e.x,
                i = e.y,
                s = e.z;
            return (
                (t[0] *= n),
                (t[4] *= i),
                (t[8] *= s),
                (t[1] *= n),
                (t[5] *= i),
                (t[9] *= s),
                (t[2] *= n),
                (t[6] *= i),
                (t[10] *= s),
                (t[3] *= n),
                (t[7] *= i),
                (t[11] *= s),
                this
            );
        }
        getMaxScaleOnAxis() {
            let e = this.elements,
                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
            return (
                this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            );
        }
        makeRotationX(e) {
            let t = Math.cos(e),
                n = Math.sin(e);
            return (
                this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            );
        }
        makeRotationY(e) {
            let t = Math.cos(e),
                n = Math.sin(e);
            return (
                this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            );
        }
        makeRotationZ(e) {
            let t = Math.cos(e),
                n = Math.sin(e);
            return (
                this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
        }
        makeRotationAxis(e, t) {
            let n = Math.cos(t),
                i = Math.sin(t),
                s = 1 - n,
                o = e.x,
                a = e.y,
                l = e.z,
                c = s * o,
                h = s * a;
            return (
                this.set(
                    c * o + n,
                    c * a - i * l,
                    c * l + i * a,
                    0,
                    c * a + i * l,
                    h * a + n,
                    h * l - i * o,
                    0,
                    c * l - i * a,
                    h * l + i * o,
                    s * l * l + n,
                    0,
                    0,
                    0,
                    0,
                    1
                ),
                this
            );
        }
        makeScale(e, t, n) {
            return (
                this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
        }
        makeShear(e, t, n, i, s, o) {
            return (
                this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this
            );
        }
        compose(e, t, n) {
            let i = this.elements,
                s = t._x,
                o = t._y,
                a = t._z,
                l = t._w,
                c = s + s,
                h = o + o,
                u = a + a,
                d = s * c,
                f = s * h,
                m = s * u,
                x = o * h,
                v = o * u,
                g = a * u,
                p = l * c,
                _ = l * h,
                y = l * u,
                w = n.x,
                A = n.y,
                C = n.z;
            return (
                (i[0] = (1 - (x + g)) * w),
                (i[1] = (f + y) * w),
                (i[2] = (m - _) * w),
                (i[3] = 0),
                (i[4] = (f - y) * A),
                (i[5] = (1 - (d + g)) * A),
                (i[6] = (v + p) * A),
                (i[7] = 0),
                (i[8] = (m + _) * C),
                (i[9] = (v - p) * C),
                (i[10] = (1 - (d + x)) * C),
                (i[11] = 0),
                (i[12] = e.x),
                (i[13] = e.y),
                (i[14] = e.z),
                (i[15] = 1),
                this
            );
        }
        decompose(e, t, n) {
            let i = this.elements,
                s = ai.set(i[0], i[1], i[2]).length(),
                o = ai.set(i[4], i[5], i[6]).length(),
                a = ai.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (s = -s),
                (e.x = i[12]),
                (e.y = i[13]),
                (e.z = i[14]),
                Ft.copy(this);
            let c = 1 / s,
                h = 1 / o,
                u = 1 / a;
            return (
                (Ft.elements[0] *= c),
                (Ft.elements[1] *= c),
                (Ft.elements[2] *= c),
                (Ft.elements[4] *= h),
                (Ft.elements[5] *= h),
                (Ft.elements[6] *= h),
                (Ft.elements[8] *= u),
                (Ft.elements[9] *= u),
                (Ft.elements[10] *= u),
                t.setFromRotationMatrix(Ft),
                (n.x = s),
                (n.y = o),
                (n.z = a),
                this
            );
        }
        makePerspective(e, t, n, i, s, o) {
            o === void 0 &&
                console.warn(
                    "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
                );
            let a = this.elements,
                l = (2 * s) / (t - e),
                c = (2 * s) / (n - i),
                h = (t + e) / (t - e),
                u = (n + i) / (n - i),
                d = -(o + s) / (o - s),
                f = (-2 * o * s) / (o - s);
            return (
                (a[0] = l),
                (a[4] = 0),
                (a[8] = h),
                (a[12] = 0),
                (a[1] = 0),
                (a[5] = c),
                (a[9] = u),
                (a[13] = 0),
                (a[2] = 0),
                (a[6] = 0),
                (a[10] = d),
                (a[14] = f),
                (a[3] = 0),
                (a[7] = 0),
                (a[11] = -1),
                (a[15] = 0),
                this
            );
        }
        makeOrthographic(e, t, n, i, s, o) {
            let a = this.elements,
                l = 1 / (t - e),
                c = 1 / (n - i),
                h = 1 / (o - s),
                u = (t + e) * l,
                d = (n + i) * c,
                f = (o + s) * h;
            return (
                (a[0] = 2 * l),
                (a[4] = 0),
                (a[8] = 0),
                (a[12] = -u),
                (a[1] = 0),
                (a[5] = 2 * c),
                (a[9] = 0),
                (a[13] = -d),
                (a[2] = 0),
                (a[6] = 0),
                (a[10] = -2 * h),
                (a[14] = -f),
                (a[3] = 0),
                (a[7] = 0),
                (a[11] = 0),
                (a[15] = 1),
                this
            );
        }
        equals(e) {
            let t = this.elements,
                n = e.elements;
            for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
            return !0;
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
            return this;
        }
        toArray(e = [], t = 0) {
            let n = this.elements;
            return (
                (e[t] = n[0]),
                (e[t + 1] = n[1]),
                (e[t + 2] = n[2]),
                (e[t + 3] = n[3]),
                (e[t + 4] = n[4]),
                (e[t + 5] = n[5]),
                (e[t + 6] = n[6]),
                (e[t + 7] = n[7]),
                (e[t + 8] = n[8]),
                (e[t + 9] = n[9]),
                (e[t + 10] = n[10]),
                (e[t + 11] = n[11]),
                (e[t + 12] = n[12]),
                (e[t + 13] = n[13]),
                (e[t + 14] = n[14]),
                (e[t + 15] = n[15]),
                e
            );
        }
    };
me.prototype.isMatrix4 = !0;
var ai = new M(),
    Ft = new me(),
    wf = new M(0, 0, 0),
    bf = new M(1, 1, 1),
    mn = new M(),
    or = new M(),
    At = new M(),
    uc = new me(),
    dc = new dt(),
    Ii = class r {
        constructor(e = 0, t = 0, n = 0, i = r.DefaultOrder) {
            (this._x = e), (this._y = t), (this._z = n), (this._order = i);
        }
        get x() {
            return this._x;
        }
        set x(e) {
            (this._x = e), this._onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set y(e) {
            (this._y = e), this._onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set z(e) {
            (this._z = e), this._onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set order(e) {
            (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
            return (
                (this._x = e),
                (this._y = t),
                (this._z = n),
                (this._order = i),
                this._onChangeCallback(),
                this
            );
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
            return (
                (this._x = e._x),
                (this._y = e._y),
                (this._z = e._z),
                (this._order = e._order),
                this._onChangeCallback(),
                this
            );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
            let i = e.elements,
                s = i[0],
                o = i[4],
                a = i[8],
                l = i[1],
                c = i[5],
                h = i[9],
                u = i[2],
                d = i[6],
                f = i[10];
            switch (t) {
                case "XYZ":
                    (this._y = Math.asin(mt(a, -1, 1))),
                        Math.abs(a) < 0.9999999
                            ? ((this._x = Math.atan2(-h, f)),
                              (this._z = Math.atan2(-o, s)))
                            : ((this._x = Math.atan2(d, c)), (this._z = 0));
                    break;
                case "YXZ":
                    (this._x = Math.asin(-mt(h, -1, 1))),
                        Math.abs(h) < 0.9999999
                            ? ((this._y = Math.atan2(a, f)),
                              (this._z = Math.atan2(l, c)))
                            : ((this._y = Math.atan2(-u, s)), (this._z = 0));
                    break;
                case "ZXY":
                    (this._x = Math.asin(mt(d, -1, 1))),
                        Math.abs(d) < 0.9999999
                            ? ((this._y = Math.atan2(-u, f)),
                              (this._z = Math.atan2(-o, c)))
                            : ((this._y = 0), (this._z = Math.atan2(l, s)));
                    break;
                case "ZYX":
                    (this._y = Math.asin(-mt(u, -1, 1))),
                        Math.abs(u) < 0.9999999
                            ? ((this._x = Math.atan2(d, f)),
                              (this._z = Math.atan2(l, s)))
                            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
                    break;
                case "YZX":
                    (this._z = Math.asin(mt(l, -1, 1))),
                        Math.abs(l) < 0.9999999
                            ? ((this._x = Math.atan2(-h, c)),
                              (this._y = Math.atan2(-u, s)))
                            : ((this._x = 0), (this._y = Math.atan2(a, f)));
                    break;
                case "XZY":
                    (this._z = Math.asin(-mt(o, -1, 1))),
                        Math.abs(o) < 0.9999999
                            ? ((this._x = Math.atan2(d, c)),
                              (this._y = Math.atan2(a, s)))
                            : ((this._x = Math.atan2(-h, f)), (this._y = 0));
                    break;
                default:
                    console.warn(
                        "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                            t
                    );
            }
            return (
                (this._order = t), n === !0 && this._onChangeCallback(), this
            );
        }
        setFromQuaternion(e, t, n) {
            return (
                uc.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(uc, t, n)
            );
        }
        setFromVector3(e, t = this._order) {
            return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
            return dc.setFromEuler(this), this.setFromQuaternion(dc, e);
        }
        equals(e) {
            return (
                e._x === this._x &&
                e._y === this._y &&
                e._z === this._z &&
                e._order === this._order
            );
        }
        fromArray(e) {
            return (
                (this._x = e[0]),
                (this._y = e[1]),
                (this._z = e[2]),
                e[3] !== void 0 && (this._order = e[3]),
                this._onChangeCallback(),
                this
            );
        }
        toArray(e = [], t = 0) {
            return (
                (e[t] = this._x),
                (e[t + 1] = this._y),
                (e[t + 2] = this._z),
                (e[t + 3] = this._order),
                e
            );
        }
        toVector3(e) {
            return e
                ? e.set(this._x, this._y, this._z)
                : new M(this._x, this._y, this._z);
        }
        _onChange(e) {
            return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
    };
Ii.prototype.isEuler = !0;
Ii.DefaultOrder = "XYZ";
Ii.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var bs = class {
        constructor() {
            this.mask = 1;
        }
        set(e) {
            this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
            this.mask |= (1 << e) | 0;
        }
        enableAll() {
            this.mask = -1;
        }
        toggle(e) {
            this.mask ^= (1 << e) | 0;
        }
        disable(e) {
            this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
            this.mask = 0;
        }
        test(e) {
            return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
            return (this.mask & ((1 << e) | 0)) !== 0;
        }
    },
    Sf = 0,
    fc = new M(),
    li = new dt(),
    tn = new me(),
    ar = new M(),
    is = new M(),
    Tf = new M(),
    Ef = new dt(),
    pc = new M(1, 0, 0),
    mc = new M(0, 1, 0),
    gc = new M(0, 0, 1),
    Af = { type: "added" },
    xc = { type: "removed" },
    Be = class r extends cn {
        constructor() {
            super(),
                Object.defineProperty(this, "id", { value: Sf++ }),
                (this.uuid = Ct()),
                (this.name = ""),
                (this.type = "Object3D"),
                (this.parent = null),
                (this.children = []),
                (this.up = r.DefaultUp.clone());
            let e = new M(),
                t = new Ii(),
                n = new dt(),
                i = new M(1, 1, 1);
            function s() {
                n.setFromEuler(t, !1);
            }
            function o() {
                t.setFromQuaternion(n, void 0, !1);
            }
            t._onChange(s),
                n._onChange(o),
                Object.defineProperties(this, {
                    position: { configurable: !0, enumerable: !0, value: e },
                    rotation: { configurable: !0, enumerable: !0, value: t },
                    quaternion: { configurable: !0, enumerable: !0, value: n },
                    scale: { configurable: !0, enumerable: !0, value: i },
                    modelViewMatrix: { value: new me() },
                    normalMatrix: { value: new rt() },
                }),
                (this.matrix = new me()),
                (this.matrixWorld = new me()),
                (this.matrixAutoUpdate = r.DefaultMatrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = !1),
                (this.layers = new bs()),
                (this.visible = !0),
                (this.castShadow = !1),
                (this.receiveShadow = !1),
                (this.frustumCulled = !0),
                (this.renderOrder = 0),
                (this.animations = []),
                (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(e),
                this.matrix.decompose(
                    this.position,
                    this.quaternion,
                    this.scale
                );
        }
        applyQuaternion(e) {
            return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
            this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
            this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
            this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
            this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
            return (
                li.setFromAxisAngle(e, t), this.quaternion.multiply(li), this
            );
        }
        rotateOnWorldAxis(e, t) {
            return (
                li.setFromAxisAngle(e, t), this.quaternion.premultiply(li), this
            );
        }
        rotateX(e) {
            return this.rotateOnAxis(pc, e);
        }
        rotateY(e) {
            return this.rotateOnAxis(mc, e);
        }
        rotateZ(e) {
            return this.rotateOnAxis(gc, e);
        }
        translateOnAxis(e, t) {
            return (
                fc.copy(e).applyQuaternion(this.quaternion),
                this.position.add(fc.multiplyScalar(t)),
                this
            );
        }
        translateX(e) {
            return this.translateOnAxis(pc, e);
        }
        translateY(e) {
            return this.translateOnAxis(mc, e);
        }
        translateZ(e) {
            return this.translateOnAxis(gc, e);
        }
        localToWorld(e) {
            return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
            return e.applyMatrix4(tn.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, n) {
            e.isVector3 ? ar.copy(e) : ar.set(e, t, n);
            let i = this.parent;
            this.updateWorldMatrix(!0, !1),
                is.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight
                    ? tn.lookAt(is, ar, this.up)
                    : tn.lookAt(ar, is, this.up),
                this.quaternion.setFromRotationMatrix(tn),
                i &&
                    (tn.extractRotation(i.matrixWorld),
                    li.setFromRotationMatrix(tn),
                    this.quaternion.premultiply(li.invert()));
        }
        add(e) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this;
            }
            return e === this
                ? (console.error(
                      "THREE.Object3D.add: object can't be added as a child of itself.",
                      e
                  ),
                  this)
                : (e && e.isObject3D
                      ? (e.parent !== null && e.parent.remove(e),
                        (e.parent = this),
                        this.children.push(e),
                        e.dispatchEvent(Af))
                      : console.error(
                            "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                            e
                        ),
                  this);
        }
        remove(e) {
            if (arguments.length > 1) {
                for (let n = 0; n < arguments.length; n++)
                    this.remove(arguments[n]);
                return this;
            }
            let t = this.children.indexOf(e);
            return (
                t !== -1 &&
                    ((e.parent = null),
                    this.children.splice(t, 1),
                    e.dispatchEvent(xc)),
                this
            );
        }
        removeFromParent() {
            let e = this.parent;
            return e !== null && e.remove(this), this;
        }
        clear() {
            for (let e = 0; e < this.children.length; e++) {
                let t = this.children[e];
                (t.parent = null), t.dispatchEvent(xc);
            }
            return (this.children.length = 0), this;
        }
        attach(e) {
            return (
                this.updateWorldMatrix(!0, !1),
                tn.copy(this.matrixWorld).invert(),
                e.parent !== null &&
                    (e.parent.updateWorldMatrix(!0, !1),
                    tn.multiply(e.parent.matrixWorld)),
                e.applyMatrix4(tn),
                this.add(e),
                e.updateWorldMatrix(!1, !0),
                this
            );
        }
        getObjectById(e) {
            return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
            return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
            if (this[e] === t) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                let o = this.children[n].getObjectByProperty(e, t);
                if (o !== void 0) return o;
            }
        }
        getWorldPosition(e) {
            return (
                this.updateWorldMatrix(!0, !1),
                e.setFromMatrixPosition(this.matrixWorld)
            );
        }
        getWorldQuaternion(e) {
            return (
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(is, e, Tf),
                e
            );
        }
        getWorldScale(e) {
            return (
                this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(is, Ef, e),
                e
            );
        }
        getWorldDirection(e) {
            this.updateWorldMatrix(!0, !1);
            let t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
            e(this);
            let t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
            if (this.visible === !1) return;
            e(this);
            let t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
            let t = this.parent;
            t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
                (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || e) &&
                    (this.parent === null
                        ? this.matrixWorld.copy(this.matrix)
                        : this.matrixWorld.multiplyMatrices(
                              this.parent.matrixWorld,
                              this.matrix
                          ),
                    (this.matrixWorldNeedsUpdate = !1),
                    (e = !0));
            let t = this.children;
            for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
            let n = this.parent;
            if (
                (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                this.parent === null
                    ? this.matrixWorld.copy(this.matrix)
                    : this.matrixWorld.multiplyMatrices(
                          this.parent.matrixWorld,
                          this.matrix
                      ),
                t === !0)
            ) {
                let i = this.children;
                for (let s = 0, o = i.length; s < o; s++)
                    i[s].updateWorldMatrix(!1, !0);
            }
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string",
                n = {};
            t &&
                ((e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                }),
                (n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON",
                }));
            let i = {};
            (i.uuid = this.uuid),
                (i.type = this.type),
                this.name !== "" && (i.name = this.name),
                this.castShadow === !0 && (i.castShadow = !0),
                this.receiveShadow === !0 && (i.receiveShadow = !0),
                this.visible === !1 && (i.visible = !1),
                this.frustumCulled === !1 && (i.frustumCulled = !1),
                this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
                JSON.stringify(this.userData) !== "{}" &&
                    (i.userData = this.userData),
                (i.layers = this.layers.mask),
                (i.matrix = this.matrix.toArray()),
                this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh &&
                    ((i.type = "InstancedMesh"),
                    (i.count = this.count),
                    (i.instanceMatrix = this.instanceMatrix.toJSON()),
                    this.instanceColor !== null &&
                        (i.instanceColor = this.instanceColor.toJSON()));
            function s(a, l) {
                return (
                    a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
                );
            }
            if (this.isScene)
                this.background &&
                    (this.background.isColor
                        ? (i.background = this.background.toJSON())
                        : this.background.isTexture &&
                          (i.background = this.background.toJSON(e).uuid)),
                    this.environment &&
                        this.environment.isTexture &&
                        (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = s(e.geometries, this.geometry);
                let a = this.geometry.parameters;
                if (a !== void 0 && a.shapes !== void 0) {
                    let l = a.shapes;
                    if (Array.isArray(l))
                        for (let c = 0, h = l.length; c < h; c++) {
                            let u = l[c];
                            s(e.shapes, u);
                        }
                    else s(e.shapes, l);
                }
            }
            if (
                (this.isSkinnedMesh &&
                    ((i.bindMode = this.bindMode),
                    (i.bindMatrix = this.bindMatrix.toArray()),
                    this.skeleton !== void 0 &&
                        (s(e.skeletons, this.skeleton),
                        (i.skeleton = this.skeleton.uuid))),
                this.material !== void 0)
            )
                if (Array.isArray(this.material)) {
                    let a = [];
                    for (let l = 0, c = this.material.length; l < c; l++)
                        a.push(s(e.materials, this.material[l]));
                    i.material = a;
                } else i.material = s(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let a = 0; a < this.children.length; a++)
                    i.children.push(this.children[a].toJSON(e).object);
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let a = 0; a < this.animations.length; a++) {
                    let l = this.animations[a];
                    i.animations.push(s(e.animations, l));
                }
            }
            if (t) {
                let a = o(e.geometries),
                    l = o(e.materials),
                    c = o(e.textures),
                    h = o(e.images),
                    u = o(e.shapes),
                    d = o(e.skeletons),
                    f = o(e.animations);
                a.length > 0 && (n.geometries = a),
                    l.length > 0 && (n.materials = l),
                    c.length > 0 && (n.textures = c),
                    h.length > 0 && (n.images = h),
                    u.length > 0 && (n.shapes = u),
                    d.length > 0 && (n.skeletons = d),
                    f.length > 0 && (n.animations = f);
            }
            return (n.object = i), n;
            function o(a) {
                let l = [];
                for (let c in a) {
                    let h = a[c];
                    delete h.metadata, l.push(h);
                }
                return l;
            }
        }
        clone(e) {
            return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
            if (
                ((this.name = e.name),
                this.up.copy(e.up),
                this.position.copy(e.position),
                (this.rotation.order = e.rotation.order),
                this.quaternion.copy(e.quaternion),
                this.scale.copy(e.scale),
                this.matrix.copy(e.matrix),
                this.matrixWorld.copy(e.matrixWorld),
                (this.matrixAutoUpdate = e.matrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
                (this.layers.mask = e.layers.mask),
                (this.visible = e.visible),
                (this.castShadow = e.castShadow),
                (this.receiveShadow = e.receiveShadow),
                (this.frustumCulled = e.frustumCulled),
                (this.renderOrder = e.renderOrder),
                (this.userData = JSON.parse(JSON.stringify(e.userData))),
                t === !0)
            )
                for (let n = 0; n < e.children.length; n++) {
                    let i = e.children[n];
                    this.add(i.clone());
                }
            return this;
        }
    };
Be.DefaultUp = new M(0, 1, 0);
Be.DefaultMatrixAutoUpdate = !0;
Be.prototype.isObject3D = !0;
var Nt = new M(),
    nn = new M(),
    ra = new M(),
    sn = new M(),
    ci = new M(),
    hi = new M(),
    yc = new M(),
    oa = new M(),
    aa = new M(),
    la = new M(),
    vt = class r {
        constructor(e = new M(), t = new M(), n = new M()) {
            (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
            i.subVectors(n, t), Nt.subVectors(e, t), i.cross(Nt);
            let s = i.lengthSq();
            return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, s) {
            Nt.subVectors(i, t), nn.subVectors(n, t), ra.subVectors(e, t);
            let o = Nt.dot(Nt),
                a = Nt.dot(nn),
                l = Nt.dot(ra),
                c = nn.dot(nn),
                h = nn.dot(ra),
                u = o * c - a * a;
            if (u === 0) return s.set(-2, -1, -1);
            let d = 1 / u,
                f = (c * l - a * h) * d,
                m = (o * h - a * l) * d;
            return s.set(1 - f - m, m, f);
        }
        static containsPoint(e, t, n, i) {
            return (
                this.getBarycoord(e, t, n, i, sn),
                sn.x >= 0 && sn.y >= 0 && sn.x + sn.y <= 1
            );
        }
        static getUV(e, t, n, i, s, o, a, l) {
            return (
                this.getBarycoord(e, t, n, i, sn),
                l.set(0, 0),
                l.addScaledVector(s, sn.x),
                l.addScaledVector(o, sn.y),
                l.addScaledVector(a, sn.z),
                l
            );
        }
        static isFrontFacing(e, t, n, i) {
            return (
                Nt.subVectors(n, t),
                nn.subVectors(e, t),
                Nt.cross(nn).dot(i) < 0
            );
        }
        set(e, t, n) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
            return (
                this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
            );
        }
        setFromAttributeAndIndices(e, t, n, i) {
            return (
                this.a.fromBufferAttribute(e, t),
                this.b.fromBufferAttribute(e, n),
                this.c.fromBufferAttribute(e, i),
                this
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
            return (
                Nt.subVectors(this.c, this.b),
                nn.subVectors(this.a, this.b),
                Nt.cross(nn).length() * 0.5
            );
        }
        getMidpoint(e) {
            return e
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3);
        }
        getNormal(e) {
            return r.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
            return r.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, n, i, s) {
            return r.getUV(e, this.a, this.b, this.c, t, n, i, s);
        }
        containsPoint(e) {
            return r.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
            return r.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
            let n = this.a,
                i = this.b,
                s = this.c,
                o,
                a;
            ci.subVectors(i, n), hi.subVectors(s, n), oa.subVectors(e, n);
            let l = ci.dot(oa),
                c = hi.dot(oa);
            if (l <= 0 && c <= 0) return t.copy(n);
            aa.subVectors(e, i);
            let h = ci.dot(aa),
                u = hi.dot(aa);
            if (h >= 0 && u <= h) return t.copy(i);
            let d = l * u - h * c;
            if (d <= 0 && l >= 0 && h <= 0)
                return (o = l / (l - h)), t.copy(n).addScaledVector(ci, o);
            la.subVectors(e, s);
            let f = ci.dot(la),
                m = hi.dot(la);
            if (m >= 0 && f <= m) return t.copy(s);
            let x = f * c - l * m;
            if (x <= 0 && c >= 0 && m <= 0)
                return (a = c / (c - m)), t.copy(n).addScaledVector(hi, a);
            let v = h * m - f * u;
            if (v <= 0 && u - h >= 0 && f - m >= 0)
                return (
                    yc.subVectors(s, i),
                    (a = (u - h) / (u - h + (f - m))),
                    t.copy(i).addScaledVector(yc, a)
                );
            let g = 1 / (v + x + d);
            return (
                (o = x * g),
                (a = d * g),
                t.copy(n).addScaledVector(ci, o).addScaledVector(hi, a)
            );
        }
        equals(e) {
            return (
                e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            );
        }
    },
    Rf = 0,
    ct = class extends cn {
        constructor() {
            super(),
                Object.defineProperty(this, "id", { value: Rf++ }),
                (this.uuid = Ct()),
                (this.name = ""),
                (this.type = "Material"),
                (this.fog = !0),
                (this.blending = fs),
                (this.side = Ci),
                (this.vertexColors = !1),
                (this.opacity = 1),
                (this.format = lt),
                (this.transparent = !1),
                (this.blendSrc = Kh),
                (this.blendDst = eu),
                (this.blendEquation = wi),
                (this.blendSrcAlpha = null),
                (this.blendDstAlpha = null),
                (this.blendEquationAlpha = null),
                (this.depthFunc = Pa),
                (this.depthTest = !0),
                (this.depthWrite = !0),
                (this.stencilWriteMask = 255),
                (this.stencilFunc = rf),
                (this.stencilRef = 0),
                (this.stencilFuncMask = 255),
                (this.stencilFail = $o),
                (this.stencilZFail = $o),
                (this.stencilZPass = $o),
                (this.stencilWrite = !1),
                (this.clippingPlanes = null),
                (this.clipIntersection = !1),
                (this.clipShadows = !1),
                (this.shadowSide = null),
                (this.colorWrite = !0),
                (this.precision = null),
                (this.polygonOffset = !1),
                (this.polygonOffsetFactor = 0),
                (this.polygonOffsetUnits = 0),
                (this.dithering = !1),
                (this.alphaToCoverage = !1),
                (this.premultipliedAlpha = !1),
                (this.visible = !0),
                (this.toneMapped = !0),
                (this.userData = {}),
                (this.version = 0),
                (this._alphaTest = 0);
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(e) {
            this._alphaTest > 0 != e > 0 && this.version++,
                (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        }
        setValues(e) {
            if (e !== void 0)
                for (let t in e) {
                    let n = e[t];
                    if (n === void 0) {
                        console.warn(
                            "THREE.Material: '" +
                                t +
                                "' parameter is undefined."
                        );
                        continue;
                    }
                    if (t === "shading") {
                        console.warn(
                            "THREE." +
                                this.type +
                                ": .shading has been removed. Use the boolean .flatShading instead."
                        ),
                            (this.flatShading = n === Qh);
                        continue;
                    }
                    let i = this[t];
                    if (i === void 0) {
                        console.warn(
                            "THREE." +
                                this.type +
                                ": '" +
                                t +
                                "' is not a property of this material."
                        );
                        continue;
                    }
                    i && i.isColor
                        ? i.set(n)
                        : i && i.isVector3 && n && n.isVector3
                        ? i.copy(n)
                        : (this[t] = n);
                }
        }
        toJSON(e) {
            let t = e === void 0 || typeof e == "string";
            t && (e = { textures: {}, images: {} });
            let n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON",
                },
            };
            (n.uuid = this.uuid),
                (n.type = this.type),
                this.name !== "" && (n.name = this.name),
                this.color &&
                    this.color.isColor &&
                    (n.color = this.color.getHex()),
                this.roughness !== void 0 && (n.roughness = this.roughness),
                this.metalness !== void 0 && (n.metalness = this.metalness),
                this.sheen !== void 0 && (n.sheen = this.sheen),
                this.sheenColor &&
                    this.sheenColor.isColor &&
                    (n.sheenColor = this.sheenColor.getHex()),
                this.sheenRoughness !== void 0 &&
                    (n.sheenRoughness = this.sheenRoughness),
                this.emissive &&
                    this.emissive.isColor &&
                    (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity &&
                    this.emissiveIntensity !== 1 &&
                    (n.emissiveIntensity = this.emissiveIntensity),
                this.specular &&
                    this.specular.isColor &&
                    (n.specular = this.specular.getHex()),
                this.specularIntensity !== void 0 &&
                    (n.specularIntensity = this.specularIntensity),
                this.specularColor &&
                    this.specularColor.isColor &&
                    (n.specularColor = this.specularColor.getHex()),
                this.shininess !== void 0 && (n.shininess = this.shininess),
                this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
                this.clearcoatRoughness !== void 0 &&
                    (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap &&
                    this.clearcoatMap.isTexture &&
                    (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                this.clearcoatRoughnessMap &&
                    this.clearcoatRoughnessMap.isTexture &&
                    (n.clearcoatRoughnessMap =
                        this.clearcoatRoughnessMap.toJSON(e).uuid),
                this.clearcoatNormalMap &&
                    this.clearcoatNormalMap.isTexture &&
                    ((n.clearcoatNormalMap =
                        this.clearcoatNormalMap.toJSON(e).uuid),
                    (n.clearcoatNormalScale =
                        this.clearcoatNormalScale.toArray())),
                this.map &&
                    this.map.isTexture &&
                    (n.map = this.map.toJSON(e).uuid),
                this.matcap &&
                    this.matcap.isTexture &&
                    (n.matcap = this.matcap.toJSON(e).uuid),
                this.alphaMap &&
                    this.alphaMap.isTexture &&
                    (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                this.lightMap &&
                    this.lightMap.isTexture &&
                    ((n.lightMap = this.lightMap.toJSON(e).uuid),
                    (n.lightMapIntensity = this.lightMapIntensity)),
                this.aoMap &&
                    this.aoMap.isTexture &&
                    ((n.aoMap = this.aoMap.toJSON(e).uuid),
                    (n.aoMapIntensity = this.aoMapIntensity)),
                this.bumpMap &&
                    this.bumpMap.isTexture &&
                    ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
                    (n.bumpScale = this.bumpScale)),
                this.normalMap &&
                    this.normalMap.isTexture &&
                    ((n.normalMap = this.normalMap.toJSON(e).uuid),
                    (n.normalMapType = this.normalMapType),
                    (n.normalScale = this.normalScale.toArray())),
                this.displacementMap &&
                    this.displacementMap.isTexture &&
                    ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
                    (n.displacementScale = this.displacementScale),
                    (n.displacementBias = this.displacementBias)),
                this.roughnessMap &&
                    this.roughnessMap.isTexture &&
                    (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                this.metalnessMap &&
                    this.metalnessMap.isTexture &&
                    (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                this.emissiveMap &&
                    this.emissiveMap.isTexture &&
                    (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                this.specularMap &&
                    this.specularMap.isTexture &&
                    (n.specularMap = this.specularMap.toJSON(e).uuid),
                this.specularIntensityMap &&
                    this.specularIntensityMap.isTexture &&
                    (n.specularIntensityMap =
                        this.specularIntensityMap.toJSON(e).uuid),
                this.specularColorMap &&
                    this.specularColorMap.isTexture &&
                    (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                this.envMap &&
                    this.envMap.isTexture &&
                    ((n.envMap = this.envMap.toJSON(e).uuid),
                    this.combine !== void 0 && (n.combine = this.combine)),
                this.envMapIntensity !== void 0 &&
                    (n.envMapIntensity = this.envMapIntensity),
                this.reflectivity !== void 0 &&
                    (n.reflectivity = this.reflectivity),
                this.refractionRatio !== void 0 &&
                    (n.refractionRatio = this.refractionRatio),
                this.gradientMap &&
                    this.gradientMap.isTexture &&
                    (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                this.transmission !== void 0 &&
                    (n.transmission = this.transmission),
                this.transmissionMap &&
                    this.transmissionMap.isTexture &&
                    (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                this.thickness !== void 0 && (n.thickness = this.thickness),
                this.thicknessMap &&
                    this.thicknessMap.isTexture &&
                    (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                this.attenuationDistance !== void 0 &&
                    (n.attenuationDistance = this.attenuationDistance),
                this.attenuationColor !== void 0 &&
                    (n.attenuationColor = this.attenuationColor.getHex()),
                this.size !== void 0 && (n.size = this.size),
                this.shadowSide !== null && (n.shadowSide = this.shadowSide),
                this.sizeAttenuation !== void 0 &&
                    (n.sizeAttenuation = this.sizeAttenuation),
                this.blending !== fs && (n.blending = this.blending),
                this.side !== Ci && (n.side = this.side),
                this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                this.format !== lt && (n.format = this.format),
                this.transparent === !0 && (n.transparent = this.transparent),
                (n.depthFunc = this.depthFunc),
                (n.depthTest = this.depthTest),
                (n.depthWrite = this.depthWrite),
                (n.colorWrite = this.colorWrite),
                (n.stencilWrite = this.stencilWrite),
                (n.stencilWriteMask = this.stencilWriteMask),
                (n.stencilFunc = this.stencilFunc),
                (n.stencilRef = this.stencilRef),
                (n.stencilFuncMask = this.stencilFuncMask),
                (n.stencilFail = this.stencilFail),
                (n.stencilZFail = this.stencilZFail),
                (n.stencilZPass = this.stencilZPass),
                this.rotation &&
                    this.rotation !== 0 &&
                    (n.rotation = this.rotation),
                this.polygonOffset === !0 && (n.polygonOffset = !0),
                this.polygonOffsetFactor !== 0 &&
                    (n.polygonOffsetFactor = this.polygonOffsetFactor),
                this.polygonOffsetUnits !== 0 &&
                    (n.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth &&
                    this.linewidth !== 1 &&
                    (n.linewidth = this.linewidth),
                this.dashSize !== void 0 && (n.dashSize = this.dashSize),
                this.gapSize !== void 0 && (n.gapSize = this.gapSize),
                this.scale !== void 0 && (n.scale = this.scale),
                this.dithering === !0 && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                this.alphaToCoverage === !0 &&
                    (n.alphaToCoverage = this.alphaToCoverage),
                this.premultipliedAlpha === !0 &&
                    (n.premultipliedAlpha = this.premultipliedAlpha),
                this.wireframe === !0 && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 &&
                    (n.wireframeLinewidth = this.wireframeLinewidth),
                this.wireframeLinecap !== "round" &&
                    (n.wireframeLinecap = this.wireframeLinecap),
                this.wireframeLinejoin !== "round" &&
                    (n.wireframeLinejoin = this.wireframeLinejoin),
                this.flatShading === !0 && (n.flatShading = this.flatShading),
                this.visible === !1 && (n.visible = !1),
                this.toneMapped === !1 && (n.toneMapped = !1),
                JSON.stringify(this.userData) !== "{}" &&
                    (n.userData = this.userData);
            function i(s) {
                let o = [];
                for (let a in s) {
                    let l = s[a];
                    delete l.metadata, o.push(l);
                }
                return o;
            }
            if (t) {
                let s = i(e.textures),
                    o = i(e.images);
                s.length > 0 && (n.textures = s),
                    o.length > 0 && (n.images = o);
            }
            return n;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            (this.name = e.name),
                (this.fog = e.fog),
                (this.blending = e.blending),
                (this.side = e.side),
                (this.vertexColors = e.vertexColors),
                (this.opacity = e.opacity),
                (this.format = e.format),
                (this.transparent = e.transparent),
                (this.blendSrc = e.blendSrc),
                (this.blendDst = e.blendDst),
                (this.blendEquation = e.blendEquation),
                (this.blendSrcAlpha = e.blendSrcAlpha),
                (this.blendDstAlpha = e.blendDstAlpha),
                (this.blendEquationAlpha = e.blendEquationAlpha),
                (this.depthFunc = e.depthFunc),
                (this.depthTest = e.depthTest),
                (this.depthWrite = e.depthWrite),
                (this.stencilWriteMask = e.stencilWriteMask),
                (this.stencilFunc = e.stencilFunc),
                (this.stencilRef = e.stencilRef),
                (this.stencilFuncMask = e.stencilFuncMask),
                (this.stencilFail = e.stencilFail),
                (this.stencilZFail = e.stencilZFail),
                (this.stencilZPass = e.stencilZPass),
                (this.stencilWrite = e.stencilWrite);
            let t = e.clippingPlanes,
                n = null;
            if (t !== null) {
                let i = t.length;
                n = new Array(i);
                for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
            }
            return (
                (this.clippingPlanes = n),
                (this.clipIntersection = e.clipIntersection),
                (this.clipShadows = e.clipShadows),
                (this.shadowSide = e.shadowSide),
                (this.colorWrite = e.colorWrite),
                (this.precision = e.precision),
                (this.polygonOffset = e.polygonOffset),
                (this.polygonOffsetFactor = e.polygonOffsetFactor),
                (this.polygonOffsetUnits = e.polygonOffsetUnits),
                (this.dithering = e.dithering),
                (this.alphaTest = e.alphaTest),
                (this.alphaToCoverage = e.alphaToCoverage),
                (this.premultipliedAlpha = e.premultipliedAlpha),
                (this.visible = e.visible),
                (this.toneMapped = e.toneMapped),
                (this.userData = JSON.parse(JSON.stringify(e.userData))),
                this
            );
        }
        dispose() {
            this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
    };
ct.prototype.isMaterial = !0;
var ou = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
    },
    zt = { h: 0, s: 0, l: 0 },
    lr = { h: 0, s: 0, l: 0 };
function ca(r, e, t) {
    return (
        t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6
            ? r + (e - r) * 6 * t
            : t < 1 / 2
            ? e
            : t < 2 / 3
            ? r + (e - r) * 6 * (2 / 3 - t)
            : r
    );
}
function ha(r) {
    return r < 0.04045
        ? r * 0.0773993808
        : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function ua(r) {
    return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
var re = class {
    constructor(e, t, n) {
        return t === void 0 && n === void 0
            ? this.set(e)
            : this.setRGB(e, t, n);
    }
    set(e) {
        return (
            e && e.isColor
                ? this.copy(e)
                : typeof e == "number"
                ? this.setHex(e)
                : typeof e == "string" && this.setStyle(e),
            this
        );
    }
    setScalar(e) {
        return (this.r = e), (this.g = e), (this.b = e), this;
    }
    setHex(e) {
        return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (e & 255) / 255),
            this
        );
    }
    setRGB(e, t, n) {
        return (this.r = e), (this.g = t), (this.b = n), this;
    }
    setHSL(e, t, n) {
        if (((e = zl(e, 1)), (t = mt(t, 0, 1)), (n = mt(n, 0, 1)), t === 0))
            this.r = this.g = this.b = n;
        else {
            let i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
                s = 2 * n - i;
            (this.r = ca(s, i, e + 1 / 3)),
                (this.g = ca(s, i, e)),
                (this.b = ca(s, i, e - 1 / 3));
        }
        return this;
    }
    setStyle(e) {
        function t(i) {
            i !== void 0 &&
                parseFloat(i) < 1 &&
                console.warn(
                    "THREE.Color: Alpha component of " + e + " will be ignored."
                );
        }
        let n;
        if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
            let i,
                s = n[1],
                o = n[2];
            switch (s) {
                case "rgb":
                case "rgba":
                    if (
                        (i =
                            /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                o
                            ))
                    )
                        return (
                            (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                            (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                            (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                            t(i[4]),
                            this
                        );
                    if (
                        (i =
                            /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                o
                            ))
                    )
                        return (
                            (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                            (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                            (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                            t(i[4]),
                            this
                        );
                    break;
                case "hsl":
                case "hsla":
                    if (
                        (i =
                            /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                                o
                            ))
                    ) {
                        let a = parseFloat(i[1]) / 360,
                            l = parseInt(i[2], 10) / 100,
                            c = parseInt(i[3], 10) / 100;
                        return t(i[4]), this.setHSL(a, l, c);
                    }
                    break;
            }
        } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            let i = n[1],
                s = i.length;
            if (s === 3)
                return (
                    (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
                    (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
                    (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
                    this
                );
            if (s === 6)
                return (
                    (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
                    (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
                    (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
                    this
                );
        }
        return e && e.length > 0 ? this.setColorName(e) : this;
    }
    setColorName(e) {
        let t = ou[e.toLowerCase()];
        return (
            t !== void 0
                ? this.setHex(t)
                : console.warn("THREE.Color: Unknown color " + e),
            this
        );
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
        return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    }
    copySRGBToLinear(e) {
        return (this.r = ha(e.r)), (this.g = ha(e.g)), (this.b = ha(e.b)), this;
    }
    copyLinearToSRGB(e) {
        return (this.r = ua(e.r)), (this.g = ua(e.g)), (this.b = ua(e.b)), this;
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
    }
    getHex() {
        return (
            ((this.r * 255) << 16) ^
            ((this.g * 255) << 8) ^
            ((this.b * 255) << 0)
        );
    }
    getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(e) {
        let t = this.r,
            n = this.g,
            i = this.b,
            s = Math.max(t, n, i),
            o = Math.min(t, n, i),
            a,
            l,
            c = (o + s) / 2;
        if (o === s) (a = 0), (l = 0);
        else {
            let h = s - o;
            switch (((l = c <= 0.5 ? h / (s + o) : h / (2 - s - o)), s)) {
                case t:
                    a = (n - i) / h + (n < i ? 6 : 0);
                    break;
                case n:
                    a = (i - t) / h + 2;
                    break;
                case i:
                    a = (t - n) / h + 4;
                    break;
            }
            a /= 6;
        }
        return (e.h = a), (e.s = l), (e.l = c), e;
    }
    getStyle() {
        return (
            "rgb(" +
            ((this.r * 255) | 0) +
            "," +
            ((this.g * 255) | 0) +
            "," +
            ((this.b * 255) | 0) +
            ")"
        );
    }
    offsetHSL(e, t, n) {
        return (
            this.getHSL(zt),
            (zt.h += e),
            (zt.s += t),
            (zt.l += n),
            this.setHSL(zt.h, zt.s, zt.l),
            this
        );
    }
    add(e) {
        return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
    }
    addColors(e, t) {
        return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
        );
    }
    addScalar(e) {
        return (this.r += e), (this.g += e), (this.b += e), this;
    }
    sub(e) {
        return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
        );
    }
    multiply(e) {
        return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
    }
    multiplyScalar(e) {
        return (this.r *= e), (this.g *= e), (this.b *= e), this;
    }
    lerp(e, t) {
        return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
        );
    }
    lerpColors(e, t, n) {
        return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
        );
    }
    lerpHSL(e, t) {
        this.getHSL(zt), e.getHSL(lr);
        let n = ps(zt.h, lr.h, t),
            i = ps(zt.s, lr.s, t),
            s = ps(zt.l, lr.l, t);
        return this.setHSL(n, i, s), this;
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
        return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
        return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
    }
    fromBufferAttribute(e, t) {
        return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            e.normalized === !0 &&
                ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
            this
        );
    }
    toJSON() {
        return this.getHex();
    }
};
re.NAMES = ou;
re.prototype.isColor = !0;
re.prototype.r = 1;
re.prototype.g = 1;
re.prototype.b = 1;
var Yt = class extends ct {
    constructor(e) {
        super(),
            (this.type = "MeshBasicMaterial"),
            (this.color = new re(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Go),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            this
        );
    }
};
Yt.prototype.isMeshBasicMaterial = !0;
var Je = new M(),
    cr = new W(),
    ze = class {
        constructor(e, t, n) {
            if (Array.isArray(e))
                throw new TypeError(
                    "THREE.BufferAttribute: array should be a Typed Array."
                );
            (this.name = ""),
                (this.array = e),
                (this.itemSize = t),
                (this.count = e !== void 0 ? e.length / t : 0),
                (this.normalized = n === !0),
                (this.usage = vs),
                (this.updateRange = { offset: 0, count: -1 }),
                (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
            e === !0 && this.version++;
        }
        setUsage(e) {
            return (this.usage = e), this;
        }
        copy(e) {
            return (
                (this.name = e.name),
                (this.array = new e.array.constructor(e.array)),
                (this.itemSize = e.itemSize),
                (this.count = e.count),
                (this.normalized = e.normalized),
                (this.usage = e.usage),
                this
            );
        }
        copyAt(e, t, n) {
            (e *= this.itemSize), (n *= t.itemSize);
            for (let i = 0, s = this.itemSize; i < s; i++)
                this.array[e + i] = t.array[n + i];
            return this;
        }
        copyArray(e) {
            return this.array.set(e), this;
        }
        copyColorsArray(e) {
            let t = this.array,
                n = 0;
            for (let i = 0, s = e.length; i < s; i++) {
                let o = e[i];
                o === void 0 &&
                    (console.warn(
                        "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                        i
                    ),
                    (o = new re())),
                    (t[n++] = o.r),
                    (t[n++] = o.g),
                    (t[n++] = o.b);
            }
            return this;
        }
        copyVector2sArray(e) {
            let t = this.array,
                n = 0;
            for (let i = 0, s = e.length; i < s; i++) {
                let o = e[i];
                o === void 0 &&
                    (console.warn(
                        "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                        i
                    ),
                    (o = new W())),
                    (t[n++] = o.x),
                    (t[n++] = o.y);
            }
            return this;
        }
        copyVector3sArray(e) {
            let t = this.array,
                n = 0;
            for (let i = 0, s = e.length; i < s; i++) {
                let o = e[i];
                o === void 0 &&
                    (console.warn(
                        "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                        i
                    ),
                    (o = new M())),
                    (t[n++] = o.x),
                    (t[n++] = o.y),
                    (t[n++] = o.z);
            }
            return this;
        }
        copyVector4sArray(e) {
            let t = this.array,
                n = 0;
            for (let i = 0, s = e.length; i < s; i++) {
                let o = e[i];
                o === void 0 &&
                    (console.warn(
                        "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                        i
                    ),
                    (o = new Ve())),
                    (t[n++] = o.x),
                    (t[n++] = o.y),
                    (t[n++] = o.z),
                    (t[n++] = o.w);
            }
            return this;
        }
        applyMatrix3(e) {
            if (this.itemSize === 2)
                for (let t = 0, n = this.count; t < n; t++)
                    cr.fromBufferAttribute(this, t),
                        cr.applyMatrix3(e),
                        this.setXY(t, cr.x, cr.y);
            else if (this.itemSize === 3)
                for (let t = 0, n = this.count; t < n; t++)
                    Je.fromBufferAttribute(this, t),
                        Je.applyMatrix3(e),
                        this.setXYZ(t, Je.x, Je.y, Je.z);
            return this;
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.count; t < n; t++)
                (Je.x = this.getX(t)),
                    (Je.y = this.getY(t)),
                    (Je.z = this.getZ(t)),
                    Je.applyMatrix4(e),
                    this.setXYZ(t, Je.x, Je.y, Je.z);
            return this;
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++)
                (Je.x = this.getX(t)),
                    (Je.y = this.getY(t)),
                    (Je.z = this.getZ(t)),
                    Je.applyNormalMatrix(e),
                    this.setXYZ(t, Je.x, Je.y, Je.z);
            return this;
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++)
                (Je.x = this.getX(t)),
                    (Je.y = this.getY(t)),
                    (Je.z = this.getZ(t)),
                    Je.transformDirection(e),
                    this.setXYZ(t, Je.x, Je.y, Je.z);
            return this;
        }
        set(e, t = 0) {
            return this.array.set(e, t), this;
        }
        getX(e) {
            return this.array[e * this.itemSize];
        }
        setX(e, t) {
            return (this.array[e * this.itemSize] = t), this;
        }
        getY(e) {
            return this.array[e * this.itemSize + 1];
        }
        setY(e, t) {
            return (this.array[e * this.itemSize + 1] = t), this;
        }
        getZ(e) {
            return this.array[e * this.itemSize + 2];
        }
        setZ(e, t) {
            return (this.array[e * this.itemSize + 2] = t), this;
        }
        getW(e) {
            return this.array[e * this.itemSize + 3];
        }
        setW(e, t) {
            return (this.array[e * this.itemSize + 3] = t), this;
        }
        setXY(e, t, n) {
            return (
                (e *= this.itemSize),
                (this.array[e + 0] = t),
                (this.array[e + 1] = n),
                this
            );
        }
        setXYZ(e, t, n, i) {
            return (
                (e *= this.itemSize),
                (this.array[e + 0] = t),
                (this.array[e + 1] = n),
                (this.array[e + 2] = i),
                this
            );
        }
        setXYZW(e, t, n, i, s) {
            return (
                (e *= this.itemSize),
                (this.array[e + 0] = t),
                (this.array[e + 1] = n),
                (this.array[e + 2] = i),
                (this.array[e + 3] = s),
                this
            );
        }
        onUpload(e) {
            return (this.onUploadCallback = e), this;
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
            let e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized,
            };
            return (
                this.name !== "" && (e.name = this.name),
                this.usage !== vs && (e.usage = this.usage),
                (this.updateRange.offset !== 0 ||
                    this.updateRange.count !== -1) &&
                    (e.updateRange = this.updateRange),
                e
            );
        }
    };
ze.prototype.isBufferAttribute = !0;
var za = class extends ze {
        constructor(e, t, n) {
            super(new Int8Array(e), t, n);
        }
    },
    Ba = class extends ze {
        constructor(e, t, n) {
            super(new Uint8Array(e), t, n);
        }
    },
    Ua = class extends ze {
        constructor(e, t, n) {
            super(new Uint8ClampedArray(e), t, n);
        }
    },
    Oa = class extends ze {
        constructor(e, t, n) {
            super(new Int16Array(e), t, n);
        }
    },
    Ss = class extends ze {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n);
        }
    },
    Ha = class extends ze {
        constructor(e, t, n) {
            super(new Int32Array(e), t, n);
        }
    },
    Ts = class extends ze {
        constructor(e, t, n) {
            super(new Uint32Array(e), t, n);
        }
    },
    ka = class extends ze {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n);
        }
    };
ka.prototype.isFloat16BufferAttribute = !0;
var de = class extends ze {
        constructor(e, t, n) {
            super(new Float32Array(e), t, n);
        }
    },
    Va = class extends ze {
        constructor(e, t, n) {
            super(new Float64Array(e), t, n);
        }
    },
    Cf = 0,
    Lt = new me(),
    da = new Be(),
    ui = new M(),
    Rt = new Tt(),
    ss = new Tt(),
    ut = new M(),
    _e = class r extends cn {
        constructor() {
            super(),
                Object.defineProperty(this, "id", { value: Cf++ }),
                (this.uuid = Ct()),
                (this.name = ""),
                (this.type = "BufferGeometry"),
                (this.index = null),
                (this.attributes = {}),
                (this.morphAttributes = {}),
                (this.morphTargetsRelative = !1),
                (this.groups = []),
                (this.boundingBox = null),
                (this.boundingSphere = null),
                (this.drawRange = { start: 0, count: 1 / 0 }),
                (this.userData = {});
        }
        getIndex() {
            return this.index;
        }
        setIndex(e) {
            return (
                Array.isArray(e)
                    ? (this.index = new (ru(e) > 65535 ? Ts : Ss)(e, 1))
                    : (this.index = e),
                this
            );
        }
        getAttribute(e) {
            return this.attributes[e];
        }
        setAttribute(e, t) {
            return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
            return delete this.attributes[e], this;
        }
        hasAttribute(e) {
            return this.attributes[e] !== void 0;
        }
        addGroup(e, t, n = 0) {
            this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(e, t) {
            (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
            let t = this.attributes.position;
            t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
            let n = this.attributes.normal;
            if (n !== void 0) {
                let s = new rt().getNormalMatrix(e);
                n.applyNormalMatrix(s), (n.needsUpdate = !0);
            }
            let i = this.attributes.tangent;
            return (
                i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
                this.boundingBox !== null && this.computeBoundingBox(),
                this.boundingSphere !== null && this.computeBoundingSphere(),
                this
            );
        }
        applyQuaternion(e) {
            return (
                Lt.makeRotationFromQuaternion(e), this.applyMatrix4(Lt), this
            );
        }
        rotateX(e) {
            return Lt.makeRotationX(e), this.applyMatrix4(Lt), this;
        }
        rotateY(e) {
            return Lt.makeRotationY(e), this.applyMatrix4(Lt), this;
        }
        rotateZ(e) {
            return Lt.makeRotationZ(e), this.applyMatrix4(Lt), this;
        }
        translate(e, t, n) {
            return Lt.makeTranslation(e, t, n), this.applyMatrix4(Lt), this;
        }
        scale(e, t, n) {
            return Lt.makeScale(e, t, n), this.applyMatrix4(Lt), this;
        }
        lookAt(e) {
            return (
                da.lookAt(e),
                da.updateMatrix(),
                this.applyMatrix4(da.matrix),
                this
            );
        }
        center() {
            return (
                this.computeBoundingBox(),
                this.boundingBox.getCenter(ui).negate(),
                this.translate(ui.x, ui.y, ui.z),
                this
            );
        }
        setFromPoints(e) {
            let t = [];
            for (let n = 0, i = e.length; n < i; n++) {
                let s = e[n];
                t.push(s.x, s.y, s.z || 0);
            }
            return this.setAttribute("position", new de(t, 3)), this;
        }
        computeBoundingBox() {
            this.boundingBox === null && (this.boundingBox = new Tt());
            let e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error(
                    'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                    this
                ),
                    this.boundingBox.set(
                        new M(-1 / 0, -1 / 0, -1 / 0),
                        new M(1 / 0, 1 / 0, 1 / 0)
                    );
                return;
            }
            if (e !== void 0) {
                if ((this.boundingBox.setFromBufferAttribute(e), t))
                    for (let n = 0, i = t.length; n < i; n++) {
                        let s = t[n];
                        Rt.setFromBufferAttribute(s),
                            this.morphTargetsRelative
                                ? (ut.addVectors(this.boundingBox.min, Rt.min),
                                  this.boundingBox.expandByPoint(ut),
                                  ut.addVectors(this.boundingBox.max, Rt.max),
                                  this.boundingBox.expandByPoint(ut))
                                : (this.boundingBox.expandByPoint(Rt.min),
                                  this.boundingBox.expandByPoint(Rt.max));
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
                isNaN(this.boundingBox.min.y) ||
                isNaN(this.boundingBox.min.z)) &&
                console.error(
                    'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                    this
                );
        }
        computeBoundingSphere() {
            this.boundingSphere === null && (this.boundingSphere = new hn());
            let e = this.attributes.position,
                t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute) {
                console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                    this
                ),
                    this.boundingSphere.set(new M(), 1 / 0);
                return;
            }
            if (e) {
                let n = this.boundingSphere.center;
                if ((Rt.setFromBufferAttribute(e), t))
                    for (let s = 0, o = t.length; s < o; s++) {
                        let a = t[s];
                        ss.setFromBufferAttribute(a),
                            this.morphTargetsRelative
                                ? (ut.addVectors(Rt.min, ss.min),
                                  Rt.expandByPoint(ut),
                                  ut.addVectors(Rt.max, ss.max),
                                  Rt.expandByPoint(ut))
                                : (Rt.expandByPoint(ss.min),
                                  Rt.expandByPoint(ss.max));
                    }
                Rt.getCenter(n);
                let i = 0;
                for (let s = 0, o = e.count; s < o; s++)
                    ut.fromBufferAttribute(e, s),
                        (i = Math.max(i, n.distanceToSquared(ut)));
                if (t)
                    for (let s = 0, o = t.length; s < o; s++) {
                        let a = t[s],
                            l = this.morphTargetsRelative;
                        for (let c = 0, h = a.count; c < h; c++)
                            ut.fromBufferAttribute(a, c),
                                l && (ui.fromBufferAttribute(e, c), ut.add(ui)),
                                (i = Math.max(i, n.distanceToSquared(ut)));
                    }
                (this.boundingSphere.radius = Math.sqrt(i)),
                    isNaN(this.boundingSphere.radius) &&
                        console.error(
                            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                            this
                        );
            }
        }
        computeTangents() {
            let e = this.index,
                t = this.attributes;
            if (
                e === null ||
                t.position === void 0 ||
                t.normal === void 0 ||
                t.uv === void 0
            ) {
                console.error(
                    "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
                );
                return;
            }
            let n = e.array,
                i = t.position.array,
                s = t.normal.array,
                o = t.uv.array,
                a = i.length / 3;
            t.tangent === void 0 &&
                this.setAttribute(
                    "tangent",
                    new ze(new Float32Array(4 * a), 4)
                );
            let l = t.tangent.array,
                c = [],
                h = [];
            for (let z = 0; z < a; z++) (c[z] = new M()), (h[z] = new M());
            let u = new M(),
                d = new M(),
                f = new M(),
                m = new W(),
                x = new W(),
                v = new W(),
                g = new M(),
                p = new M();
            function _(z, P, b) {
                u.fromArray(i, z * 3),
                    d.fromArray(i, P * 3),
                    f.fromArray(i, b * 3),
                    m.fromArray(o, z * 2),
                    x.fromArray(o, P * 2),
                    v.fromArray(o, b * 2),
                    d.sub(u),
                    f.sub(u),
                    x.sub(m),
                    v.sub(m);
                let E = 1 / (x.x * v.y - v.x * x.y);
                isFinite(E) &&
                    (g
                        .copy(d)
                        .multiplyScalar(v.y)
                        .addScaledVector(f, -x.y)
                        .multiplyScalar(E),
                    p
                        .copy(f)
                        .multiplyScalar(x.x)
                        .addScaledVector(d, -v.x)
                        .multiplyScalar(E),
                    c[z].add(g),
                    c[P].add(g),
                    c[b].add(g),
                    h[z].add(p),
                    h[P].add(p),
                    h[b].add(p));
            }
            let y = this.groups;
            y.length === 0 && (y = [{ start: 0, count: n.length }]);
            for (let z = 0, P = y.length; z < P; ++z) {
                let b = y[z],
                    E = b.start,
                    D = b.count;
                for (let U = E, F = E + D; U < F; U += 3)
                    _(n[U + 0], n[U + 1], n[U + 2]);
            }
            let w = new M(),
                A = new M(),
                C = new M(),
                I = new M();
            function k(z) {
                C.fromArray(s, z * 3), I.copy(C);
                let P = c[z];
                w.copy(P),
                    w.sub(C.multiplyScalar(C.dot(P))).normalize(),
                    A.crossVectors(I, P);
                let E = A.dot(h[z]) < 0 ? -1 : 1;
                (l[z * 4] = w.x),
                    (l[z * 4 + 1] = w.y),
                    (l[z * 4 + 2] = w.z),
                    (l[z * 4 + 3] = E);
            }
            for (let z = 0, P = y.length; z < P; ++z) {
                let b = y[z],
                    E = b.start,
                    D = b.count;
                for (let U = E, F = E + D; U < F; U += 3)
                    k(n[U + 0]), k(n[U + 1]), k(n[U + 2]);
            }
        }
        computeVertexNormals() {
            let e = this.index,
                t = this.getAttribute("position");
            if (t !== void 0) {
                let n = this.getAttribute("normal");
                if (n === void 0)
                    (n = new ze(new Float32Array(t.count * 3), 3)),
                        this.setAttribute("normal", n);
                else
                    for (let d = 0, f = n.count; d < f; d++)
                        n.setXYZ(d, 0, 0, 0);
                let i = new M(),
                    s = new M(),
                    o = new M(),
                    a = new M(),
                    l = new M(),
                    c = new M(),
                    h = new M(),
                    u = new M();
                if (e)
                    for (let d = 0, f = e.count; d < f; d += 3) {
                        let m = e.getX(d + 0),
                            x = e.getX(d + 1),
                            v = e.getX(d + 2);
                        i.fromBufferAttribute(t, m),
                            s.fromBufferAttribute(t, x),
                            o.fromBufferAttribute(t, v),
                            h.subVectors(o, s),
                            u.subVectors(i, s),
                            h.cross(u),
                            a.fromBufferAttribute(n, m),
                            l.fromBufferAttribute(n, x),
                            c.fromBufferAttribute(n, v),
                            a.add(h),
                            l.add(h),
                            c.add(h),
                            n.setXYZ(m, a.x, a.y, a.z),
                            n.setXYZ(x, l.x, l.y, l.z),
                            n.setXYZ(v, c.x, c.y, c.z);
                    }
                else
                    for (let d = 0, f = t.count; d < f; d += 3)
                        i.fromBufferAttribute(t, d + 0),
                            s.fromBufferAttribute(t, d + 1),
                            o.fromBufferAttribute(t, d + 2),
                            h.subVectors(o, s),
                            u.subVectors(i, s),
                            h.cross(u),
                            n.setXYZ(d + 0, h.x, h.y, h.z),
                            n.setXYZ(d + 1, h.x, h.y, h.z),
                            n.setXYZ(d + 2, h.x, h.y, h.z);
                this.normalizeNormals(), (n.needsUpdate = !0);
            }
        }
        merge(e, t) {
            if (!(e && e.isBufferGeometry)) {
                console.error(
                    "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                    e
                );
                return;
            }
            t === void 0 &&
                ((t = 0),
                console.warn(
                    "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                ));
            let n = this.attributes;
            for (let i in n) {
                if (e.attributes[i] === void 0) continue;
                let o = n[i].array,
                    a = e.attributes[i],
                    l = a.array,
                    c = a.itemSize * t,
                    h = Math.min(l.length, o.length - c);
                for (let u = 0, d = c; u < h; u++, d++) o[d] = l[u];
            }
            return this;
        }
        normalizeNormals() {
            let e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++)
                ut.fromBufferAttribute(e, t),
                    ut.normalize(),
                    e.setXYZ(t, ut.x, ut.y, ut.z);
        }
        toNonIndexed() {
            function e(a, l) {
                let c = a.array,
                    h = a.itemSize,
                    u = a.normalized,
                    d = new c.constructor(l.length * h),
                    f = 0,
                    m = 0;
                for (let x = 0, v = l.length; x < v; x++) {
                    a.isInterleavedBufferAttribute
                        ? (f = l[x] * a.data.stride + a.offset)
                        : (f = l[x] * h);
                    for (let g = 0; g < h; g++) d[m++] = c[f++];
                }
                return new ze(d, h, u);
            }
            if (this.index === null)
                return (
                    console.warn(
                        "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                    ),
                    this
                );
            let t = new r(),
                n = this.index.array,
                i = this.attributes;
            for (let a in i) {
                let l = i[a],
                    c = e(l, n);
                t.setAttribute(a, c);
            }
            let s = this.morphAttributes;
            for (let a in s) {
                let l = [],
                    c = s[a];
                for (let h = 0, u = c.length; h < u; h++) {
                    let d = c[h],
                        f = e(d, n);
                    l.push(f);
                }
                t.morphAttributes[a] = l;
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            let o = this.groups;
            for (let a = 0, l = o.length; a < l; a++) {
                let c = o[a];
                t.addGroup(c.start, c.count, c.materialIndex);
            }
            return t;
        }
        toJSON() {
            let e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON",
                },
            };
            if (
                ((e.uuid = this.uuid),
                (e.type = this.type),
                this.name !== "" && (e.name = this.name),
                Object.keys(this.userData).length > 0 &&
                    (e.userData = this.userData),
                this.parameters !== void 0)
            ) {
                let l = this.parameters;
                for (let c in l) l[c] !== void 0 && (e[c] = l[c]);
                return e;
            }
            e.data = { attributes: {} };
            let t = this.index;
            t !== null &&
                (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array),
                });
            let n = this.attributes;
            for (let l in n) {
                let c = n[l];
                e.data.attributes[l] = c.toJSON(e.data);
            }
            let i = {},
                s = !1;
            for (let l in this.morphAttributes) {
                let c = this.morphAttributes[l],
                    h = [];
                for (let u = 0, d = c.length; u < d; u++) {
                    let f = c[u];
                    h.push(f.toJSON(e.data));
                }
                h.length > 0 && ((i[l] = h), (s = !0));
            }
            s &&
                ((e.data.morphAttributes = i),
                (e.data.morphTargetsRelative = this.morphTargetsRelative));
            let o = this.groups;
            o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
            let a = this.boundingSphere;
            return (
                a !== null &&
                    (e.data.boundingSphere = {
                        center: a.center.toArray(),
                        radius: a.radius,
                    }),
                e
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            (this.index = null),
                (this.attributes = {}),
                (this.morphAttributes = {}),
                (this.groups = []),
                (this.boundingBox = null),
                (this.boundingSphere = null);
            let t = {};
            this.name = e.name;
            let n = e.index;
            n !== null && this.setIndex(n.clone(t));
            let i = e.attributes;
            for (let c in i) {
                let h = i[c];
                this.setAttribute(c, h.clone(t));
            }
            let s = e.morphAttributes;
            for (let c in s) {
                let h = [],
                    u = s[c];
                for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
                this.morphAttributes[c] = h;
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            let o = e.groups;
            for (let c = 0, h = o.length; c < h; c++) {
                let u = o[c];
                this.addGroup(u.start, u.count, u.materialIndex);
            }
            let a = e.boundingBox;
            a !== null && (this.boundingBox = a.clone());
            let l = e.boundingSphere;
            return (
                l !== null && (this.boundingSphere = l.clone()),
                (this.drawRange.start = e.drawRange.start),
                (this.drawRange.count = e.drawRange.count),
                (this.userData = e.userData),
                e.parameters !== void 0 &&
                    (this.parameters = Object.assign({}, e.parameters)),
                this
            );
        }
        dispose() {
            this.dispatchEvent({ type: "dispose" });
        }
    };
_e.prototype.isBufferGeometry = !0;
var vc = new me(),
    di = new un(),
    fa = new hn(),
    gn = new M(),
    xn = new M(),
    yn = new M(),
    pa = new M(),
    ma = new M(),
    ga = new M(),
    hr = new M(),
    ur = new M(),
    dr = new M(),
    fr = new W(),
    pr = new W(),
    mr = new W(),
    xa = new M(),
    gr = new M(),
    nt = class extends Be {
        constructor(e = new _e(), t = new Yt()) {
            super(),
                (this.type = "Mesh"),
                (this.geometry = e),
                (this.material = t),
                this.updateMorphTargets();
        }
        copy(e) {
            return (
                super.copy(e),
                e.morphTargetInfluences !== void 0 &&
                    (this.morphTargetInfluences =
                        e.morphTargetInfluences.slice()),
                e.morphTargetDictionary !== void 0 &&
                    (this.morphTargetDictionary = Object.assign(
                        {},
                        e.morphTargetDictionary
                    )),
                (this.material = e.material),
                (this.geometry = e.geometry),
                this
            );
        }
        updateMorphTargets() {
            let e = this.geometry;
            if (e.isBufferGeometry) {
                let t = e.morphAttributes,
                    n = Object.keys(t);
                if (n.length > 0) {
                    let i = t[n[0]];
                    if (i !== void 0) {
                        (this.morphTargetInfluences = []),
                            (this.morphTargetDictionary = {});
                        for (let s = 0, o = i.length; s < o; s++) {
                            let a = i[s].name || String(s);
                            this.morphTargetInfluences.push(0),
                                (this.morphTargetDictionary[a] = s);
                        }
                    }
                }
            } else {
                let t = e.morphTargets;
                t !== void 0 &&
                    t.length > 0 &&
                    console.error(
                        "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
            }
        }
        raycast(e, t) {
            let n = this.geometry,
                i = this.material,
                s = this.matrixWorld;
            if (
                i === void 0 ||
                (n.boundingSphere === null && n.computeBoundingSphere(),
                fa.copy(n.boundingSphere),
                fa.applyMatrix4(s),
                e.ray.intersectsSphere(fa) === !1) ||
                (vc.copy(s).invert(),
                di.copy(e.ray).applyMatrix4(vc),
                n.boundingBox !== null &&
                    di.intersectsBox(n.boundingBox) === !1)
            )
                return;
            let o;
            if (n.isBufferGeometry) {
                let a = n.index,
                    l = n.attributes.position,
                    c = n.morphAttributes.position,
                    h = n.morphTargetsRelative,
                    u = n.attributes.uv,
                    d = n.attributes.uv2,
                    f = n.groups,
                    m = n.drawRange;
                if (a !== null)
                    if (Array.isArray(i))
                        for (let x = 0, v = f.length; x < v; x++) {
                            let g = f[x],
                                p = i[g.materialIndex],
                                _ = Math.max(g.start, m.start),
                                y = Math.min(
                                    a.count,
                                    Math.min(
                                        g.start + g.count,
                                        m.start + m.count
                                    )
                                );
                            for (let w = _, A = y; w < A; w += 3) {
                                let C = a.getX(w),
                                    I = a.getX(w + 1),
                                    k = a.getX(w + 2);
                                (o = xr(
                                    this,
                                    p,
                                    e,
                                    di,
                                    l,
                                    c,
                                    h,
                                    u,
                                    d,
                                    C,
                                    I,
                                    k
                                )),
                                    o &&
                                        ((o.faceIndex = Math.floor(w / 3)),
                                        (o.face.materialIndex =
                                            g.materialIndex),
                                        t.push(o));
                            }
                        }
                    else {
                        let x = Math.max(0, m.start),
                            v = Math.min(a.count, m.start + m.count);
                        for (let g = x, p = v; g < p; g += 3) {
                            let _ = a.getX(g),
                                y = a.getX(g + 1),
                                w = a.getX(g + 2);
                            (o = xr(this, i, e, di, l, c, h, u, d, _, y, w)),
                                o &&
                                    ((o.faceIndex = Math.floor(g / 3)),
                                    t.push(o));
                        }
                    }
                else if (l !== void 0)
                    if (Array.isArray(i))
                        for (let x = 0, v = f.length; x < v; x++) {
                            let g = f[x],
                                p = i[g.materialIndex],
                                _ = Math.max(g.start, m.start),
                                y = Math.min(
                                    l.count,
                                    Math.min(
                                        g.start + g.count,
                                        m.start + m.count
                                    )
                                );
                            for (let w = _, A = y; w < A; w += 3) {
                                let C = w,
                                    I = w + 1,
                                    k = w + 2;
                                (o = xr(
                                    this,
                                    p,
                                    e,
                                    di,
                                    l,
                                    c,
                                    h,
                                    u,
                                    d,
                                    C,
                                    I,
                                    k
                                )),
                                    o &&
                                        ((o.faceIndex = Math.floor(w / 3)),
                                        (o.face.materialIndex =
                                            g.materialIndex),
                                        t.push(o));
                            }
                        }
                    else {
                        let x = Math.max(0, m.start),
                            v = Math.min(l.count, m.start + m.count);
                        for (let g = x, p = v; g < p; g += 3) {
                            let _ = g,
                                y = g + 1,
                                w = g + 2;
                            (o = xr(this, i, e, di, l, c, h, u, d, _, y, w)),
                                o &&
                                    ((o.faceIndex = Math.floor(g / 3)),
                                    t.push(o));
                        }
                    }
            } else
                n.isGeometry &&
                    console.error(
                        "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
        }
    };
nt.prototype.isMesh = !0;
function Lf(r, e, t, n, i, s, o, a) {
    let l;
    if (
        (e.side === it
            ? (l = n.intersectTriangle(o, s, i, !0, a))
            : (l = n.intersectTriangle(i, s, o, e.side !== Li, a)),
        l === null)
    )
        return null;
    gr.copy(a), gr.applyMatrix4(r.matrixWorld);
    let c = t.ray.origin.distanceTo(gr);
    return c < t.near || c > t.far
        ? null
        : { distance: c, point: gr.clone(), object: r };
}
function xr(r, e, t, n, i, s, o, a, l, c, h, u) {
    gn.fromBufferAttribute(i, c),
        xn.fromBufferAttribute(i, h),
        yn.fromBufferAttribute(i, u);
    let d = r.morphTargetInfluences;
    if (s && d) {
        hr.set(0, 0, 0), ur.set(0, 0, 0), dr.set(0, 0, 0);
        for (let m = 0, x = s.length; m < x; m++) {
            let v = d[m],
                g = s[m];
            v !== 0 &&
                (pa.fromBufferAttribute(g, c),
                ma.fromBufferAttribute(g, h),
                ga.fromBufferAttribute(g, u),
                o
                    ? (hr.addScaledVector(pa, v),
                      ur.addScaledVector(ma, v),
                      dr.addScaledVector(ga, v))
                    : (hr.addScaledVector(pa.sub(gn), v),
                      ur.addScaledVector(ma.sub(xn), v),
                      dr.addScaledVector(ga.sub(yn), v)));
        }
        gn.add(hr), xn.add(ur), yn.add(dr);
    }
    r.isSkinnedMesh &&
        (r.boneTransform(c, gn),
        r.boneTransform(h, xn),
        r.boneTransform(u, yn));
    let f = Lf(r, e, t, n, gn, xn, yn, xa);
    if (f) {
        a &&
            (fr.fromBufferAttribute(a, c),
            pr.fromBufferAttribute(a, h),
            mr.fromBufferAttribute(a, u),
            (f.uv = vt.getUV(xa, gn, xn, yn, fr, pr, mr, new W()))),
            l &&
                (fr.fromBufferAttribute(l, c),
                pr.fromBufferAttribute(l, h),
                mr.fromBufferAttribute(l, u),
                (f.uv2 = vt.getUV(xa, gn, xn, yn, fr, pr, mr, new W())));
        let m = { a: c, b: h, c: u, normal: new M(), materialIndex: 0 };
        vt.getNormal(gn, xn, yn, m.normal), (f.face = m);
    }
    return f;
}
var $n = class r extends _e {
    constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
        super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: i,
                heightSegments: s,
                depthSegments: o,
            });
        let a = this;
        (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
        let l = [],
            c = [],
            h = [],
            u = [],
            d = 0,
            f = 0;
        m("z", "y", "x", -1, -1, n, t, e, o, s, 0),
            m("z", "y", "x", 1, -1, n, t, -e, o, s, 1),
            m("x", "z", "y", 1, 1, e, n, t, i, o, 2),
            m("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
            m("x", "y", "z", 1, -1, e, t, n, i, s, 4),
            m("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
            this.setIndex(l),
            this.setAttribute("position", new de(c, 3)),
            this.setAttribute("normal", new de(h, 3)),
            this.setAttribute("uv", new de(u, 2));
        function m(x, v, g, p, _, y, w, A, C, I, k) {
            let z = y / C,
                P = w / I,
                b = y / 2,
                E = w / 2,
                D = A / 2,
                U = C + 1,
                F = I + 1,
                O = 0,
                ne = 0,
                ce = new M();
            for (let G = 0; G < F; G++) {
                let q = G * P - E;
                for (let he = 0; he < U; he++) {
                    let le = he * z - b;
                    (ce[x] = le * p),
                        (ce[v] = q * _),
                        (ce[g] = D),
                        c.push(ce.x, ce.y, ce.z),
                        (ce[x] = 0),
                        (ce[v] = 0),
                        (ce[g] = A > 0 ? 1 : -1),
                        h.push(ce.x, ce.y, ce.z),
                        u.push(he / C),
                        u.push(1 - G / I),
                        (O += 1);
                }
            }
            for (let G = 0; G < I; G++)
                for (let q = 0; q < C; q++) {
                    let he = d + q + U * G,
                        le = d + q + U * (G + 1),
                        fe = d + (q + 1) + U * (G + 1),
                        Ne = d + (q + 1) + U * G;
                    l.push(he, le, Ne), l.push(le, fe, Ne), (ne += 6);
                }
            a.addGroup(f, ne, k), (f += ne), (d += O);
        }
    }
    static fromJSON(e) {
        return new r(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
        );
    }
};
function Di(r) {
    let e = {};
    for (let t in r) {
        e[t] = {};
        for (let n in r[t]) {
            let i = r[t][n];
            i &&
            (i.isColor ||
                i.isMatrix3 ||
                i.isMatrix4 ||
                i.isVector2 ||
                i.isVector3 ||
                i.isVector4 ||
                i.isTexture ||
                i.isQuaternion)
                ? (e[t][n] = i.clone())
                : Array.isArray(i)
                ? (e[t][n] = i.slice())
                : (e[t][n] = i);
        }
    }
    return e;
}
function xt(r) {
    let e = {};
    for (let t = 0; t < r.length; t++) {
        let n = Di(r[t]);
        for (let i in n) e[i] = n[i];
    }
    return e;
}
var Pf = { clone: Di, merge: xt },
    If = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    Df = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
    Zt = class extends ct {
        constructor(e) {
            super(),
                (this.type = "ShaderMaterial"),
                (this.defines = {}),
                (this.uniforms = {}),
                (this.vertexShader = If),
                (this.fragmentShader = Df),
                (this.linewidth = 1),
                (this.wireframe = !1),
                (this.wireframeLinewidth = 1),
                (this.fog = !1),
                (this.lights = !1),
                (this.clipping = !1),
                (this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                }),
                (this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0],
                }),
                (this.index0AttributeName = void 0),
                (this.uniformsNeedUpdate = !1),
                (this.glslVersion = null),
                e !== void 0 &&
                    (e.attributes !== void 0 &&
                        console.error(
                            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                        ),
                    this.setValues(e));
        }
        copy(e) {
            return (
                super.copy(e),
                (this.fragmentShader = e.fragmentShader),
                (this.vertexShader = e.vertexShader),
                (this.uniforms = Di(e.uniforms)),
                (this.defines = Object.assign({}, e.defines)),
                (this.wireframe = e.wireframe),
                (this.wireframeLinewidth = e.wireframeLinewidth),
                (this.lights = e.lights),
                (this.clipping = e.clipping),
                (this.extensions = Object.assign({}, e.extensions)),
                (this.glslVersion = e.glslVersion),
                this
            );
        }
        toJSON(e) {
            let t = super.toJSON(e);
            (t.glslVersion = this.glslVersion), (t.uniforms = {});
            for (let i in this.uniforms) {
                let o = this.uniforms[i].value;
                o && o.isTexture
                    ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
                    : o && o.isColor
                    ? (t.uniforms[i] = { type: "c", value: o.getHex() })
                    : o && o.isVector2
                    ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
                    : o && o.isVector3
                    ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
                    : o && o.isVector4
                    ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
                    : o && o.isMatrix3
                    ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
                    : o && o.isMatrix4
                    ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
                    : (t.uniforms[i] = { value: o });
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                (t.vertexShader = this.vertexShader),
                (t.fragmentShader = this.fragmentShader);
            let n = {};
            for (let i in this.extensions)
                this.extensions[i] === !0 && (n[i] = !0);
            return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
    };
Zt.prototype.isShaderMaterial = !0;
var Fi = class extends Be {
    constructor() {
        super(),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new me()),
            (this.projectionMatrix = new me()),
            (this.projectionMatrixInverse = new me());
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        );
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize();
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
};
Fi.prototype.isCamera = !0;
var at = class extends Fi {
    constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
        super(),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
        );
    }
    setFocalLength(e) {
        let t = (0.5 * this.getFilmHeight()) / e;
        (this.fov = Ms * 2 * Math.atan(t)), this.updateProjectionMatrix();
    }
    getFocalLength() {
        let e = Math.tan(Zn * 0.5 * this.fov);
        return (0.5 * this.getFilmHeight()) / e;
    }
    getEffectiveFOV() {
        return Ms * 2 * Math.atan(Math.tan(Zn * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, n, i, s, o) {
        (this.aspect = e / t),
            this.view === null &&
                (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1,
                }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        let e = this.near,
            t = (e * Math.tan(Zn * 0.5 * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            s = -0.5 * i,
            o = this.view;
        if (this.view !== null && this.view.enabled) {
            let l = o.fullWidth,
                c = o.fullHeight;
            (s += (o.offsetX * i) / l),
                (t -= (o.offsetY * n) / c),
                (i *= o.width / l),
                (n *= o.height / c);
        }
        let a = this.filmOffset;
        a !== 0 && (s += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
                s,
                s + i,
                t,
                t - n,
                e,
                this.far
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            this.view !== null &&
                (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
        );
    }
};
at.prototype.isPerspectiveCamera = !0;
var fi = 90,
    pi = 1,
    Es = class extends Be {
        constructor(e, t, n) {
            if (
                (super(),
                (this.type = "CubeCamera"),
                n.isWebGLCubeRenderTarget !== !0)
            ) {
                console.error(
                    "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
                );
                return;
            }
            this.renderTarget = n;
            let i = new at(fi, pi, e, t);
            (i.layers = this.layers),
                i.up.set(0, -1, 0),
                i.lookAt(new M(1, 0, 0)),
                this.add(i);
            let s = new at(fi, pi, e, t);
            (s.layers = this.layers),
                s.up.set(0, -1, 0),
                s.lookAt(new M(-1, 0, 0)),
                this.add(s);
            let o = new at(fi, pi, e, t);
            (o.layers = this.layers),
                o.up.set(0, 0, 1),
                o.lookAt(new M(0, 1, 0)),
                this.add(o);
            let a = new at(fi, pi, e, t);
            (a.layers = this.layers),
                a.up.set(0, 0, -1),
                a.lookAt(new M(0, -1, 0)),
                this.add(a);
            let l = new at(fi, pi, e, t);
            (l.layers = this.layers),
                l.up.set(0, -1, 0),
                l.lookAt(new M(0, 0, 1)),
                this.add(l);
            let c = new at(fi, pi, e, t);
            (c.layers = this.layers),
                c.up.set(0, -1, 0),
                c.lookAt(new M(0, 0, -1)),
                this.add(c);
        }
        update(e, t) {
            this.parent === null && this.updateMatrixWorld();
            let n = this.renderTarget,
                [i, s, o, a, l, c] = this.children,
                h = e.xr.enabled,
                u = e.getRenderTarget();
            e.xr.enabled = !1;
            let d = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
                e.setRenderTarget(n, 0),
                e.render(t, i),
                e.setRenderTarget(n, 1),
                e.render(t, s),
                e.setRenderTarget(n, 2),
                e.render(t, o),
                e.setRenderTarget(n, 3),
                e.render(t, a),
                e.setRenderTarget(n, 4),
                e.render(t, l),
                (n.texture.generateMipmaps = d),
                e.setRenderTarget(n, 5),
                e.render(t, c),
                e.setRenderTarget(u),
                (e.xr.enabled = h);
        }
    },
    jn = class extends ft {
        constructor(e, t, n, i, s, o, a, l, c, h) {
            (e = e !== void 0 ? e : []),
                (t = t !== void 0 ? t : Yi),
                super(e, t, n, i, s, o, a, l, c, h),
                (this.flipY = !1);
        }
        get images() {
            return this.image;
        }
        set images(e) {
            this.image = e;
        }
    };
jn.prototype.isCubeTexture = !0;
var As = class extends St {
    constructor(e, t, n) {
        Number.isInteger(t) &&
            (console.warn(
                "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
            ),
            (t = n)),
            super(e, e, t),
            (t = t || {}),
            (this.texture = new jn(
                void 0,
                t.mapping,
                t.wrapS,
                t.wrapT,
                t.magFilter,
                t.minFilter,
                t.format,
                t.type,
                t.anisotropy,
                t.encoding
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
                t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
            (this.texture.minFilter =
                t.minFilter !== void 0 ? t.minFilter : tt),
            (this.texture._needsFlipEnvMap = !1);
    }
    fromEquirectangularTexture(e, t) {
        (this.texture.type = t.type),
            (this.texture.format = lt),
            (this.texture.encoding = t.encoding),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
        let n = {
                uniforms: { tEquirect: { value: null } },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
            },
            i = new $n(5, 5, 5),
            s = new Zt({
                name: "CubemapFromEquirect",
                uniforms: Di(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: it,
                blending: Mn,
            });
        s.uniforms.tEquirect.value = t;
        let o = new nt(i, s),
            a = t.minFilter;
        return (
            t.minFilter === $i && (t.minFilter = tt),
            new Es(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
        );
    }
    clear(e, t, n, i) {
        let s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, n, i);
        e.setRenderTarget(s);
    }
};
As.prototype.isWebGLCubeRenderTarget = !0;
var ya = new M(),
    Ff = new M(),
    Nf = new rt(),
    Bt = class {
        constructor(e = new M(1, 0, 0), t = 0) {
            (this.normal = e), (this.constant = t);
        }
        set(e, t) {
            return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
            return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return (
                this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
            );
        }
        setFromCoplanarPoints(e, t, n) {
            let i = ya.subVectors(n, t).cross(Ff.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
            return (
                this.normal.copy(e.normal), (this.constant = e.constant), this
            );
        }
        normalize() {
            let e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
            return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
            return t
                .copy(this.normal)
                .multiplyScalar(-this.distanceToPoint(e))
                .add(e);
        }
        intersectLine(e, t) {
            let n = e.delta(ya),
                i = this.normal.dot(n);
            if (i === 0)
                return this.distanceToPoint(e.start) === 0
                    ? t.copy(e.start)
                    : null;
            let s = -(e.start.dot(this.normal) + this.constant) / i;
            return s < 0 || s > 1
                ? null
                : t.copy(n).multiplyScalar(s).add(e.start);
        }
        intersectsLine(e) {
            let t = this.distanceToPoint(e.start),
                n = this.distanceToPoint(e.end);
            return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
            return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
            let n = t || Nf.getNormalMatrix(e),
                i = this.coplanarPoint(ya).applyMatrix4(e),
                s = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -i.dot(s)), this;
        }
        translate(e) {
            return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    };
Bt.prototype.isPlane = !0;
var mi = new hn(),
    yr = new M(),
    Ni = class {
        constructor(
            e = new Bt(),
            t = new Bt(),
            n = new Bt(),
            i = new Bt(),
            s = new Bt(),
            o = new Bt()
        ) {
            this.planes = [e, t, n, i, s, o];
        }
        set(e, t, n, i, s, o) {
            let a = this.planes;
            return (
                a[0].copy(e),
                a[1].copy(t),
                a[2].copy(n),
                a[3].copy(i),
                a[4].copy(s),
                a[5].copy(o),
                this
            );
        }
        copy(e) {
            let t = this.planes;
            for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
            return this;
        }
        setFromProjectionMatrix(e) {
            let t = this.planes,
                n = e.elements,
                i = n[0],
                s = n[1],
                o = n[2],
                a = n[3],
                l = n[4],
                c = n[5],
                h = n[6],
                u = n[7],
                d = n[8],
                f = n[9],
                m = n[10],
                x = n[11],
                v = n[12],
                g = n[13],
                p = n[14],
                _ = n[15];
            return (
                t[0].setComponents(a - i, u - l, x - d, _ - v).normalize(),
                t[1].setComponents(a + i, u + l, x + d, _ + v).normalize(),
                t[2].setComponents(a + s, u + c, x + f, _ + g).normalize(),
                t[3].setComponents(a - s, u - c, x - f, _ - g).normalize(),
                t[4].setComponents(a - o, u - h, x - m, _ - p).normalize(),
                t[5].setComponents(a + o, u + h, x + m, _ + p).normalize(),
                this
            );
        }
        intersectsObject(e) {
            let t = e.geometry;
            return (
                t.boundingSphere === null && t.computeBoundingSphere(),
                mi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(mi)
            );
        }
        intersectsSprite(e) {
            return (
                mi.center.set(0, 0, 0),
                (mi.radius = 0.7071067811865476),
                mi.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(mi)
            );
        }
        intersectsSphere(e) {
            let t = this.planes,
                n = e.center,
                i = -e.radius;
            for (let s = 0; s < 6; s++)
                if (t[s].distanceToPoint(n) < i) return !1;
            return !0;
        }
        intersectsBox(e) {
            let t = this.planes;
            for (let n = 0; n < 6; n++) {
                let i = t[n];
                if (
                    ((yr.x = i.normal.x > 0 ? e.max.x : e.min.x),
                    (yr.y = i.normal.y > 0 ? e.max.y : e.min.y),
                    (yr.z = i.normal.z > 0 ? e.max.z : e.min.z),
                    i.distanceToPoint(yr) < 0)
                )
                    return !1;
            }
            return !0;
        }
        containsPoint(e) {
            let t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0) return !1;
            return !0;
        }
        clone() {
            return new this.constructor().copy(this);
        }
    };
function au() {
    let r = null,
        e = !1,
        t = null,
        n = null;
    function i(s, o) {
        t(s, o), (n = r.requestAnimationFrame(i));
    }
    return {
        start: function () {
            e !== !0 &&
                t !== null &&
                ((n = r.requestAnimationFrame(i)), (e = !0));
        },
        stop: function () {
            r.cancelAnimationFrame(n), (e = !1);
        },
        setAnimationLoop: function (s) {
            t = s;
        },
        setContext: function (s) {
            r = s;
        },
    };
}
function zf(r, e) {
    let t = e.isWebGL2,
        n = new WeakMap();
    function i(c, h) {
        let u = c.array,
            d = c.usage,
            f = r.createBuffer();
        r.bindBuffer(h, f), r.bufferData(h, u, d), c.onUploadCallback();
        let m = 5126;
        return (
            u instanceof Float32Array
                ? (m = 5126)
                : u instanceof Float64Array
                ? console.warn(
                      "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                  )
                : u instanceof Uint16Array
                ? c.isFloat16BufferAttribute
                    ? t
                        ? (m = 5131)
                        : console.warn(
                              "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          )
                    : (m = 5123)
                : u instanceof Int16Array
                ? (m = 5122)
                : u instanceof Uint32Array
                ? (m = 5125)
                : u instanceof Int32Array
                ? (m = 5124)
                : u instanceof Int8Array
                ? (m = 5120)
                : (u instanceof Uint8Array || u instanceof Uint8ClampedArray) &&
                  (m = 5121),
            {
                buffer: f,
                type: m,
                bytesPerElement: u.BYTES_PER_ELEMENT,
                version: c.version,
            }
        );
    }
    function s(c, h, u) {
        let d = h.array,
            f = h.updateRange;
        r.bindBuffer(u, c),
            f.count === -1
                ? r.bufferSubData(u, 0, d)
                : (t
                      ? r.bufferSubData(
                            u,
                            f.offset * d.BYTES_PER_ELEMENT,
                            d,
                            f.offset,
                            f.count
                        )
                      : r.bufferSubData(
                            u,
                            f.offset * d.BYTES_PER_ELEMENT,
                            d.subarray(f.offset, f.offset + f.count)
                        ),
                  (f.count = -1));
    }
    function o(c) {
        return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
    }
    function a(c) {
        c.isInterleavedBufferAttribute && (c = c.data);
        let h = n.get(c);
        h && (r.deleteBuffer(h.buffer), n.delete(c));
    }
    function l(c, h) {
        if (c.isGLBufferAttribute) {
            let d = n.get(c);
            (!d || d.version < c.version) &&
                n.set(c, {
                    buffer: c.buffer,
                    type: c.type,
                    bytesPerElement: c.elementSize,
                    version: c.version,
                });
            return;
        }
        c.isInterleavedBufferAttribute && (c = c.data);
        let u = n.get(c);
        u === void 0
            ? n.set(c, i(c, h))
            : u.version < c.version &&
              (s(u.buffer, c, h), (u.version = c.version));
    }
    return { get: o, remove: a, update: l };
}
var Rs = class r extends _e {
        constructor(e = 1, t = 1, n = 1, i = 1) {
            super(),
                (this.type = "PlaneGeometry"),
                (this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i,
                });
            let s = e / 2,
                o = t / 2,
                a = Math.floor(n),
                l = Math.floor(i),
                c = a + 1,
                h = l + 1,
                u = e / a,
                d = t / l,
                f = [],
                m = [],
                x = [],
                v = [];
            for (let g = 0; g < h; g++) {
                let p = g * d - o;
                for (let _ = 0; _ < c; _++) {
                    let y = _ * u - s;
                    m.push(y, -p, 0),
                        x.push(0, 0, 1),
                        v.push(_ / a),
                        v.push(1 - g / l);
                }
            }
            for (let g = 0; g < l; g++)
                for (let p = 0; p < a; p++) {
                    let _ = p + c * g,
                        y = p + c * (g + 1),
                        w = p + 1 + c * (g + 1),
                        A = p + 1 + c * g;
                    f.push(_, y, A), f.push(y, w, A);
                }
            this.setIndex(f),
                this.setAttribute("position", new de(m, 3)),
                this.setAttribute("normal", new de(x, 3)),
                this.setAttribute("uv", new de(v, 2));
        }
        static fromJSON(e) {
            return new r(e.width, e.height, e.widthSegments, e.heightSegments);
        }
    },
    Bf = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
    Uf = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    Of = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
    Hf = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    kf = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    Vf = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    Gf = "vec3 transformed = vec3( position );",
    Wf = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    qf = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
    Xf = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    Jf = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
    Yf = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    Zf = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    $f = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    jf = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    Qf = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    Kf = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
    ep = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
    tp = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
    np = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		return texture2D( envMap, uv ).rgb;
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    ip = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    sp = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    rp = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
    op = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    ap = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    lp = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    cp = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    hp = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    up = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif`,
    dp = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    fp = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    pp = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    mp = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    gp = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    xp = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    yp = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    vp = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
    _p = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
    Mp = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    wp = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
    bp = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    Sp = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
    Tp = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    Ep = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
    Ap = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    Rp = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
    Cp = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
    Lp = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    Pp = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    Ip = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    Dp = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
    Fp = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    Np = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    zp = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
    Bp = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
    Up = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
    Op = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    Hp = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    kp = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    Vp = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    Gp = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    Wp = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
    qp = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
    Xp = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
    Jp = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
    Yp = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    Zp = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    $p = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    jp = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    Qp = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
    Kp = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
    em = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
    tm = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
    nm = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    im = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
    sm = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    rm = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    om = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    am = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    lm = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    cm = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    hm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
    um = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    dm = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
    fm = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    pm = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    mm = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
    gm = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    xm = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    ym = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    vm = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    _m = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    Mm = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    wm = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
    bm = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
    Sm = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
    Tm = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
    Em = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
    Am = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
    Rm = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
    Cm = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
    Lm = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
    Pm = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    Im = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    Dm = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    Fm = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    Nm = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    zm = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
    Bm = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    Um = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    Om = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    Hm = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
    km = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    Vm = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    Gm = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    Wm = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    qm = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Xm = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Jm = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    Ym = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Zm = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    $m = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
    jm = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    Qm = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Km = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    eg = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    tg = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    ng = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    ig = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    sg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    rg = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    og = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    ag = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    lg = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
    Fe = {
        alphamap_fragment: Bf,
        alphamap_pars_fragment: Uf,
        alphatest_fragment: Of,
        alphatest_pars_fragment: Hf,
        aomap_fragment: kf,
        aomap_pars_fragment: Vf,
        begin_vertex: Gf,
        beginnormal_vertex: Wf,
        bsdfs: qf,
        bumpmap_pars_fragment: Xf,
        clipping_planes_fragment: Jf,
        clipping_planes_pars_fragment: Yf,
        clipping_planes_pars_vertex: Zf,
        clipping_planes_vertex: $f,
        color_fragment: jf,
        color_pars_fragment: Qf,
        color_pars_vertex: Kf,
        color_vertex: ep,
        common: tp,
        cube_uv_reflection_fragment: np,
        defaultnormal_vertex: ip,
        displacementmap_pars_vertex: sp,
        displacementmap_vertex: rp,
        emissivemap_fragment: op,
        emissivemap_pars_fragment: ap,
        encodings_fragment: lp,
        encodings_pars_fragment: cp,
        envmap_fragment: hp,
        envmap_common_pars_fragment: up,
        envmap_pars_fragment: dp,
        envmap_pars_vertex: fp,
        envmap_physical_pars_fragment: Sp,
        envmap_vertex: pp,
        fog_vertex: mp,
        fog_pars_vertex: gp,
        fog_fragment: xp,
        fog_pars_fragment: yp,
        gradientmap_pars_fragment: vp,
        lightmap_fragment: _p,
        lightmap_pars_fragment: Mp,
        lights_lambert_vertex: wp,
        lights_pars_begin: bp,
        lights_toon_fragment: Tp,
        lights_toon_pars_fragment: Ep,
        lights_phong_fragment: Ap,
        lights_phong_pars_fragment: Rp,
        lights_physical_fragment: Cp,
        lights_physical_pars_fragment: Lp,
        lights_fragment_begin: Pp,
        lights_fragment_maps: Ip,
        lights_fragment_end: Dp,
        logdepthbuf_fragment: Fp,
        logdepthbuf_pars_fragment: Np,
        logdepthbuf_pars_vertex: zp,
        logdepthbuf_vertex: Bp,
        map_fragment: Up,
        map_pars_fragment: Op,
        map_particle_fragment: Hp,
        map_particle_pars_fragment: kp,
        metalnessmap_fragment: Vp,
        metalnessmap_pars_fragment: Gp,
        morphnormal_vertex: Wp,
        morphtarget_pars_vertex: qp,
        morphtarget_vertex: Xp,
        normal_fragment_begin: Jp,
        normal_fragment_maps: Yp,
        normal_pars_fragment: Zp,
        normal_pars_vertex: $p,
        normal_vertex: jp,
        normalmap_pars_fragment: Qp,
        clearcoat_normal_fragment_begin: Kp,
        clearcoat_normal_fragment_maps: em,
        clearcoat_pars_fragment: tm,
        output_fragment: nm,
        packing: im,
        premultiplied_alpha_fragment: sm,
        project_vertex: rm,
        dithering_fragment: om,
        dithering_pars_fragment: am,
        roughnessmap_fragment: lm,
        roughnessmap_pars_fragment: cm,
        shadowmap_pars_fragment: hm,
        shadowmap_pars_vertex: um,
        shadowmap_vertex: dm,
        shadowmask_pars_fragment: fm,
        skinbase_vertex: pm,
        skinning_pars_vertex: mm,
        skinning_vertex: gm,
        skinnormal_vertex: xm,
        specularmap_fragment: ym,
        specularmap_pars_fragment: vm,
        tonemapping_fragment: _m,
        tonemapping_pars_fragment: Mm,
        transmission_fragment: wm,
        transmission_pars_fragment: bm,
        uv_pars_fragment: Sm,
        uv_pars_vertex: Tm,
        uv_vertex: Em,
        uv2_pars_fragment: Am,
        uv2_pars_vertex: Rm,
        uv2_vertex: Cm,
        worldpos_vertex: Lm,
        background_vert: Pm,
        background_frag: Im,
        cube_vert: Dm,
        cube_frag: Fm,
        depth_vert: Nm,
        depth_frag: zm,
        distanceRGBA_vert: Bm,
        distanceRGBA_frag: Um,
        equirect_vert: Om,
        equirect_frag: Hm,
        linedashed_vert: km,
        linedashed_frag: Vm,
        meshbasic_vert: Gm,
        meshbasic_frag: Wm,
        meshlambert_vert: qm,
        meshlambert_frag: Xm,
        meshmatcap_vert: Jm,
        meshmatcap_frag: Ym,
        meshnormal_vert: Zm,
        meshnormal_frag: $m,
        meshphong_vert: jm,
        meshphong_frag: Qm,
        meshphysical_vert: Km,
        meshphysical_frag: eg,
        meshtoon_vert: tg,
        meshtoon_frag: ng,
        points_vert: ig,
        points_frag: sg,
        shadow_vert: rg,
        shadow_frag: og,
        sprite_vert: ag,
        sprite_frag: lg,
    },
    ie = {
        common: {
            diffuse: { value: new re(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new rt() },
            uv2Transform: { value: new rt() },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
            normalMap: { value: null },
            normalScale: { value: new W(1, 1) },
        },
        displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new re(16777215) },
        },
        lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
                value: [],
                properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                },
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                },
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {},
                },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
        },
        points: {
            diffuse: { value: new re(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new rt() },
        },
        sprite: {
            diffuse: { value: new re(16777215) },
            opacity: { value: 1 },
            center: { value: new W(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            alphaTest: { value: 0 },
            uvTransform: { value: new rt() },
        },
    },
    Jt = {
        basic: {
            uniforms: xt([
                ie.common,
                ie.specularmap,
                ie.envmap,
                ie.aomap,
                ie.lightmap,
                ie.fog,
            ]),
            vertexShader: Fe.meshbasic_vert,
            fragmentShader: Fe.meshbasic_frag,
        },
        lambert: {
            uniforms: xt([
                ie.common,
                ie.specularmap,
                ie.envmap,
                ie.aomap,
                ie.lightmap,
                ie.emissivemap,
                ie.fog,
                ie.lights,
                { emissive: { value: new re(0) } },
            ]),
            vertexShader: Fe.meshlambert_vert,
            fragmentShader: Fe.meshlambert_frag,
        },
        phong: {
            uniforms: xt([
                ie.common,
                ie.specularmap,
                ie.envmap,
                ie.aomap,
                ie.lightmap,
                ie.emissivemap,
                ie.bumpmap,
                ie.normalmap,
                ie.displacementmap,
                ie.fog,
                ie.lights,
                {
                    emissive: { value: new re(0) },
                    specular: { value: new re(1118481) },
                    shininess: { value: 30 },
                },
            ]),
            vertexShader: Fe.meshphong_vert,
            fragmentShader: Fe.meshphong_frag,
        },
        standard: {
            uniforms: xt([
                ie.common,
                ie.envmap,
                ie.aomap,
                ie.lightmap,
                ie.emissivemap,
                ie.bumpmap,
                ie.normalmap,
                ie.displacementmap,
                ie.roughnessmap,
                ie.metalnessmap,
                ie.fog,
                ie.lights,
                {
                    emissive: { value: new re(0) },
                    roughness: { value: 1 },
                    metalness: { value: 0 },
                    envMapIntensity: { value: 1 },
                },
            ]),
            vertexShader: Fe.meshphysical_vert,
            fragmentShader: Fe.meshphysical_frag,
        },
        toon: {
            uniforms: xt([
                ie.common,
                ie.aomap,
                ie.lightmap,
                ie.emissivemap,
                ie.bumpmap,
                ie.normalmap,
                ie.displacementmap,
                ie.gradientmap,
                ie.fog,
                ie.lights,
                { emissive: { value: new re(0) } },
            ]),
            vertexShader: Fe.meshtoon_vert,
            fragmentShader: Fe.meshtoon_frag,
        },
        matcap: {
            uniforms: xt([
                ie.common,
                ie.bumpmap,
                ie.normalmap,
                ie.displacementmap,
                ie.fog,
                { matcap: { value: null } },
            ]),
            vertexShader: Fe.meshmatcap_vert,
            fragmentShader: Fe.meshmatcap_frag,
        },
        points: {
            uniforms: xt([ie.points, ie.fog]),
            vertexShader: Fe.points_vert,
            fragmentShader: Fe.points_frag,
        },
        dashed: {
            uniforms: xt([
                ie.common,
                ie.fog,
                {
                    scale: { value: 1 },
                    dashSize: { value: 1 },
                    totalSize: { value: 2 },
                },
            ]),
            vertexShader: Fe.linedashed_vert,
            fragmentShader: Fe.linedashed_frag,
        },
        depth: {
            uniforms: xt([ie.common, ie.displacementmap]),
            vertexShader: Fe.depth_vert,
            fragmentShader: Fe.depth_frag,
        },
        normal: {
            uniforms: xt([
                ie.common,
                ie.bumpmap,
                ie.normalmap,
                ie.displacementmap,
                { opacity: { value: 1 } },
            ]),
            vertexShader: Fe.meshnormal_vert,
            fragmentShader: Fe.meshnormal_frag,
        },
        sprite: {
            uniforms: xt([ie.sprite, ie.fog]),
            vertexShader: Fe.sprite_vert,
            fragmentShader: Fe.sprite_frag,
        },
        background: {
            uniforms: {
                uvTransform: { value: new rt() },
                t2D: { value: null },
            },
            vertexShader: Fe.background_vert,
            fragmentShader: Fe.background_frag,
        },
        cube: {
            uniforms: xt([ie.envmap, { opacity: { value: 1 } }]),
            vertexShader: Fe.cube_vert,
            fragmentShader: Fe.cube_frag,
        },
        equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Fe.equirect_vert,
            fragmentShader: Fe.equirect_frag,
        },
        distanceRGBA: {
            uniforms: xt([
                ie.common,
                ie.displacementmap,
                {
                    referencePosition: { value: new M() },
                    nearDistance: { value: 1 },
                    farDistance: { value: 1e3 },
                },
            ]),
            vertexShader: Fe.distanceRGBA_vert,
            fragmentShader: Fe.distanceRGBA_frag,
        },
        shadow: {
            uniforms: xt([
                ie.lights,
                ie.fog,
                { color: { value: new re(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Fe.shadow_vert,
            fragmentShader: Fe.shadow_frag,
        },
    };
Jt.physical = {
    uniforms: xt([
        Jt.standard.uniforms,
        {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatNormalScale: { value: new W(1, 1) },
            clearcoatNormalMap: { value: null },
            sheen: { value: 0 },
            sheenColor: { value: new re(0) },
            sheenColorMap: { value: null },
            sheenRoughness: { value: 0 },
            sheenRoughnessMap: { value: null },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionSamplerSize: { value: new W() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new re(0) },
            specularIntensity: { value: 0 },
            specularIntensityMap: { value: null },
            specularColor: { value: new re(1, 1, 1) },
            specularColorMap: { value: null },
        },
    ]),
    vertexShader: Fe.meshphysical_vert,
    fragmentShader: Fe.meshphysical_frag,
};
function cg(r, e, t, n, i) {
    let s = new re(0),
        o = 0,
        a,
        l,
        c = null,
        h = 0,
        u = null;
    function d(m, x) {
        let v = !1,
            g = x.isScene === !0 ? x.background : null;
        g && g.isTexture && (g = e.get(g));
        let p = r.xr,
            _ = p.getSession && p.getSession();
        _ && _.environmentBlendMode === "additive" && (g = null),
            g === null ? f(s, o) : g && g.isColor && (f(g, 1), (v = !0)),
            (r.autoClear || v) &&
                r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
            g && (g.isCubeTexture || g.mapping === js)
                ? (l === void 0 &&
                      ((l = new nt(
                          new $n(1, 1, 1),
                          new Zt({
                              name: "BackgroundCubeMaterial",
                              uniforms: Di(Jt.cube.uniforms),
                              vertexShader: Jt.cube.vertexShader,
                              fragmentShader: Jt.cube.fragmentShader,
                              side: it,
                              depthTest: !1,
                              depthWrite: !1,
                              fog: !1,
                          })
                      )),
                      l.geometry.deleteAttribute("normal"),
                      l.geometry.deleteAttribute("uv"),
                      (l.onBeforeRender = function (y, w, A) {
                          this.matrixWorld.copyPosition(A.matrixWorld);
                      }),
                      Object.defineProperty(l.material, "envMap", {
                          get: function () {
                              return this.uniforms.envMap.value;
                          },
                      }),
                      n.update(l)),
                  (l.material.uniforms.envMap.value = g),
                  (l.material.uniforms.flipEnvMap.value =
                      g.isCubeTexture && g.isRenderTargetTexture === !1
                          ? -1
                          : 1),
                  (c !== g || h !== g.version || u !== r.toneMapping) &&
                      ((l.material.needsUpdate = !0),
                      (c = g),
                      (h = g.version),
                      (u = r.toneMapping)),
                  m.unshift(l, l.geometry, l.material, 0, 0, null))
                : g &&
                  g.isTexture &&
                  (a === void 0 &&
                      ((a = new nt(
                          new Rs(2, 2),
                          new Zt({
                              name: "BackgroundMaterial",
                              uniforms: Di(Jt.background.uniforms),
                              vertexShader: Jt.background.vertexShader,
                              fragmentShader: Jt.background.fragmentShader,
                              side: Ci,
                              depthTest: !1,
                              depthWrite: !1,
                              fog: !1,
                          })
                      )),
                      a.geometry.deleteAttribute("normal"),
                      Object.defineProperty(a.material, "map", {
                          get: function () {
                              return this.uniforms.t2D.value;
                          },
                      }),
                      n.update(a)),
                  (a.material.uniforms.t2D.value = g),
                  g.matrixAutoUpdate === !0 && g.updateMatrix(),
                  a.material.uniforms.uvTransform.value.copy(g.matrix),
                  (c !== g || h !== g.version || u !== r.toneMapping) &&
                      ((a.material.needsUpdate = !0),
                      (c = g),
                      (h = g.version),
                      (u = r.toneMapping)),
                  m.unshift(a, a.geometry, a.material, 0, 0, null));
    }
    function f(m, x) {
        t.buffers.color.setClear(m.r, m.g, m.b, x, i);
    }
    return {
        getClearColor: function () {
            return s;
        },
        setClearColor: function (m, x = 1) {
            s.set(m), (o = x), f(s, o);
        },
        getClearAlpha: function () {
            return o;
        },
        setClearAlpha: function (m) {
            (o = m), f(s, o);
        },
        render: d,
    };
}
function hg(r, e, t, n) {
    let i = r.getParameter(34921),
        s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = n.isWebGL2 || s !== null,
        a = {},
        l = x(null),
        c = l;
    function h(E, D, U, F, O) {
        let ne = !1;
        if (o) {
            let ce = m(F, U, D);
            c !== ce && ((c = ce), d(c.object)), (ne = v(F, O)), ne && g(F, O);
        } else {
            let ce = D.wireframe === !0;
            (c.geometry !== F.id || c.program !== U.id || c.wireframe !== ce) &&
                ((c.geometry = F.id),
                (c.program = U.id),
                (c.wireframe = ce),
                (ne = !0));
        }
        E.isInstancedMesh === !0 && (ne = !0),
            O !== null && t.update(O, 34963),
            ne &&
                (C(E, D, U, F),
                O !== null && r.bindBuffer(34963, t.get(O).buffer));
    }
    function u() {
        return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES();
    }
    function d(E) {
        return n.isWebGL2 ? r.bindVertexArray(E) : s.bindVertexArrayOES(E);
    }
    function f(E) {
        return n.isWebGL2 ? r.deleteVertexArray(E) : s.deleteVertexArrayOES(E);
    }
    function m(E, D, U) {
        let F = U.wireframe === !0,
            O = a[E.id];
        O === void 0 && ((O = {}), (a[E.id] = O));
        let ne = O[D.id];
        ne === void 0 && ((ne = {}), (O[D.id] = ne));
        let ce = ne[F];
        return ce === void 0 && ((ce = x(u())), (ne[F] = ce)), ce;
    }
    function x(E) {
        let D = [],
            U = [],
            F = [];
        for (let O = 0; O < i; O++) (D[O] = 0), (U[O] = 0), (F[O] = 0);
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: D,
            enabledAttributes: U,
            attributeDivisors: F,
            object: E,
            attributes: {},
            index: null,
        };
    }
    function v(E, D) {
        let U = c.attributes,
            F = E.attributes,
            O = 0;
        for (let ne in F) {
            let ce = U[ne],
                G = F[ne];
            if (ce === void 0 || ce.attribute !== G || ce.data !== G.data)
                return !0;
            O++;
        }
        return c.attributesNum !== O || c.index !== D;
    }
    function g(E, D) {
        let U = {},
            F = E.attributes,
            O = 0;
        for (let ne in F) {
            let ce = F[ne],
                G = {};
            (G.attribute = ce), ce.data && (G.data = ce.data), (U[ne] = G), O++;
        }
        (c.attributes = U), (c.attributesNum = O), (c.index = D);
    }
    function p() {
        let E = c.newAttributes;
        for (let D = 0, U = E.length; D < U; D++) E[D] = 0;
    }
    function _(E) {
        y(E, 0);
    }
    function y(E, D) {
        let U = c.newAttributes,
            F = c.enabledAttributes,
            O = c.attributeDivisors;
        (U[E] = 1),
            F[E] === 0 && (r.enableVertexAttribArray(E), (F[E] = 1)),
            O[E] !== D &&
                ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[
                    n.isWebGL2
                        ? "vertexAttribDivisor"
                        : "vertexAttribDivisorANGLE"
                ](E, D),
                (O[E] = D));
    }
    function w() {
        let E = c.newAttributes,
            D = c.enabledAttributes;
        for (let U = 0, F = D.length; U < F; U++)
            D[U] !== E[U] && (r.disableVertexAttribArray(U), (D[U] = 0));
    }
    function A(E, D, U, F, O, ne) {
        n.isWebGL2 === !0 && (U === 5124 || U === 5125)
            ? r.vertexAttribIPointer(E, D, U, O, ne)
            : r.vertexAttribPointer(E, D, U, F, O, ne);
    }
    function C(E, D, U, F) {
        if (
            n.isWebGL2 === !1 &&
            (E.isInstancedMesh || F.isInstancedBufferGeometry) &&
            e.get("ANGLE_instanced_arrays") === null
        )
            return;
        p();
        let O = F.attributes,
            ne = U.getAttributes(),
            ce = D.defaultAttributeValues;
        for (let G in ne) {
            let q = ne[G];
            if (q.location >= 0) {
                let he = O[G];
                if (
                    (he === void 0 &&
                        (G === "instanceMatrix" &&
                            E.instanceMatrix &&
                            (he = E.instanceMatrix),
                        G === "instanceColor" &&
                            E.instanceColor &&
                            (he = E.instanceColor)),
                    he !== void 0)
                ) {
                    let le = he.normalized,
                        fe = he.itemSize,
                        Ne = t.get(he);
                    if (Ne === void 0) continue;
                    let Y = Ne.buffer,
                        Re = Ne.type,
                        ye = Ne.bytesPerElement;
                    if (he.isInterleavedBufferAttribute) {
                        let ge = he.data,
                            xe = ge.stride,
                            Oe = he.offset;
                        if (ge && ge.isInstancedInterleavedBuffer) {
                            for (let V = 0; V < q.locationSize; V++)
                                y(q.location + V, ge.meshPerAttribute);
                            E.isInstancedMesh !== !0 &&
                                F._maxInstanceCount === void 0 &&
                                (F._maxInstanceCount =
                                    ge.meshPerAttribute * ge.count);
                        } else
                            for (let V = 0; V < q.locationSize; V++)
                                _(q.location + V);
                        r.bindBuffer(34962, Y);
                        for (let V = 0; V < q.locationSize; V++)
                            A(
                                q.location + V,
                                fe / q.locationSize,
                                Re,
                                le,
                                xe * ye,
                                (Oe + (fe / q.locationSize) * V) * ye
                            );
                    } else {
                        if (he.isInstancedBufferAttribute) {
                            for (let ge = 0; ge < q.locationSize; ge++)
                                y(q.location + ge, he.meshPerAttribute);
                            E.isInstancedMesh !== !0 &&
                                F._maxInstanceCount === void 0 &&
                                (F._maxInstanceCount =
                                    he.meshPerAttribute * he.count);
                        } else
                            for (let ge = 0; ge < q.locationSize; ge++)
                                _(q.location + ge);
                        r.bindBuffer(34962, Y);
                        for (let ge = 0; ge < q.locationSize; ge++)
                            A(
                                q.location + ge,
                                fe / q.locationSize,
                                Re,
                                le,
                                fe * ye,
                                (fe / q.locationSize) * ge * ye
                            );
                    }
                } else if (ce !== void 0) {
                    let le = ce[G];
                    if (le !== void 0)
                        switch (le.length) {
                            case 2:
                                r.vertexAttrib2fv(q.location, le);
                                break;
                            case 3:
                                r.vertexAttrib3fv(q.location, le);
                                break;
                            case 4:
                                r.vertexAttrib4fv(q.location, le);
                                break;
                            default:
                                r.vertexAttrib1fv(q.location, le);
                        }
                }
            }
        }
        w();
    }
    function I() {
        P();
        for (let E in a) {
            let D = a[E];
            for (let U in D) {
                let F = D[U];
                for (let O in F) f(F[O].object), delete F[O];
                delete D[U];
            }
            delete a[E];
        }
    }
    function k(E) {
        if (a[E.id] === void 0) return;
        let D = a[E.id];
        for (let U in D) {
            let F = D[U];
            for (let O in F) f(F[O].object), delete F[O];
            delete D[U];
        }
        delete a[E.id];
    }
    function z(E) {
        for (let D in a) {
            let U = a[D];
            if (U[E.id] === void 0) continue;
            let F = U[E.id];
            for (let O in F) f(F[O].object), delete F[O];
            delete U[E.id];
        }
    }
    function P() {
        b(), c !== l && ((c = l), d(c.object));
    }
    function b() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
    }
    return {
        setup: h,
        reset: P,
        resetDefaultState: b,
        dispose: I,
        releaseStatesOfGeometry: k,
        releaseStatesOfProgram: z,
        initAttributes: p,
        enableAttribute: _,
        disableUnusedAttributes: w,
    };
}
function ug(r, e, t, n) {
    let i = n.isWebGL2,
        s;
    function o(c) {
        s = c;
    }
    function a(c, h) {
        r.drawArrays(s, c, h), t.update(h, s, 1);
    }
    function l(c, h, u) {
        if (u === 0) return;
        let d, f;
        if (i) (d = r), (f = "drawArraysInstanced");
        else if (
            ((d = e.get("ANGLE_instanced_arrays")),
            (f = "drawArraysInstancedANGLE"),
            d === null)
        ) {
            console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
        }
        d[f](s, c, h, u), t.update(h, s, u);
    }
    (this.setMode = o), (this.render = a), (this.renderInstances = l);
}
function dg(r, e, t) {
    let n;
    function i() {
        if (n !== void 0) return n;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            let C = e.get("EXT_texture_filter_anisotropic");
            n = r.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else n = 0;
        return n;
    }
    function s(C) {
        if (C === "highp") {
            if (
                r.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                r.getShaderPrecisionFormat(35632, 36338).precision > 0
            )
                return "highp";
            C = "mediump";
        }
        return C === "mediump" &&
            r.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
            r.getShaderPrecisionFormat(35632, 36337).precision > 0
            ? "mediump"
            : "lowp";
    }
    let o =
            (typeof WebGL2RenderingContext < "u" &&
                r instanceof WebGL2RenderingContext) ||
            (typeof WebGL2ComputeRenderingContext < "u" &&
                r instanceof WebGL2ComputeRenderingContext),
        a = t.precision !== void 0 ? t.precision : "highp",
        l = s(a);
    l !== a &&
        (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
        ),
        (a = l));
    let c = o || e.has("WEBGL_draw_buffers"),
        h = t.logarithmicDepthBuffer === !0,
        u = r.getParameter(34930),
        d = r.getParameter(35660),
        f = r.getParameter(3379),
        m = r.getParameter(34076),
        x = r.getParameter(34921),
        v = r.getParameter(36347),
        g = r.getParameter(36348),
        p = r.getParameter(36349),
        _ = d > 0,
        y = o || e.has("OES_texture_float"),
        w = _ && y,
        A = o ? r.getParameter(36183) : 0;
    return {
        isWebGL2: o,
        drawBuffers: c,
        getMaxAnisotropy: i,
        getMaxPrecision: s,
        precision: a,
        logarithmicDepthBuffer: h,
        maxTextures: u,
        maxVertexTextures: d,
        maxTextureSize: f,
        maxCubemapSize: m,
        maxAttributes: x,
        maxVertexUniforms: v,
        maxVaryings: g,
        maxFragmentUniforms: p,
        vertexTextures: _,
        floatFragmentTextures: y,
        floatVertexTextures: w,
        maxSamples: A,
    };
}
function fg(r) {
    let e = this,
        t = null,
        n = 0,
        i = !1,
        s = !1,
        o = new Bt(),
        a = new rt(),
        l = { value: null, needsUpdate: !1 };
    (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (u, d, f) {
            let m = u.length !== 0 || d || n !== 0 || i;
            return (i = d), (t = h(u, f, 0)), (n = u.length), m;
        }),
        (this.beginShadows = function () {
            (s = !0), h(null);
        }),
        (this.endShadows = function () {
            (s = !1), c();
        }),
        (this.setState = function (u, d, f) {
            let m = u.clippingPlanes,
                x = u.clipIntersection,
                v = u.clipShadows,
                g = r.get(u);
            if (!i || m === null || m.length === 0 || (s && !v))
                s ? h(null) : c();
            else {
                let p = s ? 0 : n,
                    _ = p * 4,
                    y = g.clippingState || null;
                (l.value = y), (y = h(m, d, _, f));
                for (let w = 0; w !== _; ++w) y[w] = t[w];
                (g.clippingState = y),
                    (this.numIntersection = x ? this.numPlanes : 0),
                    (this.numPlanes += p);
            }
        });
    function c() {
        l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
            (e.numPlanes = n),
            (e.numIntersection = 0);
    }
    function h(u, d, f, m) {
        let x = u !== null ? u.length : 0,
            v = null;
        if (x !== 0) {
            if (((v = l.value), m !== !0 || v === null)) {
                let g = f + x * 4,
                    p = d.matrixWorldInverse;
                a.getNormalMatrix(p),
                    (v === null || v.length < g) && (v = new Float32Array(g));
                for (let _ = 0, y = f; _ !== x; ++_, y += 4)
                    o.copy(u[_]).applyMatrix4(p, a),
                        o.normal.toArray(v, y),
                        (v[y + 3] = o.constant);
            }
            (l.value = v), (l.needsUpdate = !0);
        }
        return (e.numPlanes = x), (e.numIntersection = 0), v;
    }
}
function pg(r) {
    let e = new WeakMap();
    function t(o, a) {
        return a === Gr ? (o.mapping = Yi) : a === Wr && (o.mapping = Zi), o;
    }
    function n(o) {
        if (o && o.isTexture && o.isRenderTargetTexture === !1) {
            let a = o.mapping;
            if (a === Gr || a === Wr)
                if (e.has(o)) {
                    let l = e.get(o).texture;
                    return t(l, o.mapping);
                } else {
                    let l = o.image;
                    if (l && l.height > 0) {
                        let c = r.getRenderTarget(),
                            h = new As(l.height / 2);
                        return (
                            h.fromEquirectangularTexture(r, o),
                            e.set(o, h),
                            r.setRenderTarget(c),
                            o.addEventListener("dispose", i),
                            t(h.texture, o.mapping)
                        );
                    } else return null;
                }
        }
        return o;
    }
    function i(o) {
        let a = o.target;
        a.removeEventListener("dispose", i);
        let l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose());
    }
    function s() {
        e = new WeakMap();
    }
    return { get: n, dispose: s };
}
var zi = class extends Fi {
    constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, o = 2e3) {
        super(),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = s),
            (this.far = o),
            this.updateProjectionMatrix();
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = e.view === null ? null : Object.assign({}, e.view)),
            this
        );
    }
    setViewOffset(e, t, n, i, s, o) {
        this.view === null &&
            (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
            this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        let e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2,
            s = n - e,
            o = n + e,
            a = i + t,
            l = i - t;
        if (this.view !== null && this.view.enabled) {
            let c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += c * this.view.offsetX),
                (o = s + c * this.view.width),
                (a -= h * this.view.offsetY),
                (l = a - h * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            this.view !== null &&
                (t.object.view = Object.assign({}, this.view)),
            t
        );
    }
};
zi.prototype.isOrthographicCamera = !0;
var Qn = class extends Zt {
    constructor(e) {
        super(e), (this.type = "RawShaderMaterial");
    }
};
Qn.prototype.isRawShaderMaterial = !0;
var Ri = 4,
    bn = 8,
    Xt = Math.pow(2, bn),
    lu = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    cu = bn - Ri + 1 + lu.length,
    gi = 20,
    $r = { [Ot]: 0, [ji]: 1 },
    va = new zi(),
    { _lodPlanes: rs, _sizeLods: _c, _sigmas: vr } = mg(),
    Mc = new re(),
    _a = null,
    qn = (1 + Math.sqrt(5)) / 2,
    xi = 1 / qn,
    wc = [
        new M(1, 1, 1),
        new M(-1, 1, 1),
        new M(1, 1, -1),
        new M(-1, 1, -1),
        new M(0, qn, xi),
        new M(0, qn, -xi),
        new M(xi, 0, qn),
        new M(-xi, 0, qn),
        new M(qn, xi, 0),
        new M(-qn, xi, 0),
    ],
    Ga = class {
        constructor(e) {
            (this._renderer = e),
                (this._pingPongRenderTarget = null),
                (this._blurMaterial = gg(gi)),
                (this._equirectShader = null),
                (this._cubemapShader = null),
                this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
            _a = this._renderer.getRenderTarget();
            let s = this._allocateTargets();
            return (
                this._sceneToCubeUV(e, n, i, s),
                t > 0 && this._blur(s, 0, 0, t),
                this._applyPMREM(s),
                this._cleanup(s),
                s
            );
        }
        fromEquirectangular(e) {
            return this._fromTexture(e);
        }
        fromCubemap(e) {
            return this._fromTexture(e);
        }
        compileCubemapShader() {
            this._cubemapShader === null &&
                ((this._cubemapShader = Tc()),
                this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
            this._equirectShader === null &&
                ((this._equirectShader = Sc()),
                this._compileMaterial(this._equirectShader));
        }
        dispose() {
            this._blurMaterial.dispose(),
                this._cubemapShader !== null && this._cubemapShader.dispose(),
                this._equirectShader !== null && this._equirectShader.dispose();
            for (let e = 0; e < rs.length; e++) rs[e].dispose();
        }
        _cleanup(e) {
            this._pingPongRenderTarget.dispose(),
                this._renderer.setRenderTarget(_a),
                (e.scissorTest = !1),
                _r(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e) {
            _a = this._renderer.getRenderTarget();
            let t = this._allocateTargets(e);
            return (
                this._textureToCubeUV(e, t),
                this._applyPMREM(t),
                this._cleanup(t),
                t
            );
        }
        _allocateTargets(e) {
            let t = {
                    magFilter: tt,
                    minFilter: tt,
                    generateMipmaps: !1,
                    type: Xn,
                    format: lt,
                    encoding: Ot,
                    depthBuffer: !1,
                },
                n = bc(t);
            return (
                (n.depthBuffer = !e), (this._pingPongRenderTarget = bc(t)), n
            );
        }
        _compileMaterial(e) {
            let t = new nt(rs[0], e);
            this._renderer.compile(t, va);
        }
        _sceneToCubeUV(e, t, n, i) {
            let a = new at(90, 1, t, n),
                l = [1, -1, 1, 1, 1, 1],
                c = [1, 1, 1, -1, -1, -1],
                h = this._renderer,
                u = h.autoClear,
                d = h.toneMapping;
            h.getClearColor(Mc), (h.toneMapping = wn), (h.autoClear = !1);
            let f = new Yt({
                    name: "PMREM.Background",
                    side: it,
                    depthWrite: !1,
                    depthTest: !1,
                }),
                m = new nt(new $n(), f),
                x = !1,
                v = e.background;
            v
                ? v.isColor &&
                  (f.color.copy(v), (e.background = null), (x = !0))
                : (f.color.copy(Mc), (x = !0));
            for (let g = 0; g < 6; g++) {
                let p = g % 3;
                p == 0
                    ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0))
                    : p == 1
                    ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0))
                    : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g])),
                    _r(i, p * Xt, g > 2 ? Xt : 0, Xt, Xt),
                    h.setRenderTarget(i),
                    x && h.render(m, a),
                    h.render(e, a);
            }
            m.geometry.dispose(),
                m.material.dispose(),
                (h.toneMapping = d),
                (h.autoClear = u),
                (e.background = v);
        }
        _setEncoding(e, t) {
            this._renderer.capabilities.isWebGL2 === !0 &&
            t.format === lt &&
            t.type === an &&
            t.encoding === ji
                ? (e.value = $r[Ot])
                : (e.value = $r[t.encoding]);
        }
        _textureToCubeUV(e, t) {
            let n = this._renderer,
                i = e.mapping === Yi || e.mapping === Zi;
            i
                ? this._cubemapShader == null && (this._cubemapShader = Tc())
                : this._equirectShader == null && (this._equirectShader = Sc());
            let s = i ? this._cubemapShader : this._equirectShader,
                o = new nt(rs[0], s),
                a = s.uniforms;
            (a.envMap.value = e),
                i ||
                    a.texelSize.value.set(
                        1 / e.image.width,
                        1 / e.image.height
                    ),
                this._setEncoding(a.inputEncoding, e),
                _r(t, 0, 0, 3 * Xt, 2 * Xt),
                n.setRenderTarget(t),
                n.render(o, va);
        }
        _applyPMREM(e) {
            let t = this._renderer,
                n = t.autoClear;
            t.autoClear = !1;
            for (let i = 1; i < cu; i++) {
                let s = Math.sqrt(vr[i] * vr[i] - vr[i - 1] * vr[i - 1]),
                    o = wc[(i - 1) % wc.length];
                this._blur(e, i - 1, i, s, o);
            }
            t.autoClear = n;
        }
        _blur(e, t, n, i, s) {
            let o = this._pingPongRenderTarget;
            this._halfBlur(e, o, t, n, i, "latitudinal", s),
                this._halfBlur(o, e, n, n, i, "longitudinal", s);
        }
        _halfBlur(e, t, n, i, s, o, a) {
            let l = this._renderer,
                c = this._blurMaterial;
            o !== "latitudinal" &&
                o !== "longitudinal" &&
                console.error(
                    "blur direction must be either latitudinal or longitudinal!"
                );
            let h = 3,
                u = new nt(rs[i], c),
                d = c.uniforms,
                f = _c[n] - 1,
                m = isFinite(s)
                    ? Math.PI / (2 * f)
                    : (2 * Math.PI) / (2 * gi - 1),
                x = s / m,
                v = isFinite(s) ? 1 + Math.floor(h * x) : gi;
            v > gi &&
                console.warn(
                    `sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${gi}`
                );
            let g = [],
                p = 0;
            for (let A = 0; A < gi; ++A) {
                let C = A / x,
                    I = Math.exp((-C * C) / 2);
                g.push(I), A == 0 ? (p += I) : A < v && (p += 2 * I);
            }
            for (let A = 0; A < g.length; A++) g[A] = g[A] / p;
            (d.envMap.value = e.texture),
                (d.samples.value = v),
                (d.weights.value = g),
                (d.latitudinal.value = o === "latitudinal"),
                a && (d.poleAxis.value = a),
                (d.dTheta.value = m),
                (d.mipInt.value = bn - n);
            let _ = _c[i],
                y = 3 * Math.max(0, Xt - 2 * _),
                w =
                    (i === 0 ? 0 : 2 * Xt) +
                    2 * _ * (i > bn - Ri ? i - bn + Ri : 0);
            _r(t, y, w, 3 * _, 2 * _), l.setRenderTarget(t), l.render(u, va);
        }
    };
function mg() {
    let r = [],
        e = [],
        t = [],
        n = bn;
    for (let i = 0; i < cu; i++) {
        let s = Math.pow(2, n);
        e.push(s);
        let o = 1 / s;
        i > bn - Ri ? (o = lu[i - bn + Ri - 1]) : i == 0 && (o = 0), t.push(o);
        let a = 1 / (s - 1),
            l = -a / 2,
            c = 1 + a / 2,
            h = [l, l, c, l, c, c, l, l, c, c, l, c],
            u = 6,
            d = 6,
            f = 3,
            m = 2,
            x = 1,
            v = new Float32Array(f * d * u),
            g = new Float32Array(m * d * u),
            p = new Float32Array(x * d * u);
        for (let y = 0; y < u; y++) {
            let w = ((y % 3) * 2) / 3 - 1,
                A = y > 2 ? 0 : -1,
                C = [
                    w,
                    A,
                    0,
                    w + 2 / 3,
                    A,
                    0,
                    w + 2 / 3,
                    A + 1,
                    0,
                    w,
                    A,
                    0,
                    w + 2 / 3,
                    A + 1,
                    0,
                    w,
                    A + 1,
                    0,
                ];
            v.set(C, f * d * y), g.set(h, m * d * y);
            let I = [y, y, y, y, y, y];
            p.set(I, x * d * y);
        }
        let _ = new _e();
        _.setAttribute("position", new ze(v, f)),
            _.setAttribute("uv", new ze(g, m)),
            _.setAttribute("faceIndex", new ze(p, x)),
            r.push(_),
            n > Ri && n--;
    }
    return { _lodPlanes: r, _sizeLods: e, _sigmas: t };
}
function bc(r) {
    let e = new St(3 * Xt, 3 * Xt, r);
    return (
        (e.texture.mapping = js),
        (e.texture.name = "PMREM.cubeUv"),
        (e.scissorTest = !0),
        e
    );
}
function _r(r, e, t, n, i) {
    r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function gg(r) {
    let e = new Float32Array(r),
        t = new M(0, 1, 0);
    return new Qn({
        name: "SphericalGaussianBlur",
        defines: { n: r },
        uniforms: {
            envMap: { value: null },
            samples: { value: 1 },
            weights: { value: e },
            latitudinal: { value: !1 },
            dTheta: { value: 0 },
            mipInt: { value: 0 },
            poleAxis: { value: t },
        },
        vertexShader: Bl(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ul()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Mn,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Sc() {
    let r = new W(1, 1);
    return new Qn({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: { value: null },
            texelSize: { value: r },
            inputEncoding: { value: $r[Ot] },
        },
        vertexShader: Bl(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ul()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,
        blending: Mn,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Tc() {
    return new Qn({
        name: "CubemapToCubeUV",
        uniforms: { envMap: { value: null }, inputEncoding: { value: $r[Ot] } },
        vertexShader: Bl(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ul()}

			void main() {

				gl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );

			}
		`,
        blending: Mn,
        depthTest: !1,
        depthWrite: !1,
    });
}
function Bl() {
    return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Ul() {
    return `

		uniform int inputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else {

				return sRGBToLinear( value );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
function xg(r) {
    let e = new WeakMap(),
        t = null;
    function n(a) {
        if (a && a.isTexture && a.isRenderTargetTexture === !1) {
            let l = a.mapping,
                c = l === Gr || l === Wr,
                h = l === Yi || l === Zi;
            if (c || h) {
                if (e.has(a)) return e.get(a).texture;
                {
                    let u = a.image;
                    if ((c && u && u.height > 0) || (h && u && i(u))) {
                        let d = r.getRenderTarget();
                        t === null && (t = new Ga(r));
                        let f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                        return (
                            e.set(a, f),
                            r.setRenderTarget(d),
                            a.addEventListener("dispose", s),
                            f.texture
                        );
                    } else return null;
                }
            }
        }
        return a;
    }
    function i(a) {
        let l = 0,
            c = 6;
        for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
        return l === c;
    }
    function s(a) {
        let l = a.target;
        l.removeEventListener("dispose", s);
        let c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose());
    }
    function o() {
        (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
    }
    return { get: n, dispose: o };
}
function yg(r) {
    let e = {};
    function t(n) {
        if (e[n] !== void 0) return e[n];
        let i;
        switch (n) {
            case "WEBGL_depth_texture":
                i =
                    r.getExtension("WEBGL_depth_texture") ||
                    r.getExtension("MOZ_WEBGL_depth_texture") ||
                    r.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i =
                    r.getExtension("EXT_texture_filter_anisotropic") ||
                    r.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i =
                    r.getExtension("WEBGL_compressed_texture_s3tc") ||
                    r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                    r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i =
                    r.getExtension("WEBGL_compressed_texture_pvrtc") ||
                    r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i = r.getExtension(n);
        }
        return (e[n] = i), i;
    }
    return {
        has: function (n) {
            return t(n) !== null;
        },
        init: function (n) {
            n.isWebGL2
                ? t("EXT_color_buffer_float")
                : (t("WEBGL_depth_texture"),
                  t("OES_texture_float"),
                  t("OES_texture_half_float"),
                  t("OES_texture_half_float_linear"),
                  t("OES_standard_derivatives"),
                  t("OES_element_index_uint"),
                  t("OES_vertex_array_object"),
                  t("ANGLE_instanced_arrays")),
                t("OES_texture_float_linear"),
                t("EXT_color_buffer_half_float"),
                t("WEBGL_multisampled_render_to_texture");
        },
        get: function (n) {
            let i = t(n);
            return (
                i === null &&
                    console.warn(
                        "THREE.WebGLRenderer: " +
                            n +
                            " extension not supported."
                    ),
                i
            );
        },
    };
}
function vg(r, e, t, n) {
    let i = {},
        s = new WeakMap();
    function o(u) {
        let d = u.target;
        d.index !== null && e.remove(d.index);
        for (let m in d.attributes) e.remove(d.attributes[m]);
        d.removeEventListener("dispose", o), delete i[d.id];
        let f = s.get(d);
        f && (e.remove(f), s.delete(d)),
            n.releaseStatesOfGeometry(d),
            d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
            t.memory.geometries--;
    }
    function a(u, d) {
        return (
            i[d.id] === !0 ||
                (d.addEventListener("dispose", o),
                (i[d.id] = !0),
                t.memory.geometries++),
            d
        );
    }
    function l(u) {
        let d = u.attributes;
        for (let m in d) e.update(d[m], 34962);
        let f = u.morphAttributes;
        for (let m in f) {
            let x = f[m];
            for (let v = 0, g = x.length; v < g; v++) e.update(x[v], 34962);
        }
    }
    function c(u) {
        let d = [],
            f = u.index,
            m = u.attributes.position,
            x = 0;
        if (f !== null) {
            let p = f.array;
            x = f.version;
            for (let _ = 0, y = p.length; _ < y; _ += 3) {
                let w = p[_ + 0],
                    A = p[_ + 1],
                    C = p[_ + 2];
                d.push(w, A, A, C, C, w);
            }
        } else {
            let p = m.array;
            x = m.version;
            for (let _ = 0, y = p.length / 3 - 1; _ < y; _ += 3) {
                let w = _ + 0,
                    A = _ + 1,
                    C = _ + 2;
                d.push(w, A, A, C, C, w);
            }
        }
        let v = new (ru(d) > 65535 ? Ts : Ss)(d, 1);
        v.version = x;
        let g = s.get(u);
        g && e.remove(g), s.set(u, v);
    }
    function h(u) {
        let d = s.get(u);
        if (d) {
            let f = u.index;
            f !== null && d.version < f.version && c(u);
        } else c(u);
        return s.get(u);
    }
    return { get: a, update: l, getWireframeAttribute: h };
}
function _g(r, e, t, n) {
    let i = n.isWebGL2,
        s;
    function o(d) {
        s = d;
    }
    let a, l;
    function c(d) {
        (a = d.type), (l = d.bytesPerElement);
    }
    function h(d, f) {
        r.drawElements(s, f, a, d * l), t.update(f, s, 1);
    }
    function u(d, f, m) {
        if (m === 0) return;
        let x, v;
        if (i) (x = r), (v = "drawElementsInstanced");
        else if (
            ((x = e.get("ANGLE_instanced_arrays")),
            (v = "drawElementsInstancedANGLE"),
            x === null)
        ) {
            console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
            return;
        }
        x[v](s, f, a, d * l, m), t.update(f, s, m);
    }
    (this.setMode = o),
        (this.setIndex = c),
        (this.render = h),
        (this.renderInstances = u);
}
function Mg(r) {
    let e = { geometries: 0, textures: 0 },
        t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    function n(s, o, a) {
        switch ((t.calls++, o)) {
            case 4:
                t.triangles += a * (s / 3);
                break;
            case 1:
                t.lines += a * (s / 2);
                break;
            case 3:
                t.lines += a * (s - 1);
                break;
            case 2:
                t.lines += a * s;
                break;
            case 0:
                t.points += a * s;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break;
        }
    }
    function i() {
        t.frame++,
            (t.calls = 0),
            (t.triangles = 0),
            (t.points = 0),
            (t.lines = 0);
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n,
    };
}
var Cs = class extends ft {
    constructor(e = null, t = 1, n = 1, i = 1) {
        super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = st),
            (this.minFilter = st),
            (this.wrapR = yt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
};
Cs.prototype.isDataTexture2DArray = !0;
function wg(r, e) {
    return r[0] - e[0];
}
function bg(r, e) {
    return Math.abs(e[1]) - Math.abs(r[1]);
}
function Ec(r, e) {
    let t = 1,
        n = e.isInterleavedBufferAttribute ? e.data.array : e.array;
    n instanceof Int8Array
        ? (t = 127)
        : n instanceof Int16Array
        ? (t = 32767)
        : n instanceof Int32Array
        ? (t = 2147483647)
        : console.error(
              "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
              n
          ),
        r.divideScalar(t);
}
function Sg(r, e, t) {
    let n = {},
        i = new Float32Array(8),
        s = new WeakMap(),
        o = new M(),
        a = [];
    for (let c = 0; c < 8; c++) a[c] = [c, 0];
    function l(c, h, u, d) {
        let f = c.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            let m = h.morphAttributes.position.length,
                x = s.get(h);
            if (x === void 0 || x.count !== m) {
                x !== void 0 && x.texture.dispose();
                let p = h.morphAttributes.normal !== void 0,
                    _ = h.morphAttributes.position,
                    y = h.morphAttributes.normal || [],
                    w = h.attributes.position.count,
                    A = p === !0 ? 2 : 1,
                    C = w * A,
                    I = 1;
                C > e.maxTextureSize &&
                    ((I = Math.ceil(C / e.maxTextureSize)),
                    (C = e.maxTextureSize));
                let k = new Float32Array(C * I * 4 * m),
                    z = new Cs(k, C, I, m);
                (z.format = lt), (z.type = on), (z.needsUpdate = !0);
                let P = A * 4;
                for (let b = 0; b < m; b++) {
                    let E = _[b],
                        D = y[b],
                        U = C * I * 4 * b;
                    for (let F = 0; F < E.count; F++) {
                        o.fromBufferAttribute(E, F),
                            E.normalized === !0 && Ec(o, E);
                        let O = F * P;
                        (k[U + O + 0] = o.x),
                            (k[U + O + 1] = o.y),
                            (k[U + O + 2] = o.z),
                            (k[U + O + 3] = 0),
                            p === !0 &&
                                (o.fromBufferAttribute(D, F),
                                D.normalized === !0 && Ec(o, D),
                                (k[U + O + 4] = o.x),
                                (k[U + O + 5] = o.y),
                                (k[U + O + 6] = o.z),
                                (k[U + O + 7] = 0));
                    }
                }
                (x = { count: m, texture: z, size: new W(C, I) }), s.set(h, x);
            }
            let v = 0;
            for (let p = 0; p < f.length; p++) v += f[p];
            let g = h.morphTargetsRelative ? 1 : 1 - v;
            d.getUniforms().setValue(r, "morphTargetBaseInfluence", g),
                d.getUniforms().setValue(r, "morphTargetInfluences", f),
                d
                    .getUniforms()
                    .setValue(r, "morphTargetsTexture", x.texture, t),
                d.getUniforms().setValue(r, "morphTargetsTextureSize", x.size);
        } else {
            let m = f === void 0 ? 0 : f.length,
                x = n[h.id];
            if (x === void 0 || x.length !== m) {
                x = [];
                for (let y = 0; y < m; y++) x[y] = [y, 0];
                n[h.id] = x;
            }
            for (let y = 0; y < m; y++) {
                let w = x[y];
                (w[0] = y), (w[1] = f[y]);
            }
            x.sort(bg);
            for (let y = 0; y < 8; y++)
                y < m && x[y][1]
                    ? ((a[y][0] = x[y][0]), (a[y][1] = x[y][1]))
                    : ((a[y][0] = Number.MAX_SAFE_INTEGER), (a[y][1] = 0));
            a.sort(wg);
            let v = h.morphAttributes.position,
                g = h.morphAttributes.normal,
                p = 0;
            for (let y = 0; y < 8; y++) {
                let w = a[y],
                    A = w[0],
                    C = w[1];
                A !== Number.MAX_SAFE_INTEGER && C
                    ? (v &&
                          h.getAttribute("morphTarget" + y) !== v[A] &&
                          h.setAttribute("morphTarget" + y, v[A]),
                      g &&
                          h.getAttribute("morphNormal" + y) !== g[A] &&
                          h.setAttribute("morphNormal" + y, g[A]),
                      (i[y] = C),
                      (p += C))
                    : (v &&
                          h.hasAttribute("morphTarget" + y) === !0 &&
                          h.deleteAttribute("morphTarget" + y),
                      g &&
                          h.hasAttribute("morphNormal" + y) === !0 &&
                          h.deleteAttribute("morphNormal" + y),
                      (i[y] = 0));
            }
            let _ = h.morphTargetsRelative ? 1 : 1 - p;
            d.getUniforms().setValue(r, "morphTargetBaseInfluence", _),
                d.getUniforms().setValue(r, "morphTargetInfluences", i);
        }
    }
    return { update: l };
}
function Tg(r, e, t, n) {
    let i = new WeakMap();
    function s(l) {
        let c = n.render.frame,
            h = l.geometry,
            u = e.get(l, h);
        return (
            i.get(u) !== c && (e.update(u), i.set(u, c)),
            l.isInstancedMesh &&
                (l.hasEventListener("dispose", a) === !1 &&
                    l.addEventListener("dispose", a),
                t.update(l.instanceMatrix, 34962),
                l.instanceColor !== null && t.update(l.instanceColor, 34962)),
            u
        );
    }
    function o() {
        i = new WeakMap();
    }
    function a(l) {
        let c = l.target;
        c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            c.instanceColor !== null && t.remove(c.instanceColor);
    }
    return { update: s, dispose: o };
}
var jr = class extends ft {
    constructor(e = null, t = 1, n = 1, i = 1) {
        super(null),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = st),
            (this.minFilter = st),
            (this.wrapR = yt),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
};
jr.prototype.isDataTexture3D = !0;
var hu = new ft(),
    uu = new Cs(),
    du = new jr(),
    fu = new jn(),
    Ac = [],
    Rc = [],
    Cc = new Float32Array(16),
    Lc = new Float32Array(9),
    Pc = new Float32Array(4);
function Ki(r, e, t) {
    let n = r[0];
    if (n <= 0 || n > 0) return r;
    let i = e * t,
        s = Ac[i];
    if ((s === void 0 && ((s = new Float32Array(i)), (Ac[i] = s)), e !== 0)) {
        n.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o) (a += t), r[o].toArray(s, a);
    }
    return s;
}
function wt(r, e) {
    if (r.length !== e.length) return !1;
    for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
    return !0;
}
function _t(r, e) {
    for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
}
function Xo(r, e) {
    let t = Rc[e];
    t === void 0 && ((t = new Int32Array(e)), (Rc[e] = t));
    for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
    return t;
}
function Eg(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function Ag(r, e) {
    let t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) &&
            (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
    else {
        if (wt(t, e)) return;
        r.uniform2fv(this.addr, e), _t(t, e);
    }
}
function Rg(r, e) {
    let t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (r.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (r.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
    else {
        if (wt(t, e)) return;
        r.uniform3fv(this.addr, e), _t(t, e);
    }
}
function Cg(r, e) {
    let t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
    else {
        if (wt(t, e)) return;
        r.uniform4fv(this.addr, e), _t(t, e);
    }
}
function Lg(r, e) {
    let t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (wt(t, e)) return;
        r.uniformMatrix2fv(this.addr, !1, e), _t(t, e);
    } else {
        if (wt(t, n)) return;
        Pc.set(n), r.uniformMatrix2fv(this.addr, !1, Pc), _t(t, n);
    }
}
function Pg(r, e) {
    let t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (wt(t, e)) return;
        r.uniformMatrix3fv(this.addr, !1, e), _t(t, e);
    } else {
        if (wt(t, n)) return;
        Lc.set(n), r.uniformMatrix3fv(this.addr, !1, Lc), _t(t, n);
    }
}
function Ig(r, e) {
    let t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (wt(t, e)) return;
        r.uniformMatrix4fv(this.addr, !1, e), _t(t, e);
    } else {
        if (wt(t, n)) return;
        Cc.set(n), r.uniformMatrix4fv(this.addr, !1, Cc), _t(t, n);
    }
}
function Dg(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function Fg(r, e) {
    let t = this.cache;
    wt(t, e) || (r.uniform2iv(this.addr, e), _t(t, e));
}
function Ng(r, e) {
    let t = this.cache;
    wt(t, e) || (r.uniform3iv(this.addr, e), _t(t, e));
}
function zg(r, e) {
    let t = this.cache;
    wt(t, e) || (r.uniform4iv(this.addr, e), _t(t, e));
}
function Bg(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function Ug(r, e) {
    let t = this.cache;
    wt(t, e) || (r.uniform2uiv(this.addr, e), _t(t, e));
}
function Og(r, e) {
    let t = this.cache;
    wt(t, e) || (r.uniform3uiv(this.addr, e), _t(t, e));
}
function Hg(r, e) {
    let t = this.cache;
    wt(t, e) || (r.uniform4uiv(this.addr, e), _t(t, e));
}
function kg(r, e, t) {
    let n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
        t.safeSetTexture2D(e || hu, i);
}
function Vg(r, e, t) {
    let n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
        t.setTexture3D(e || du, i);
}
function Gg(r, e, t) {
    let n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
        t.safeSetTextureCube(e || fu, i);
}
function Wg(r, e, t) {
    let n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
        t.setTexture2DArray(e || uu, i);
}
function qg(r) {
    switch (r) {
        case 5126:
            return Eg;
        case 35664:
            return Ag;
        case 35665:
            return Rg;
        case 35666:
            return Cg;
        case 35674:
            return Lg;
        case 35675:
            return Pg;
        case 35676:
            return Ig;
        case 5124:
        case 35670:
            return Dg;
        case 35667:
        case 35671:
            return Fg;
        case 35668:
        case 35672:
            return Ng;
        case 35669:
        case 35673:
            return zg;
        case 5125:
            return Bg;
        case 36294:
            return Ug;
        case 36295:
            return Og;
        case 36296:
            return Hg;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return kg;
        case 35679:
        case 36299:
        case 36307:
            return Vg;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return Gg;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return Wg;
    }
}
function Xg(r, e) {
    r.uniform1fv(this.addr, e);
}
function Jg(r, e) {
    let t = Ki(e, this.size, 2);
    r.uniform2fv(this.addr, t);
}
function Yg(r, e) {
    let t = Ki(e, this.size, 3);
    r.uniform3fv(this.addr, t);
}
function Zg(r, e) {
    let t = Ki(e, this.size, 4);
    r.uniform4fv(this.addr, t);
}
function $g(r, e) {
    let t = Ki(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, t);
}
function jg(r, e) {
    let t = Ki(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, t);
}
function Qg(r, e) {
    let t = Ki(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, t);
}
function Kg(r, e) {
    r.uniform1iv(this.addr, e);
}
function ex(r, e) {
    r.uniform2iv(this.addr, e);
}
function tx(r, e) {
    r.uniform3iv(this.addr, e);
}
function nx(r, e) {
    r.uniform4iv(this.addr, e);
}
function ix(r, e) {
    r.uniform1uiv(this.addr, e);
}
function sx(r, e) {
    r.uniform2uiv(this.addr, e);
}
function rx(r, e) {
    r.uniform3uiv(this.addr, e);
}
function ox(r, e) {
    r.uniform4uiv(this.addr, e);
}
function ax(r, e, t) {
    let n = e.length,
        i = Xo(t, n);
    r.uniform1iv(this.addr, i);
    for (let s = 0; s !== n; ++s) t.safeSetTexture2D(e[s] || hu, i[s]);
}
function lx(r, e, t) {
    let n = e.length,
        i = Xo(t, n);
    r.uniform1iv(this.addr, i);
    for (let s = 0; s !== n; ++s) t.setTexture3D(e[s] || du, i[s]);
}
function cx(r, e, t) {
    let n = e.length,
        i = Xo(t, n);
    r.uniform1iv(this.addr, i);
    for (let s = 0; s !== n; ++s) t.safeSetTextureCube(e[s] || fu, i[s]);
}
function hx(r, e, t) {
    let n = e.length,
        i = Xo(t, n);
    r.uniform1iv(this.addr, i);
    for (let s = 0; s !== n; ++s) t.setTexture2DArray(e[s] || uu, i[s]);
}
function ux(r) {
    switch (r) {
        case 5126:
            return Xg;
        case 35664:
            return Jg;
        case 35665:
            return Yg;
        case 35666:
            return Zg;
        case 35674:
            return $g;
        case 35675:
            return jg;
        case 35676:
            return Qg;
        case 5124:
        case 35670:
            return Kg;
        case 35667:
        case 35671:
            return ex;
        case 35668:
        case 35672:
            return tx;
        case 35669:
        case 35673:
            return nx;
        case 5125:
            return ix;
        case 36294:
            return sx;
        case 36295:
            return rx;
        case 36296:
            return ox;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return ax;
        case 35679:
        case 36299:
        case 36307:
            return lx;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return cx;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return hx;
    }
}
function dx(r, e, t) {
    (this.id = r),
        (this.addr = t),
        (this.cache = []),
        (this.setValue = qg(e.type));
}
function pu(r, e, t) {
    (this.id = r),
        (this.addr = t),
        (this.cache = []),
        (this.size = e.size),
        (this.setValue = ux(e.type));
}
pu.prototype.updateCache = function (r) {
    let e = this.cache;
    r instanceof Float32Array &&
        e.length !== r.length &&
        (this.cache = new Float32Array(r.length)),
        _t(e, r);
};
function mu(r) {
    (this.id = r), (this.seq = []), (this.map = {});
}
mu.prototype.setValue = function (r, e, t) {
    let n = this.seq;
    for (let i = 0, s = n.length; i !== s; ++i) {
        let o = n[i];
        o.setValue(r, e[o.id], t);
    }
};
var Ma = /(\w+)(\])?(\[|\.)?/g;
function Ic(r, e) {
    r.seq.push(e), (r.map[e.id] = e);
}
function fx(r, e, t) {
    let n = r.name,
        i = n.length;
    for (Ma.lastIndex = 0; ; ) {
        let s = Ma.exec(n),
            o = Ma.lastIndex,
            a = s[1],
            l = s[2] === "]",
            c = s[3];
        if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
            Ic(t, c === void 0 ? new dx(a, r, e) : new pu(a, r, e));
            break;
        } else {
            let u = t.map[a];
            u === void 0 && ((u = new mu(a)), Ic(t, u)), (t = u);
        }
    }
}
function Sn(r, e) {
    (this.seq = []), (this.map = {});
    let t = r.getProgramParameter(e, 35718);
    for (let n = 0; n < t; ++n) {
        let i = r.getActiveUniform(e, n),
            s = r.getUniformLocation(e, i.name);
        fx(i, s, this);
    }
}
Sn.prototype.setValue = function (r, e, t, n) {
    let i = this.map[e];
    i !== void 0 && i.setValue(r, t, n);
};
Sn.prototype.setOptional = function (r, e, t) {
    let n = e[t];
    n !== void 0 && this.setValue(r, t, n);
};
Sn.upload = function (r, e, t, n) {
    for (let i = 0, s = e.length; i !== s; ++i) {
        let o = e[i],
            a = t[o.id];
        a.needsUpdate !== !1 && o.setValue(r, a.value, n);
    }
};
Sn.seqWithValue = function (r, e) {
    let t = [];
    for (let n = 0, i = r.length; n !== i; ++n) {
        let s = r[n];
        s.id in e && t.push(s);
    }
    return t;
};
function Dc(r, e, t) {
    let n = r.createShader(e);
    return r.shaderSource(n, t), r.compileShader(n), n;
}
var px = 0;
function mx(r) {
    let e = r.split(`
`);
    for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
    return e.join(`
`);
}
function gu(r) {
    switch (r) {
        case Ot:
            return ["Linear", "( value )"];
        case ji:
            return ["sRGB", "( value )"];
        default:
            return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", r),
                ["Linear", "( value )"]
            );
    }
}
function Fc(r, e, t) {
    let n = r.getShaderParameter(e, 35713),
        i = r.getShaderInfoLog(e).trim();
    return n && i === ""
        ? ""
        : t.toUpperCase() +
              `

` +
              i +
              `

` +
              mx(r.getShaderSource(e));
}
function On(r, e) {
    let t = gu(e);
    return (
        "vec4 " +
        r +
        "( vec4 value ) { return " +
        t[0] +
        "ToLinear" +
        t[1] +
        "; }"
    );
}
function gx(r, e) {
    let t = gu(e);
    return (
        "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
    );
}
function xx(r, e) {
    let t;
    switch (e) {
        case td:
            t = "Linear";
            break;
        case nd:
            t = "Reinhard";
            break;
        case id:
            t = "OptimizedCineon";
            break;
        case sd:
            t = "ACESFilmic";
            break;
        case rd:
            t = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                (t = "Linear");
    }
    return (
        "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
    );
}
function yx(r) {
    return [
        r.extensionDerivatives ||
        r.envMapCubeUV ||
        r.bumpMap ||
        r.tangentSpaceNormalMap ||
        r.clearcoatNormalMap ||
        r.flatShading ||
        r.shaderID === "physical"
            ? "#extension GL_OES_standard_derivatives : enable"
            : "",
        (r.extensionFragDepth || r.logarithmicDepthBuffer) &&
        r.rendererExtensionFragDepth
            ? "#extension GL_EXT_frag_depth : enable"
            : "",
        r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
            ? "#extension GL_EXT_draw_buffers : require"
            : "",
        (r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
        r.rendererExtensionShaderTextureLod
            ? "#extension GL_EXT_shader_texture_lod : enable"
            : "",
    ].filter(ds).join(`
`);
}
function vx(r) {
    let e = [];
    for (let t in r) {
        let n = r[t];
        n !== !1 && e.push("#define " + t + " " + n);
    }
    return e.join(`
`);
}
function _x(r, e) {
    let t = {},
        n = r.getProgramParameter(e, 35721);
    for (let i = 0; i < n; i++) {
        let s = r.getActiveAttrib(e, i),
            o = s.name,
            a = 1;
        s.type === 35674 && (a = 2),
            s.type === 35675 && (a = 3),
            s.type === 35676 && (a = 4),
            (t[o] = {
                type: s.type,
                location: r.getAttribLocation(e, o),
                locationSize: a,
            });
    }
    return t;
}
function ds(r) {
    return r !== "";
}
function Nc(r, e) {
    return r
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function zc(r, e) {
    return r
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
        );
}
var Mx = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Wa(r) {
    return r.replace(Mx, wx);
}
function wx(r, e) {
    let t = Fe[e];
    if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
    return Wa(t);
}
var bx =
        /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    Sx =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Bc(r) {
    return r.replace(Sx, xu).replace(bx, Tx);
}
function Tx(r, e, t, n) {
    return (
        console.warn(
            "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
        ),
        xu(r, e, t, n)
    );
}
function xu(r, e, t, n) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        i += n
            .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, s);
    return i;
}
function Uc(r) {
    let e =
        "precision " +
        r.precision +
        ` float;
precision ` +
        r.precision +
        " int;";
    return (
        r.precision === "highp"
            ? (e += `
#define HIGH_PRECISION`)
            : r.precision === "mediump"
            ? (e += `
#define MEDIUM_PRECISION`)
            : r.precision === "lowp" &&
              (e += `
#define LOW_PRECISION`),
        e
    );
}
function Ex(r) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return (
        r.shadowMapType === jh
            ? (e = "SHADOWMAP_TYPE_PCF")
            : r.shadowMapType === Du
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : r.shadowMapType === us && (e = "SHADOWMAP_TYPE_VSM"),
        e
    );
}
function Ax(r) {
    let e = "ENVMAP_TYPE_CUBE";
    if (r.envMap)
        switch (r.envMapMode) {
            case Yi:
            case Zi:
                e = "ENVMAP_TYPE_CUBE";
                break;
            case js:
            case Wo:
                e = "ENVMAP_TYPE_CUBE_UV";
                break;
        }
    return e;
}
function Rx(r) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (r.envMap)
        switch (r.envMapMode) {
            case Zi:
            case Wo:
                e = "ENVMAP_MODE_REFRACTION";
                break;
        }
    return e;
}
function Cx(r) {
    let e = "ENVMAP_BLENDING_NONE";
    if (r.envMap)
        switch (r.combine) {
            case Go:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case Ku:
                e = "ENVMAP_BLENDING_MIX";
                break;
            case ed:
                e = "ENVMAP_BLENDING_ADD";
                break;
        }
    return e;
}
function Lx(r, e, t, n) {
    let i = r.getContext(),
        s = t.defines,
        o = t.vertexShader,
        a = t.fragmentShader,
        l = Ex(t),
        c = Ax(t),
        h = Rx(t),
        u = Cx(t),
        d = t.isWebGL2 ? "" : yx(t),
        f = vx(s),
        m = i.createProgram(),
        x,
        v,
        g = t.glslVersion
            ? "#version " +
              t.glslVersion +
              `
`
            : "";
    t.isRawShaderMaterial
        ? ((x = [f].filter(ds).join(`
`)),
          x.length > 0 &&
              (x += `
`),
          (v = [d, f].filter(ds).join(`
`)),
          v.length > 0 &&
              (v += `
`))
        : ((x = [
              Uc(t),
              "#define SHADER_NAME " + t.shaderName,
              f,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define MAX_BONES " + t.maxBones,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + h : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
              t.normalMap && t.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.displacementMap && t.supportsVertexTextures
                  ? "#define USE_DISPLACEMENTMAP"
                  : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.useVertexTexture ? "#define BONE_TEXTURE" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && t.flatShading === !1
                  ? "#define USE_MORPHNORMALS"
                  : "",
              t.morphTargets && t.isWebGL2
                  ? "#define MORPHTARGETS_TEXTURE"
                  : "",
              t.morphTargets && t.isWebGL2
                  ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
                  : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "	attribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "	attribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "	attribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "	attribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "	attribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "	attribute vec3 morphTarget0;",
              "	attribute vec3 morphTarget1;",
              "	attribute vec3 morphTarget2;",
              "	attribute vec3 morphTarget3;",
              "	#ifdef USE_MORPHNORMALS",
              "		attribute vec3 morphNormal0;",
              "		attribute vec3 morphNormal1;",
              "		attribute vec3 morphNormal2;",
              "		attribute vec3 morphNormal3;",
              "	#else",
              "		attribute vec3 morphTarget4;",
              "		attribute vec3 morphTarget5;",
              "		attribute vec3 morphTarget6;",
              "		attribute vec3 morphTarget7;",
              "	#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "	attribute vec4 skinIndex;",
              "	attribute vec4 skinWeight;",
              "#endif",
              `
`,
          ].filter(ds).join(`
`)),
          (v = [
              d,
              Uc(t),
              "#define SHADER_NAME " + t.shaderName,
              f,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + h : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMap && t.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
              t.normalMap && t.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
              t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents ? "#define USE_TANGENT" : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUvs ? "#define USE_UV" : "",
              t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.physicallyCorrectLights
                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                  : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
              (t.extensionShaderTextureLOD || t.envMap) &&
              t.rendererExtensionShaderTextureLod
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== wn ? "#define TONE_MAPPING" : "",
              t.toneMapping !== wn ? Fe.tonemapping_pars_fragment : "",
              t.toneMapping !== wn ? xx("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.format === Jn ? "#define OPAQUE" : "",
              Fe.encodings_pars_fragment,
              t.map ? On("mapTexelToLinear", t.mapEncoding) : "",
              t.matcap ? On("matcapTexelToLinear", t.matcapEncoding) : "",
              t.envMap ? On("envMapTexelToLinear", t.envMapEncoding) : "",
              t.emissiveMap
                  ? On("emissiveMapTexelToLinear", t.emissiveMapEncoding)
                  : "",
              t.specularColorMap
                  ? On(
                        "specularColorMapTexelToLinear",
                        t.specularColorMapEncoding
                    )
                  : "",
              t.sheenColorMap
                  ? On("sheenColorMapTexelToLinear", t.sheenColorMapEncoding)
                  : "",
              t.lightMap ? On("lightMapTexelToLinear", t.lightMapEncoding) : "",
              gx("linearToOutputTexel", t.outputEncoding),
              t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
              `
`,
          ].filter(ds).join(`
`))),
        (o = Wa(o)),
        (o = Nc(o, t)),
        (o = zc(o, t)),
        (a = Wa(a)),
        (a = Nc(a, t)),
        (a = zc(a, t)),
        (o = Bc(o)),
        (a = Bc(a)),
        t.isWebGL2 &&
            t.isRawShaderMaterial !== !0 &&
            ((g = `#version 300 es
`),
            (x =
                [
                    "precision mediump sampler2DArray;",
                    "#define attribute in",
                    "#define varying out",
                    "#define texture2D texture",
                ].join(`
`) +
                `
` +
                x),
            (v =
                [
                    "#define varying in",
                    t.glslVersion === lc
                        ? ""
                        : "layout(location = 0) out highp vec4 pc_fragColor;",
                    t.glslVersion === lc
                        ? ""
                        : "#define gl_FragColor pc_fragColor",
                    "#define gl_FragDepthEXT gl_FragDepth",
                    "#define texture2D texture",
                    "#define textureCube texture",
                    "#define texture2DProj textureProj",
                    "#define texture2DLodEXT textureLod",
                    "#define texture2DProjLodEXT textureProjLod",
                    "#define textureCubeLodEXT textureLod",
                    "#define texture2DGradEXT textureGrad",
                    "#define texture2DProjGradEXT textureProjGrad",
                    "#define textureCubeGradEXT textureGrad",
                ].join(`
`) +
                `
` +
                v));
    let p = g + x + o,
        _ = g + v + a,
        y = Dc(i, 35633, p),
        w = Dc(i, 35632, _);
    if (
        (i.attachShader(m, y),
        i.attachShader(m, w),
        t.index0AttributeName !== void 0
            ? i.bindAttribLocation(m, 0, t.index0AttributeName)
            : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"),
        i.linkProgram(m),
        r.debug.checkShaderErrors)
    ) {
        let I = i.getProgramInfoLog(m).trim(),
            k = i.getShaderInfoLog(y).trim(),
            z = i.getShaderInfoLog(w).trim(),
            P = !0,
            b = !0;
        if (i.getProgramParameter(m, 35714) === !1) {
            P = !1;
            let E = Fc(i, y, "vertex"),
                D = Fc(i, w, "fragment");
            console.error(
                "THREE.WebGLProgram: Shader Error " +
                    i.getError() +
                    " - VALIDATE_STATUS " +
                    i.getProgramParameter(m, 35715) +
                    `

Program Info Log: ` +
                    I +
                    `
` +
                    E +
                    `
` +
                    D
            );
        } else
            I !== ""
                ? console.warn("THREE.WebGLProgram: Program Info Log:", I)
                : (k === "" || z === "") && (b = !1);
        b &&
            (this.diagnostics = {
                runnable: P,
                programLog: I,
                vertexShader: { log: k, prefix: x },
                fragmentShader: { log: z, prefix: v },
            });
    }
    i.deleteShader(y), i.deleteShader(w);
    let A;
    this.getUniforms = function () {
        return A === void 0 && (A = new Sn(i, m)), A;
    };
    let C;
    return (
        (this.getAttributes = function () {
            return C === void 0 && (C = _x(i, m)), C;
        }),
        (this.destroy = function () {
            n.releaseStatesOfProgram(this),
                i.deleteProgram(m),
                (this.program = void 0);
        }),
        (this.name = t.shaderName),
        (this.id = px++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = m),
        (this.vertexShader = y),
        (this.fragmentShader = w),
        this
    );
}
var Px = 0,
    qa = class {
        constructor() {
            (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
            let t = e.vertexShader,
                n = e.fragmentShader,
                i = this._getShaderStage(t),
                s = this._getShaderStage(n),
                o = this._getShaderCacheForMaterial(e);
            return (
                o.has(i) === !1 && (o.add(i), i.usedTimes++),
                o.has(s) === !1 && (o.add(s), s.usedTimes++),
                this
            );
        }
        remove(e) {
            let t = this.materialCache.get(e);
            for (let n of t)
                n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n);
            return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
            return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
            return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
            let t = this.materialCache;
            return t.has(e) === !1 && t.set(e, new Set()), t.get(e);
        }
        _getShaderStage(e) {
            let t = this.shaderCache;
            if (t.has(e) === !1) {
                let n = new Xa();
                t.set(e, n);
            }
            return t.get(e);
        }
    },
    Xa = class {
        constructor() {
            (this.id = Px++), (this.usedTimes = 0);
        }
    };
function Ix(r, e, t, n, i, s, o) {
    let a = new bs(),
        l = new qa(),
        c = [],
        h = i.isWebGL2,
        u = i.logarithmicDepthBuffer,
        d = i.floatVertexTextures,
        f = i.maxVertexUniforms,
        m = i.vertexTextures,
        x = i.precision,
        v = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
        };
    function g(b) {
        let D = b.skeleton.bones;
        if (d) return 1024;
        {
            let F = Math.floor((f - 20) / 4),
                O = Math.min(F, D.length);
            return O < D.length
                ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                          D.length +
                          " bones. This GPU supports " +
                          O +
                          "."
                  ),
                  0)
                : O;
        }
    }
    function p(b) {
        let E;
        return (
            b && b.isTexture
                ? (E = b.encoding)
                : b && b.isWebGLRenderTarget
                ? (console.warn(
                      "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (E = b.texture.encoding))
                : (E = Ot),
            h &&
                b &&
                b.isTexture &&
                b.format === lt &&
                b.type === an &&
                b.encoding === ji &&
                (E = Ot),
            E
        );
    }
    function _(b, E, D, U, F) {
        let O = U.fog,
            ne = b.isMeshStandardMaterial ? U.environment : null,
            ce = (b.isMeshStandardMaterial ? t : e).get(b.envMap || ne),
            G = v[b.type],
            q = F.isSkinnedMesh ? g(F) : 0;
        b.precision !== null &&
            ((x = i.getMaxPrecision(b.precision)),
            x !== b.precision &&
                console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    b.precision,
                    "not supported, using",
                    x,
                    "instead."
                ));
        let he, le, fe, Ne;
        if (G) {
            let xe = Jt[G];
            (he = xe.vertexShader), (le = xe.fragmentShader);
        } else
            (he = b.vertexShader),
                (le = b.fragmentShader),
                l.update(b),
                (fe = l.getVertexShaderID(b)),
                (Ne = l.getFragmentShaderID(b));
        let Y = r.getRenderTarget(),
            Re = b.alphaTest > 0,
            ye = b.clearcoat > 0;
        return {
            isWebGL2: h,
            shaderID: G,
            shaderName: b.type,
            vertexShader: he,
            fragmentShader: le,
            defines: b.defines,
            customVertexShaderID: fe,
            customFragmentShaderID: Ne,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: x,
            instancing: F.isInstancedMesh === !0,
            instancingColor:
                F.isInstancedMesh === !0 && F.instanceColor !== null,
            supportsVertexTextures: m,
            outputEncoding: Y !== null ? p(Y.texture) : r.outputEncoding,
            map: !!b.map,
            mapEncoding: p(b.map),
            matcap: !!b.matcap,
            matcapEncoding: p(b.matcap),
            envMap: !!ce,
            envMapMode: ce && ce.mapping,
            envMapEncoding: p(ce),
            envMapCubeUV: !!ce && (ce.mapping === js || ce.mapping === Wo),
            lightMap: !!b.lightMap,
            lightMapEncoding: p(b.lightMap),
            aoMap: !!b.aoMap,
            emissiveMap: !!b.emissiveMap,
            emissiveMapEncoding: p(b.emissiveMap),
            bumpMap: !!b.bumpMap,
            normalMap: !!b.normalMap,
            objectSpaceNormalMap: b.normalMapType === sf,
            tangentSpaceNormalMap: b.normalMapType === Qi,
            clearcoat: ye,
            clearcoatMap: ye && !!b.clearcoatMap,
            clearcoatRoughnessMap: ye && !!b.clearcoatRoughnessMap,
            clearcoatNormalMap: ye && !!b.clearcoatNormalMap,
            displacementMap: !!b.displacementMap,
            roughnessMap: !!b.roughnessMap,
            metalnessMap: !!b.metalnessMap,
            specularMap: !!b.specularMap,
            specularIntensityMap: !!b.specularIntensityMap,
            specularColorMap: !!b.specularColorMap,
            specularColorMapEncoding: p(b.specularColorMap),
            alphaMap: !!b.alphaMap,
            alphaTest: Re,
            gradientMap: !!b.gradientMap,
            sheen: b.sheen > 0,
            sheenColorMap: !!b.sheenColorMap,
            sheenColorMapEncoding: p(b.sheenColorMap),
            sheenRoughnessMap: !!b.sheenRoughnessMap,
            transmission: b.transmission > 0,
            transmissionMap: !!b.transmissionMap,
            thicknessMap: !!b.thicknessMap,
            combine: b.combine,
            vertexTangents:
                !!b.normalMap &&
                !!F.geometry &&
                !!F.geometry.attributes.tangent,
            vertexColors: b.vertexColors,
            vertexAlphas:
                b.vertexColors === !0 &&
                !!F.geometry &&
                !!F.geometry.attributes.color &&
                F.geometry.attributes.color.itemSize === 4,
            vertexUvs:
                !!b.map ||
                !!b.bumpMap ||
                !!b.normalMap ||
                !!b.specularMap ||
                !!b.alphaMap ||
                !!b.emissiveMap ||
                !!b.roughnessMap ||
                !!b.metalnessMap ||
                !!b.clearcoatMap ||
                !!b.clearcoatRoughnessMap ||
                !!b.clearcoatNormalMap ||
                !!b.displacementMap ||
                !!b.transmissionMap ||
                !!b.thicknessMap ||
                !!b.specularIntensityMap ||
                !!b.specularColorMap ||
                !!b.sheenColorMap ||
                !!b.sheenRoughnessMap,
            uvsVertexOnly:
                !(
                    b.map ||
                    b.bumpMap ||
                    b.normalMap ||
                    b.specularMap ||
                    b.alphaMap ||
                    b.emissiveMap ||
                    b.roughnessMap ||
                    b.metalnessMap ||
                    b.clearcoatNormalMap ||
                    b.transmission > 0 ||
                    b.transmissionMap ||
                    b.thicknessMap ||
                    b.specularIntensityMap ||
                    b.specularColorMap ||
                    b.sheen > 0 ||
                    b.sheenColorMap ||
                    b.sheenRoughnessMap
                ) && !!b.displacementMap,
            fog: !!O,
            useFog: b.fog,
            fogExp2: O && O.isFogExp2,
            flatShading: !!b.flatShading,
            sizeAttenuation: b.sizeAttenuation,
            logarithmicDepthBuffer: u,
            skinning: F.isSkinnedMesh === !0 && q > 0,
            maxBones: q,
            useVertexTexture: d,
            morphTargets: !!F.geometry && !!F.geometry.morphAttributes.position,
            morphNormals: !!F.geometry && !!F.geometry.morphAttributes.normal,
            morphTargetsCount:
                F.geometry && F.geometry.morphAttributes.position
                    ? F.geometry.morphAttributes.position.length
                    : 0,
            numDirLights: E.directional.length,
            numPointLights: E.point.length,
            numSpotLights: E.spot.length,
            numRectAreaLights: E.rectArea.length,
            numHemiLights: E.hemi.length,
            numDirLightShadows: E.directionalShadowMap.length,
            numPointLightShadows: E.pointShadowMap.length,
            numSpotLightShadows: E.spotShadowMap.length,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            format: b.format,
            dithering: b.dithering,
            shadowMapEnabled: r.shadowMap.enabled && D.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: b.toneMapped ? r.toneMapping : wn,
            physicallyCorrectLights: r.physicallyCorrectLights,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === Li,
            flipSided: b.side === it,
            depthPacking: b.depthPacking !== void 0 ? b.depthPacking : !1,
            index0AttributeName: b.index0AttributeName,
            extensionDerivatives: b.extensions && b.extensions.derivatives,
            extensionFragDepth: b.extensions && b.extensions.fragDepth,
            extensionDrawBuffers: b.extensions && b.extensions.drawBuffers,
            extensionShaderTextureLOD:
                b.extensions && b.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
                h || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: b.customProgramCacheKey(),
        };
    }
    function y(b) {
        let E = [];
        if (
            (b.shaderID
                ? E.push(b.shaderID)
                : (E.push(b.customVertexShaderID),
                  E.push(b.customFragmentShaderID)),
            b.defines !== void 0)
        )
            for (let D in b.defines) E.push(D), E.push(b.defines[D]);
        return (
            b.isRawShaderMaterial === !1 &&
                (w(E, b), A(E, b), E.push(r.outputEncoding)),
            E.push(b.customProgramCacheKey),
            E.join()
        );
    }
    function w(b, E) {
        b.push(E.precision),
            b.push(E.outputEncoding),
            b.push(E.mapEncoding),
            b.push(E.matcapEncoding),
            b.push(E.envMapMode),
            b.push(E.envMapEncoding),
            b.push(E.lightMapEncoding),
            b.push(E.emissiveMapEncoding),
            b.push(E.combine),
            b.push(E.vertexUvs),
            b.push(E.fogExp2),
            b.push(E.sizeAttenuation),
            b.push(E.maxBones),
            b.push(E.morphTargetsCount),
            b.push(E.numDirLights),
            b.push(E.numPointLights),
            b.push(E.numSpotLights),
            b.push(E.numHemiLights),
            b.push(E.numRectAreaLights),
            b.push(E.numDirLightShadows),
            b.push(E.numPointLightShadows),
            b.push(E.numSpotLightShadows),
            b.push(E.shadowMapType),
            b.push(E.toneMapping),
            b.push(E.numClippingPlanes),
            b.push(E.numClipIntersection),
            b.push(E.format),
            b.push(E.specularColorMapEncoding),
            b.push(E.sheenColorMapEncoding);
    }
    function A(b, E) {
        a.disableAll(),
            E.isWebGL2 && a.enable(0),
            E.supportsVertexTextures && a.enable(1),
            E.instancing && a.enable(2),
            E.instancingColor && a.enable(3),
            E.map && a.enable(4),
            E.matcap && a.enable(5),
            E.envMap && a.enable(6),
            E.envMapCubeUV && a.enable(7),
            E.lightMap && a.enable(8),
            E.aoMap && a.enable(9),
            E.emissiveMap && a.enable(10),
            E.bumpMap && a.enable(11),
            E.normalMap && a.enable(12),
            E.objectSpaceNormalMap && a.enable(13),
            E.tangentSpaceNormalMap && a.enable(14),
            E.clearcoat && a.enable(15),
            E.clearcoatMap && a.enable(16),
            E.clearcoatRoughnessMap && a.enable(17),
            E.clearcoatNormalMap && a.enable(18),
            E.displacementMap && a.enable(19),
            E.specularMap && a.enable(20),
            E.roughnessMap && a.enable(21),
            E.metalnessMap && a.enable(22),
            E.gradientMap && a.enable(23),
            E.alphaMap && a.enable(24),
            E.alphaTest && a.enable(25),
            E.vertexColors && a.enable(26),
            E.vertexAlphas && a.enable(27),
            E.vertexUvs && a.enable(28),
            E.vertexTangents && a.enable(29),
            E.uvsVertexOnly && a.enable(30),
            E.fog && a.enable(31),
            b.push(a.mask),
            a.disableAll(),
            E.useFog && a.enable(0),
            E.flatShading && a.enable(1),
            E.logarithmicDepthBuffer && a.enable(2),
            E.skinning && a.enable(3),
            E.useVertexTexture && a.enable(4),
            E.morphTargets && a.enable(5),
            E.morphNormals && a.enable(6),
            E.premultipliedAlpha && a.enable(7),
            E.shadowMapEnabled && a.enable(8),
            E.physicallyCorrectLights && a.enable(9),
            E.doubleSided && a.enable(10),
            E.flipSided && a.enable(11),
            E.depthPacking && a.enable(12),
            E.dithering && a.enable(13),
            E.specularIntensityMap && a.enable(14),
            E.specularColorMap && a.enable(15),
            E.transmission && a.enable(16),
            E.transmissionMap && a.enable(17),
            E.thicknessMap && a.enable(18),
            E.sheen && a.enable(19),
            E.sheenColorMap && a.enable(20),
            E.sheenRoughnessMap && a.enable(21),
            b.push(a.mask);
    }
    function C(b) {
        let E = v[b.type],
            D;
        if (E) {
            let U = Jt[E];
            D = Pf.clone(U.uniforms);
        } else D = b.uniforms;
        return D;
    }
    function I(b, E) {
        let D;
        for (let U = 0, F = c.length; U < F; U++) {
            let O = c[U];
            if (O.cacheKey === E) {
                (D = O), ++D.usedTimes;
                break;
            }
        }
        return D === void 0 && ((D = new Lx(r, E, b, s)), c.push(D)), D;
    }
    function k(b) {
        if (--b.usedTimes === 0) {
            let E = c.indexOf(b);
            (c[E] = c[c.length - 1]), c.pop(), b.destroy();
        }
    }
    function z(b) {
        l.remove(b);
    }
    function P() {
        l.dispose();
    }
    return {
        getParameters: _,
        getProgramCacheKey: y,
        getUniforms: C,
        acquireProgram: I,
        releaseProgram: k,
        releaseShaderCache: z,
        programs: c,
        dispose: P,
    };
}
function Dx() {
    let r = new WeakMap();
    function e(s) {
        let o = r.get(s);
        return o === void 0 && ((o = {}), r.set(s, o)), o;
    }
    function t(s) {
        r.delete(s);
    }
    function n(s, o, a) {
        r.get(s)[o] = a;
    }
    function i() {
        r = new WeakMap();
    }
    return { get: e, remove: t, update: n, dispose: i };
}
function Fx(r, e) {
    return r.groupOrder !== e.groupOrder
        ? r.groupOrder - e.groupOrder
        : r.renderOrder !== e.renderOrder
        ? r.renderOrder - e.renderOrder
        : r.material.id !== e.material.id
        ? r.material.id - e.material.id
        : r.z !== e.z
        ? r.z - e.z
        : r.id - e.id;
}
function Oc(r, e) {
    return r.groupOrder !== e.groupOrder
        ? r.groupOrder - e.groupOrder
        : r.renderOrder !== e.renderOrder
        ? r.renderOrder - e.renderOrder
        : r.z !== e.z
        ? e.z - r.z
        : r.id - e.id;
}
function Hc() {
    let r = [],
        e = 0,
        t = [],
        n = [],
        i = [];
    function s() {
        (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
    }
    function o(u, d, f, m, x, v) {
        let g = r[e];
        return (
            g === void 0
                ? ((g = {
                      id: u.id,
                      object: u,
                      geometry: d,
                      material: f,
                      groupOrder: m,
                      renderOrder: u.renderOrder,
                      z: x,
                      group: v,
                  }),
                  (r[e] = g))
                : ((g.id = u.id),
                  (g.object = u),
                  (g.geometry = d),
                  (g.material = f),
                  (g.groupOrder = m),
                  (g.renderOrder = u.renderOrder),
                  (g.z = x),
                  (g.group = v)),
            e++,
            g
        );
    }
    function a(u, d, f, m, x, v) {
        let g = o(u, d, f, m, x, v);
        f.transmission > 0
            ? n.push(g)
            : f.transparent === !0
            ? i.push(g)
            : t.push(g);
    }
    function l(u, d, f, m, x, v) {
        let g = o(u, d, f, m, x, v);
        f.transmission > 0
            ? n.unshift(g)
            : f.transparent === !0
            ? i.unshift(g)
            : t.unshift(g);
    }
    function c(u, d) {
        t.length > 1 && t.sort(u || Fx),
            n.length > 1 && n.sort(d || Oc),
            i.length > 1 && i.sort(d || Oc);
    }
    function h() {
        for (let u = e, d = r.length; u < d; u++) {
            let f = r[u];
            if (f.id === null) break;
            (f.id = null),
                (f.object = null),
                (f.geometry = null),
                (f.material = null),
                (f.group = null);
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: s,
        push: a,
        unshift: l,
        finish: h,
        sort: c,
    };
}
function Nx() {
    let r = new WeakMap();
    function e(n, i) {
        let s;
        return (
            r.has(n) === !1
                ? ((s = new Hc()), r.set(n, [s]))
                : i >= r.get(n).length
                ? ((s = new Hc()), r.get(n).push(s))
                : (s = r.get(n)[i]),
            s
        );
    }
    function t() {
        r = new WeakMap();
    }
    return { get: e, dispose: t };
}
function zx() {
    let r = {};
    return {
        get: function (e) {
            if (r[e.id] !== void 0) return r[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = { direction: new M(), color: new re() };
                    break;
                case "SpotLight":
                    t = {
                        position: new M(),
                        direction: new M(),
                        color: new re(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new M(),
                        color: new re(),
                        distance: 0,
                        decay: 0,
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new M(),
                        skyColor: new re(),
                        groundColor: new re(),
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new re(),
                        position: new M(),
                        halfWidth: new M(),
                        halfHeight: new M(),
                    };
                    break;
            }
            return (r[e.id] = t), t;
        },
    };
}
function Bx() {
    let r = {};
    return {
        get: function (e) {
            if (r[e.id] !== void 0) return r[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new W(),
                    };
                    break;
                case "SpotLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new W(),
                    };
                    break;
                case "PointLight":
                    t = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new W(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                    };
                    break;
            }
            return (r[e.id] = t), t;
        },
    };
}
var Ux = 0;
function Ox(r, e) {
    return (e.castShadow ? 1 : 0) - (r.castShadow ? 1 : 0);
}
function Hx(r, e) {
    let t = new zx(),
        n = Bx(),
        i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
        };
    for (let h = 0; h < 9; h++) i.probe.push(new M());
    let s = new M(),
        o = new me(),
        a = new me();
    function l(h, u) {
        let d = 0,
            f = 0,
            m = 0;
        for (let k = 0; k < 9; k++) i.probe[k].set(0, 0, 0);
        let x = 0,
            v = 0,
            g = 0,
            p = 0,
            _ = 0,
            y = 0,
            w = 0,
            A = 0;
        h.sort(Ox);
        let C = u !== !0 ? Math.PI : 1;
        for (let k = 0, z = h.length; k < z; k++) {
            let P = h[k],
                b = P.color,
                E = P.intensity,
                D = P.distance,
                U = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
            if (P.isAmbientLight)
                (d += b.r * E * C), (f += b.g * E * C), (m += b.b * E * C);
            else if (P.isLightProbe)
                for (let F = 0; F < 9; F++)
                    i.probe[F].addScaledVector(P.sh.coefficients[F], E);
            else if (P.isDirectionalLight) {
                let F = t.get(P);
                if (
                    (F.color.copy(P.color).multiplyScalar(P.intensity * C),
                    P.castShadow)
                ) {
                    let O = P.shadow,
                        ne = n.get(P);
                    (ne.shadowBias = O.bias),
                        (ne.shadowNormalBias = O.normalBias),
                        (ne.shadowRadius = O.radius),
                        (ne.shadowMapSize = O.mapSize),
                        (i.directionalShadow[x] = ne),
                        (i.directionalShadowMap[x] = U),
                        (i.directionalShadowMatrix[x] = P.shadow.matrix),
                        y++;
                }
                (i.directional[x] = F), x++;
            } else if (P.isSpotLight) {
                let F = t.get(P);
                if (
                    (F.position.setFromMatrixPosition(P.matrixWorld),
                    F.color.copy(b).multiplyScalar(E * C),
                    (F.distance = D),
                    (F.coneCos = Math.cos(P.angle)),
                    (F.penumbraCos = Math.cos(P.angle * (1 - P.penumbra))),
                    (F.decay = P.decay),
                    P.castShadow)
                ) {
                    let O = P.shadow,
                        ne = n.get(P);
                    (ne.shadowBias = O.bias),
                        (ne.shadowNormalBias = O.normalBias),
                        (ne.shadowRadius = O.radius),
                        (ne.shadowMapSize = O.mapSize),
                        (i.spotShadow[g] = ne),
                        (i.spotShadowMap[g] = U),
                        (i.spotShadowMatrix[g] = P.shadow.matrix),
                        A++;
                }
                (i.spot[g] = F), g++;
            } else if (P.isRectAreaLight) {
                let F = t.get(P);
                F.color.copy(b).multiplyScalar(E),
                    F.halfWidth.set(P.width * 0.5, 0, 0),
                    F.halfHeight.set(0, P.height * 0.5, 0),
                    (i.rectArea[p] = F),
                    p++;
            } else if (P.isPointLight) {
                let F = t.get(P);
                if (
                    (F.color.copy(P.color).multiplyScalar(P.intensity * C),
                    (F.distance = P.distance),
                    (F.decay = P.decay),
                    P.castShadow)
                ) {
                    let O = P.shadow,
                        ne = n.get(P);
                    (ne.shadowBias = O.bias),
                        (ne.shadowNormalBias = O.normalBias),
                        (ne.shadowRadius = O.radius),
                        (ne.shadowMapSize = O.mapSize),
                        (ne.shadowCameraNear = O.camera.near),
                        (ne.shadowCameraFar = O.camera.far),
                        (i.pointShadow[v] = ne),
                        (i.pointShadowMap[v] = U),
                        (i.pointShadowMatrix[v] = P.shadow.matrix),
                        w++;
                }
                (i.point[v] = F), v++;
            } else if (P.isHemisphereLight) {
                let F = t.get(P);
                F.skyColor.copy(P.color).multiplyScalar(E * C),
                    F.groundColor.copy(P.groundColor).multiplyScalar(E * C),
                    (i.hemi[_] = F),
                    _++;
            }
        }
        p > 0 &&
            (e.isWebGL2 || r.has("OES_texture_float_linear") === !0
                ? ((i.rectAreaLTC1 = ie.LTC_FLOAT_1),
                  (i.rectAreaLTC2 = ie.LTC_FLOAT_2))
                : r.has("OES_texture_half_float_linear") === !0
                ? ((i.rectAreaLTC1 = ie.LTC_HALF_1),
                  (i.rectAreaLTC2 = ie.LTC_HALF_2))
                : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
            (i.ambient[0] = d),
            (i.ambient[1] = f),
            (i.ambient[2] = m);
        let I = i.hash;
        (I.directionalLength !== x ||
            I.pointLength !== v ||
            I.spotLength !== g ||
            I.rectAreaLength !== p ||
            I.hemiLength !== _ ||
            I.numDirectionalShadows !== y ||
            I.numPointShadows !== w ||
            I.numSpotShadows !== A) &&
            ((i.directional.length = x),
            (i.spot.length = g),
            (i.rectArea.length = p),
            (i.point.length = v),
            (i.hemi.length = _),
            (i.directionalShadow.length = y),
            (i.directionalShadowMap.length = y),
            (i.pointShadow.length = w),
            (i.pointShadowMap.length = w),
            (i.spotShadow.length = A),
            (i.spotShadowMap.length = A),
            (i.directionalShadowMatrix.length = y),
            (i.pointShadowMatrix.length = w),
            (i.spotShadowMatrix.length = A),
            (I.directionalLength = x),
            (I.pointLength = v),
            (I.spotLength = g),
            (I.rectAreaLength = p),
            (I.hemiLength = _),
            (I.numDirectionalShadows = y),
            (I.numPointShadows = w),
            (I.numSpotShadows = A),
            (i.version = Ux++));
    }
    function c(h, u) {
        let d = 0,
            f = 0,
            m = 0,
            x = 0,
            v = 0,
            g = u.matrixWorldInverse;
        for (let p = 0, _ = h.length; p < _; p++) {
            let y = h[p];
            if (y.isDirectionalLight) {
                let w = i.directional[d];
                w.direction.setFromMatrixPosition(y.matrixWorld),
                    s.setFromMatrixPosition(y.target.matrixWorld),
                    w.direction.sub(s),
                    w.direction.transformDirection(g),
                    d++;
            } else if (y.isSpotLight) {
                let w = i.spot[m];
                w.position.setFromMatrixPosition(y.matrixWorld),
                    w.position.applyMatrix4(g),
                    w.direction.setFromMatrixPosition(y.matrixWorld),
                    s.setFromMatrixPosition(y.target.matrixWorld),
                    w.direction.sub(s),
                    w.direction.transformDirection(g),
                    m++;
            } else if (y.isRectAreaLight) {
                let w = i.rectArea[x];
                w.position.setFromMatrixPosition(y.matrixWorld),
                    w.position.applyMatrix4(g),
                    a.identity(),
                    o.copy(y.matrixWorld),
                    o.premultiply(g),
                    a.extractRotation(o),
                    w.halfWidth.set(y.width * 0.5, 0, 0),
                    w.halfHeight.set(0, y.height * 0.5, 0),
                    w.halfWidth.applyMatrix4(a),
                    w.halfHeight.applyMatrix4(a),
                    x++;
            } else if (y.isPointLight) {
                let w = i.point[f];
                w.position.setFromMatrixPosition(y.matrixWorld),
                    w.position.applyMatrix4(g),
                    f++;
            } else if (y.isHemisphereLight) {
                let w = i.hemi[v];
                w.direction.setFromMatrixPosition(y.matrixWorld),
                    w.direction.transformDirection(g),
                    w.direction.normalize(),
                    v++;
            }
        }
    }
    return { setup: l, setupView: c, state: i };
}
function kc(r, e) {
    let t = new Hx(r, e),
        n = [],
        i = [];
    function s() {
        (n.length = 0), (i.length = 0);
    }
    function o(u) {
        n.push(u);
    }
    function a(u) {
        i.push(u);
    }
    function l(u) {
        t.setup(n, u);
    }
    function c(u) {
        t.setupView(n, u);
    }
    return {
        init: s,
        state: { lightsArray: n, shadowsArray: i, lights: t },
        setupLights: l,
        setupLightsView: c,
        pushLight: o,
        pushShadow: a,
    };
}
function kx(r, e) {
    let t = new WeakMap();
    function n(s, o = 0) {
        let a;
        return (
            t.has(s) === !1
                ? ((a = new kc(r, e)), t.set(s, [a]))
                : o >= t.get(s).length
                ? ((a = new kc(r, e)), t.get(s).push(a))
                : (a = t.get(s)[o]),
            a
        );
    }
    function i() {
        t = new WeakMap();
    }
    return { get: n, dispose: i };
}
var Ls = class extends ct {
    constructor(e) {
        super(),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = tf),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
        );
    }
};
Ls.prototype.isMeshDepthMaterial = !0;
var Ps = class extends ct {
    constructor(e) {
        super(),
            (this.type = "MeshDistanceMaterial"),
            (this.referencePosition = new M()),
            (this.nearDistance = 1),
            (this.farDistance = 1e3),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.fog = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            (this.nearDistance = e.nearDistance),
            (this.farDistance = e.farDistance),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
        );
    }
};
Ps.prototype.isMeshDistanceMaterial = !0;
var Vx = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    Gx = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function yu(r, e, t) {
    let n = new Ni(),
        i = new W(),
        s = new W(),
        o = new Ve(),
        a = new Ls({ depthPacking: nf }),
        l = new Ps(),
        c = {},
        h = t.maxTextureSize,
        u = { 0: it, 1: Ci, 2: Li },
        d = new Zt({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new W() },
                radius: { value: 4 },
            },
            vertexShader: Vx,
            fragmentShader: Gx,
        }),
        f = d.clone();
    f.defines.HORIZONTAL_PASS = 1;
    let m = new _e();
    m.setAttribute(
        "position",
        new ze(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    let x = new nt(m, d),
        v = this;
    (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = jh),
        (this.render = function (y, w, A) {
            if (
                v.enabled === !1 ||
                (v.autoUpdate === !1 && v.needsUpdate === !1) ||
                y.length === 0
            )
                return;
            let C = r.getRenderTarget(),
                I = r.getActiveCubeFace(),
                k = r.getActiveMipmapLevel(),
                z = r.state;
            z.setBlending(Mn),
                z.buffers.color.setClear(1, 1, 1, 1),
                z.buffers.depth.setTest(!0),
                z.setScissorTest(!1);
            for (let P = 0, b = y.length; P < b; P++) {
                let E = y[P],
                    D = E.shadow;
                if (D === void 0) {
                    console.warn("THREE.WebGLShadowMap:", E, "has no shadow.");
                    continue;
                }
                if (D.autoUpdate === !1 && D.needsUpdate === !1) continue;
                i.copy(D.mapSize);
                let U = D.getFrameExtents();
                if (
                    (i.multiply(U),
                    s.copy(D.mapSize),
                    (i.x > h || i.y > h) &&
                        (i.x > h &&
                            ((s.x = Math.floor(h / U.x)),
                            (i.x = s.x * U.x),
                            (D.mapSize.x = s.x)),
                        i.y > h &&
                            ((s.y = Math.floor(h / U.y)),
                            (i.y = s.y * U.y),
                            (D.mapSize.y = s.y))),
                    D.map === null && !D.isPointLightShadow && this.type === us)
                ) {
                    let O = { minFilter: tt, magFilter: tt, format: lt };
                    (D.map = new St(i.x, i.y, O)),
                        (D.map.texture.name = E.name + ".shadowMap"),
                        (D.mapPass = new St(i.x, i.y, O)),
                        D.camera.updateProjectionMatrix();
                }
                if (D.map === null) {
                    let O = { minFilter: st, magFilter: st, format: lt };
                    (D.map = new St(i.x, i.y, O)),
                        (D.map.texture.name = E.name + ".shadowMap"),
                        D.camera.updateProjectionMatrix();
                }
                r.setRenderTarget(D.map), r.clear();
                let F = D.getViewportCount();
                for (let O = 0; O < F; O++) {
                    let ne = D.getViewport(O);
                    o.set(s.x * ne.x, s.y * ne.y, s.x * ne.z, s.y * ne.w),
                        z.viewport(o),
                        D.updateMatrices(E, O),
                        (n = D.getFrustum()),
                        _(w, A, D.camera, E, this.type);
                }
                !D.isPointLightShadow && this.type === us && g(D, A),
                    (D.needsUpdate = !1);
            }
            (v.needsUpdate = !1), r.setRenderTarget(C, I, k);
        });
    function g(y, w) {
        let A = e.update(x);
        d.defines.VSM_SAMPLES !== y.blurSamples &&
            ((d.defines.VSM_SAMPLES = y.blurSamples),
            (f.defines.VSM_SAMPLES = y.blurSamples),
            (d.needsUpdate = !0),
            (f.needsUpdate = !0)),
            (d.uniforms.shadow_pass.value = y.map.texture),
            (d.uniforms.resolution.value = y.mapSize),
            (d.uniforms.radius.value = y.radius),
            r.setRenderTarget(y.mapPass),
            r.clear(),
            r.renderBufferDirect(w, null, A, d, x, null),
            (f.uniforms.shadow_pass.value = y.mapPass.texture),
            (f.uniforms.resolution.value = y.mapSize),
            (f.uniforms.radius.value = y.radius),
            r.setRenderTarget(y.map),
            r.clear(),
            r.renderBufferDirect(w, null, A, f, x, null);
    }
    function p(y, w, A, C, I, k, z) {
        let P = null,
            b =
                C.isPointLight === !0
                    ? y.customDistanceMaterial
                    : y.customDepthMaterial;
        if (
            (b !== void 0 ? (P = b) : (P = C.isPointLight === !0 ? l : a),
            (r.localClippingEnabled &&
                A.clipShadows === !0 &&
                A.clippingPlanes.length !== 0) ||
                (A.displacementMap && A.displacementScale !== 0) ||
                (A.alphaMap && A.alphaTest > 0))
        ) {
            let E = P.uuid,
                D = A.uuid,
                U = c[E];
            U === void 0 && ((U = {}), (c[E] = U));
            let F = U[D];
            F === void 0 && ((F = P.clone()), (U[D] = F)), (P = F);
        }
        return (
            (P.visible = A.visible),
            (P.wireframe = A.wireframe),
            z === us
                ? (P.side = A.shadowSide !== null ? A.shadowSide : A.side)
                : (P.side = A.shadowSide !== null ? A.shadowSide : u[A.side]),
            (P.alphaMap = A.alphaMap),
            (P.alphaTest = A.alphaTest),
            (P.clipShadows = A.clipShadows),
            (P.clippingPlanes = A.clippingPlanes),
            (P.clipIntersection = A.clipIntersection),
            (P.displacementMap = A.displacementMap),
            (P.displacementScale = A.displacementScale),
            (P.displacementBias = A.displacementBias),
            (P.wireframeLinewidth = A.wireframeLinewidth),
            (P.linewidth = A.linewidth),
            C.isPointLight === !0 &&
                P.isMeshDistanceMaterial === !0 &&
                (P.referencePosition.setFromMatrixPosition(C.matrixWorld),
                (P.nearDistance = I),
                (P.farDistance = k)),
            P
        );
    }
    function _(y, w, A, C, I) {
        if (y.visible === !1) return;
        if (
            y.layers.test(w.layers) &&
            (y.isMesh || y.isLine || y.isPoints) &&
            (y.castShadow || (y.receiveShadow && I === us)) &&
            (!y.frustumCulled || n.intersectsObject(y))
        ) {
            y.modelViewMatrix.multiplyMatrices(
                A.matrixWorldInverse,
                y.matrixWorld
            );
            let P = e.update(y),
                b = y.material;
            if (Array.isArray(b)) {
                let E = P.groups;
                for (let D = 0, U = E.length; D < U; D++) {
                    let F = E[D],
                        O = b[F.materialIndex];
                    if (O && O.visible) {
                        let ne = p(y, P, O, C, A.near, A.far, I);
                        r.renderBufferDirect(A, null, P, ne, y, F);
                    }
                }
            } else if (b.visible) {
                let E = p(y, P, b, C, A.near, A.far, I);
                r.renderBufferDirect(A, null, P, E, y, null);
            }
        }
        let z = y.children;
        for (let P = 0, b = z.length; P < b; P++) _(z[P], w, A, C, I);
    }
}
function Wx(r, e, t) {
    let n = t.isWebGL2;
    function i() {
        let L = !1,
            ee = new Ve(),
            Q = null,
            Ee = new Ve(0, 0, 0, 0);
        return {
            setMask: function (pe) {
                Q !== pe && !L && (r.colorMask(pe, pe, pe, pe), (Q = pe));
            },
            setLocked: function (pe) {
                L = pe;
            },
            setClear: function (pe, Le, ae, Ce, Xe) {
                Xe === !0 && ((pe *= Ce), (Le *= Ce), (ae *= Ce)),
                    ee.set(pe, Le, ae, Ce),
                    Ee.equals(ee) === !1 &&
                        (r.clearColor(pe, Le, ae, Ce), Ee.copy(ee));
            },
            reset: function () {
                (L = !1), (Q = null), Ee.set(-1, 0, 0, 0);
            },
        };
    }
    function s() {
        let L = !1,
            ee = null,
            Q = null,
            Ee = null;
        return {
            setTest: function (pe) {
                pe ? le(2929) : fe(2929);
            },
            setMask: function (pe) {
                ee !== pe && !L && (r.depthMask(pe), (ee = pe));
            },
            setFunc: function (pe) {
                if (Q !== pe) {
                    if (pe)
                        switch (pe) {
                            case Xu:
                                r.depthFunc(512);
                                break;
                            case Ju:
                                r.depthFunc(519);
                                break;
                            case Yu:
                                r.depthFunc(513);
                                break;
                            case Pa:
                                r.depthFunc(515);
                                break;
                            case Zu:
                                r.depthFunc(514);
                                break;
                            case $u:
                                r.depthFunc(518);
                                break;
                            case ju:
                                r.depthFunc(516);
                                break;
                            case Qu:
                                r.depthFunc(517);
                                break;
                            default:
                                r.depthFunc(515);
                        }
                    else r.depthFunc(515);
                    Q = pe;
                }
            },
            setLocked: function (pe) {
                L = pe;
            },
            setClear: function (pe) {
                Ee !== pe && (r.clearDepth(pe), (Ee = pe));
            },
            reset: function () {
                (L = !1), (ee = null), (Q = null), (Ee = null);
            },
        };
    }
    function o() {
        let L = !1,
            ee = null,
            Q = null,
            Ee = null,
            pe = null,
            Le = null,
            ae = null,
            Ce = null,
            Xe = null;
        return {
            setTest: function (Ge) {
                L || (Ge ? le(2960) : fe(2960));
            },
            setMask: function (Ge) {
                ee !== Ge && !L && (r.stencilMask(Ge), (ee = Ge));
            },
            setFunc: function (Ge, kt, Vt) {
                (Q !== Ge || Ee !== kt || pe !== Vt) &&
                    (r.stencilFunc(Ge, kt, Vt), (Q = Ge), (Ee = kt), (pe = Vt));
            },
            setOp: function (Ge, kt, Vt) {
                (Le !== Ge || ae !== kt || Ce !== Vt) &&
                    (r.stencilOp(Ge, kt, Vt), (Le = Ge), (ae = kt), (Ce = Vt));
            },
            setLocked: function (Ge) {
                L = Ge;
            },
            setClear: function (Ge) {
                Xe !== Ge && (r.clearStencil(Ge), (Xe = Ge));
            },
            reset: function () {
                (L = !1),
                    (ee = null),
                    (Q = null),
                    (Ee = null),
                    (pe = null),
                    (Le = null),
                    (ae = null),
                    (Ce = null),
                    (Xe = null);
            },
        };
    }
    let a = new i(),
        l = new s(),
        c = new o(),
        h = {},
        u = {},
        d = null,
        f = !1,
        m = null,
        x = null,
        v = null,
        g = null,
        p = null,
        _ = null,
        y = null,
        w = !1,
        A = null,
        C = null,
        I = null,
        k = null,
        z = null,
        P = r.getParameter(35661),
        b = !1,
        E = 0,
        D = r.getParameter(7938);
    D.indexOf("WebGL") !== -1
        ? ((E = parseFloat(/^WebGL (\d)/.exec(D)[1])), (b = E >= 1))
        : D.indexOf("OpenGL ES") !== -1 &&
          ((E = parseFloat(/^OpenGL ES (\d)/.exec(D)[1])), (b = E >= 2));
    let U = null,
        F = {},
        O = r.getParameter(3088),
        ne = r.getParameter(2978),
        ce = new Ve().fromArray(O),
        G = new Ve().fromArray(ne);
    function q(L, ee, Q) {
        let Ee = new Uint8Array(4),
            pe = r.createTexture();
        r.bindTexture(L, pe),
            r.texParameteri(L, 10241, 9728),
            r.texParameteri(L, 10240, 9728);
        for (let Le = 0; Le < Q; Le++)
            r.texImage2D(ee + Le, 0, 6408, 1, 1, 0, 6408, 5121, Ee);
        return pe;
    }
    let he = {};
    (he[3553] = q(3553, 3553, 1)),
        (he[34067] = q(34067, 34069, 6)),
        a.setClear(0, 0, 0, 1),
        l.setClear(1),
        c.setClear(0),
        le(2929),
        l.setFunc(Pa),
        Oe(!1),
        V(Xl),
        le(2884),
        ge(Mn);
    function le(L) {
        h[L] !== !0 && (r.enable(L), (h[L] = !0));
    }
    function fe(L) {
        h[L] !== !1 && (r.disable(L), (h[L] = !1));
    }
    function Ne(L, ee) {
        return u[L] !== ee
            ? (r.bindFramebuffer(L, ee),
              (u[L] = ee),
              n &&
                  (L === 36009 && (u[36160] = ee),
                  L === 36160 && (u[36009] = ee)),
              !0)
            : !1;
    }
    function Y(L) {
        return d !== L ? (r.useProgram(L), (d = L), !0) : !1;
    }
    let Re = { [wi]: 32774, [Nu]: 32778, [zu]: 32779 };
    if (n) (Re[$l] = 32775), (Re[jl] = 32776);
    else {
        let L = e.get("EXT_blend_minmax");
        L !== null && ((Re[$l] = L.MIN_EXT), (Re[jl] = L.MAX_EXT));
    }
    let ye = {
        [Bu]: 0,
        [Uu]: 1,
        [Ou]: 768,
        [Kh]: 770,
        [qu]: 776,
        [Gu]: 774,
        [ku]: 772,
        [Hu]: 769,
        [eu]: 771,
        [Wu]: 775,
        [Vu]: 773,
    };
    function ge(L, ee, Q, Ee, pe, Le, ae, Ce) {
        if (L === Mn) {
            f === !0 && (fe(3042), (f = !1));
            return;
        }
        if ((f === !1 && (le(3042), (f = !0)), L !== Fu)) {
            if (L !== m || Ce !== w) {
                if (
                    ((x !== wi || p !== wi) &&
                        (r.blendEquation(32774), (x = wi), (p = wi)),
                    Ce)
                )
                    switch (L) {
                        case fs:
                            r.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case Jl:
                            r.blendFunc(1, 1);
                            break;
                        case Yl:
                            r.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case Zl:
                            r.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error(
                                "THREE.WebGLState: Invalid blending: ",
                                L
                            );
                            break;
                    }
                else
                    switch (L) {
                        case fs:
                            r.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case Jl:
                            r.blendFunc(770, 1);
                            break;
                        case Yl:
                            r.blendFunc(0, 769);
                            break;
                        case Zl:
                            r.blendFunc(0, 768);
                            break;
                        default:
                            console.error(
                                "THREE.WebGLState: Invalid blending: ",
                                L
                            );
                            break;
                    }
                (v = null),
                    (g = null),
                    (_ = null),
                    (y = null),
                    (m = L),
                    (w = Ce);
            }
            return;
        }
        (pe = pe || ee),
            (Le = Le || Q),
            (ae = ae || Ee),
            (ee !== x || pe !== p) &&
                (r.blendEquationSeparate(Re[ee], Re[pe]), (x = ee), (p = pe)),
            (Q !== v || Ee !== g || Le !== _ || ae !== y) &&
                (r.blendFuncSeparate(ye[Q], ye[Ee], ye[Le], ye[ae]),
                (v = Q),
                (g = Ee),
                (_ = Le),
                (y = ae)),
            (m = L),
            (w = null);
    }
    function xe(L, ee) {
        L.side === Li ? fe(2884) : le(2884);
        let Q = L.side === it;
        ee && (Q = !Q),
            Oe(Q),
            L.blending === fs && L.transparent === !1
                ? ge(Mn)
                : ge(
                      L.blending,
                      L.blendEquation,
                      L.blendSrc,
                      L.blendDst,
                      L.blendEquationAlpha,
                      L.blendSrcAlpha,
                      L.blendDstAlpha,
                      L.premultipliedAlpha
                  ),
            l.setFunc(L.depthFunc),
            l.setTest(L.depthTest),
            l.setMask(L.depthWrite),
            a.setMask(L.colorWrite);
        let Ee = L.stencilWrite;
        c.setTest(Ee),
            Ee &&
                (c.setMask(L.stencilWriteMask),
                c.setFunc(L.stencilFunc, L.stencilRef, L.stencilFuncMask),
                c.setOp(L.stencilFail, L.stencilZFail, L.stencilZPass)),
            K(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits),
            L.alphaToCoverage === !0 ? le(32926) : fe(32926);
    }
    function Oe(L) {
        A !== L && (L ? r.frontFace(2304) : r.frontFace(2305), (A = L));
    }
    function V(L) {
        L !== Pu
            ? (le(2884),
              L !== C &&
                  (L === Xl
                      ? r.cullFace(1029)
                      : L === Iu
                      ? r.cullFace(1028)
                      : r.cullFace(1032)))
            : fe(2884),
            (C = L);
    }
    function j(L) {
        L !== I && (b && r.lineWidth(L), (I = L));
    }
    function K(L, ee, Q) {
        L
            ? (le(32823),
              (k !== ee || z !== Q) &&
                  (r.polygonOffset(ee, Q), (k = ee), (z = Q)))
            : fe(32823);
    }
    function ue(L) {
        L ? le(3089) : fe(3089);
    }
    function oe(L) {
        L === void 0 && (L = 33984 + P - 1),
            U !== L && (r.activeTexture(L), (U = L));
    }
    function Se(L, ee) {
        U === null && oe();
        let Q = F[U];
        Q === void 0 && ((Q = { type: void 0, texture: void 0 }), (F[U] = Q)),
            (Q.type !== L || Q.texture !== ee) &&
                (r.bindTexture(L, ee || he[L]), (Q.type = L), (Q.texture = ee));
    }
    function Te() {
        let L = F[U];
        L !== void 0 &&
            L.type !== void 0 &&
            (r.bindTexture(L.type, null),
            (L.type = void 0),
            (L.texture = void 0));
    }
    function Pe() {
        try {
            r.compressedTexImage2D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function Ye() {
        try {
            r.texSubImage2D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function R() {
        try {
            r.texSubImage3D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function T() {
        try {
            r.compressedTexSubImage2D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function J() {
        try {
            r.texStorage2D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function $() {
        try {
            r.texStorage3D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function se() {
        try {
            r.texImage2D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function Z() {
        try {
            r.texImage3D.apply(r, arguments);
        } catch (L) {
            console.error("THREE.WebGLState:", L);
        }
    }
    function Me(L) {
        ce.equals(L) === !1 && (r.scissor(L.x, L.y, L.z, L.w), ce.copy(L));
    }
    function ve(L) {
        G.equals(L) === !1 && (r.viewport(L.x, L.y, L.z, L.w), G.copy(L));
    }
    function te() {
        r.disable(3042),
            r.disable(2884),
            r.disable(2929),
            r.disable(32823),
            r.disable(3089),
            r.disable(2960),
            r.disable(32926),
            r.blendEquation(32774),
            r.blendFunc(1, 0),
            r.blendFuncSeparate(1, 0, 1, 0),
            r.colorMask(!0, !0, !0, !0),
            r.clearColor(0, 0, 0, 0),
            r.depthMask(!0),
            r.depthFunc(513),
            r.clearDepth(1),
            r.stencilMask(4294967295),
            r.stencilFunc(519, 0, 4294967295),
            r.stencilOp(7680, 7680, 7680),
            r.clearStencil(0),
            r.cullFace(1029),
            r.frontFace(2305),
            r.polygonOffset(0, 0),
            r.activeTexture(33984),
            r.bindFramebuffer(36160, null),
            n === !0 &&
                (r.bindFramebuffer(36009, null),
                r.bindFramebuffer(36008, null)),
            r.useProgram(null),
            r.lineWidth(1),
            r.scissor(0, 0, r.canvas.width, r.canvas.height),
            r.viewport(0, 0, r.canvas.width, r.canvas.height),
            (h = {}),
            (U = null),
            (F = {}),
            (u = {}),
            (d = null),
            (f = !1),
            (m = null),
            (x = null),
            (v = null),
            (g = null),
            (p = null),
            (_ = null),
            (y = null),
            (w = !1),
            (A = null),
            (C = null),
            (I = null),
            (k = null),
            (z = null),
            ce.set(0, 0, r.canvas.width, r.canvas.height),
            G.set(0, 0, r.canvas.width, r.canvas.height),
            a.reset(),
            l.reset(),
            c.reset();
    }
    return {
        buffers: { color: a, depth: l, stencil: c },
        enable: le,
        disable: fe,
        bindFramebuffer: Ne,
        useProgram: Y,
        setBlending: ge,
        setMaterial: xe,
        setFlipSided: Oe,
        setCullFace: V,
        setLineWidth: j,
        setPolygonOffset: K,
        setScissorTest: ue,
        activeTexture: oe,
        bindTexture: Se,
        unbindTexture: Te,
        compressedTexImage2D: Pe,
        texImage2D: se,
        texImage3D: Z,
        texStorage2D: J,
        texStorage3D: $,
        texSubImage2D: Ye,
        texSubImage3D: R,
        compressedTexSubImage2D: T,
        scissor: Me,
        viewport: ve,
        reset: te,
    };
}
function qx(r, e, t, n, i, s, o) {
    let a = i.isWebGL2,
        l = i.maxTextures,
        c = i.maxCubemapSize,
        h = i.maxTextureSize,
        u = i.maxSamples,
        f = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : void 0,
        m = new WeakMap(),
        x,
        v = !1;
    try {
        v =
            typeof OffscreenCanvas < "u" &&
            new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch {}
    function g(R, T) {
        return v ? new OffscreenCanvas(R, T) : qo("canvas");
    }
    function p(R, T, J, $) {
        let se = 1;
        if (
            ((R.width > $ || R.height > $) &&
                (se = $ / Math.max(R.width, R.height)),
            se < 1 || T === !0)
        )
            if (
                (typeof HTMLImageElement < "u" &&
                    R instanceof HTMLImageElement) ||
                (typeof HTMLCanvasElement < "u" &&
                    R instanceof HTMLCanvasElement) ||
                (typeof ImageBitmap < "u" && R instanceof ImageBitmap)
            ) {
                let Z = T ? su : Math.floor,
                    Me = Z(se * R.width),
                    ve = Z(se * R.height);
                x === void 0 && (x = g(Me, ve));
                let te = J ? g(Me, ve) : x;
                return (
                    (te.width = Me),
                    (te.height = ve),
                    te.getContext("2d").drawImage(R, 0, 0, Me, ve),
                    console.warn(
                        "THREE.WebGLRenderer: Texture has been resized from (" +
                            R.width +
                            "x" +
                            R.height +
                            ") to (" +
                            Me +
                            "x" +
                            ve +
                            ")."
                    ),
                    te
                );
            } else
                return (
                    "data" in R &&
                        console.warn(
                            "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                                R.width +
                                "x" +
                                R.height +
                                ")."
                        ),
                    R
                );
        return R;
    }
    function _(R) {
        return Fa(R.width) && Fa(R.height);
    }
    function y(R) {
        return a
            ? !1
            : R.wrapS !== yt ||
                  R.wrapT !== yt ||
                  (R.minFilter !== st && R.minFilter !== tt);
    }
    function w(R, T) {
        return (
            R.generateMipmaps && T && R.minFilter !== st && R.minFilter !== tt
        );
    }
    function A(R) {
        r.generateMipmap(R);
    }
    function C(R, T, J, $) {
        if (a === !1) return T;
        if (R !== null) {
            if (r[R] !== void 0) return r[R];
            console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                    R +
                    "'"
            );
        }
        let se = T;
        return (
            T === 6403 &&
                (J === 5126 && (se = 33326),
                J === 5131 && (se = 33325),
                J === 5121 && (se = 33321)),
            T === 6407 &&
                (J === 5126 && (se = 34837),
                J === 5131 && (se = 34843),
                J === 5121 && (se = 32849)),
            T === 6408 &&
                (J === 5126 && (se = 34836),
                J === 5131 && (se = 34842),
                J === 5121 && (se = $ === ji ? 35907 : 32856)),
            (se === 33325 || se === 33326 || se === 34842 || se === 34836) &&
                e.get("EXT_color_buffer_float"),
            se
        );
    }
    function I(R, T, J) {
        return w(R, J) === !0 ||
            (R.isFramebufferTexture && R.minFilter !== st && R.minFilter !== tt)
            ? Math.log2(Math.max(T.width, T.height)) + 1
            : R.mipmaps !== void 0 && R.mipmaps.length > 0
            ? R.mipmaps.length
            : R.isCompressedTexture && Array.isArray(R.image)
            ? T.mipmaps.length
            : 1;
    }
    function k(R) {
        return R === st || R === Ia || R === Da ? 9728 : 9729;
    }
    function z(R) {
        let T = R.target;
        T.removeEventListener("dispose", z),
            b(T),
            T.isVideoTexture && m.delete(T),
            o.memory.textures--;
    }
    function P(R) {
        let T = R.target;
        T.removeEventListener("dispose", P), E(T);
    }
    function b(R) {
        let T = n.get(R);
        T.__webglInit !== void 0 &&
            (r.deleteTexture(T.__webglTexture), n.remove(R));
    }
    function E(R) {
        let T = R.texture,
            J = n.get(R),
            $ = n.get(T);
        if (R) {
            if (
                ($.__webglTexture !== void 0 &&
                    (r.deleteTexture($.__webglTexture), o.memory.textures--),
                R.depthTexture && R.depthTexture.dispose(),
                R.isWebGLCubeRenderTarget)
            )
                for (let se = 0; se < 6; se++)
                    r.deleteFramebuffer(J.__webglFramebuffer[se]),
                        J.__webglDepthbuffer &&
                            r.deleteRenderbuffer(J.__webglDepthbuffer[se]);
            else
                r.deleteFramebuffer(J.__webglFramebuffer),
                    J.__webglDepthbuffer &&
                        r.deleteRenderbuffer(J.__webglDepthbuffer),
                    J.__webglMultisampledFramebuffer &&
                        r.deleteFramebuffer(J.__webglMultisampledFramebuffer),
                    J.__webglColorRenderbuffer &&
                        r.deleteRenderbuffer(J.__webglColorRenderbuffer),
                    J.__webglDepthRenderbuffer &&
                        r.deleteRenderbuffer(J.__webglDepthRenderbuffer);
            if (R.isWebGLMultipleRenderTargets)
                for (let se = 0, Z = T.length; se < Z; se++) {
                    let Me = n.get(T[se]);
                    Me.__webglTexture &&
                        (r.deleteTexture(Me.__webglTexture),
                        o.memory.textures--),
                        n.remove(T[se]);
                }
            n.remove(T), n.remove(R);
        }
    }
    let D = 0;
    function U() {
        D = 0;
    }
    function F() {
        let R = D;
        return (
            R >= l &&
                console.warn(
                    "THREE.WebGLTextures: Trying to use " +
                        R +
                        " texture units while this GPU supports only " +
                        l
                ),
            (D += 1),
            R
        );
    }
    function O(R, T) {
        let J = n.get(R);
        if (
            (R.isVideoTexture && oe(R),
            R.version > 0 && J.__version !== R.version)
        ) {
            let $ = R.image;
            if ($ === void 0)
                console.warn(
                    "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                );
            else if ($.complete === !1)
                console.warn(
                    "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
            else {
                Ne(J, R, T);
                return;
            }
        }
        t.activeTexture(33984 + T), t.bindTexture(3553, J.__webglTexture);
    }
    function ne(R, T) {
        let J = n.get(R);
        if (R.version > 0 && J.__version !== R.version) {
            Ne(J, R, T);
            return;
        }
        t.activeTexture(33984 + T), t.bindTexture(35866, J.__webglTexture);
    }
    function ce(R, T) {
        let J = n.get(R);
        if (R.version > 0 && J.__version !== R.version) {
            Ne(J, R, T);
            return;
        }
        t.activeTexture(33984 + T), t.bindTexture(32879, J.__webglTexture);
    }
    function G(R, T) {
        let J = n.get(R);
        if (R.version > 0 && J.__version !== R.version) {
            Y(J, R, T);
            return;
        }
        t.activeTexture(33984 + T), t.bindTexture(34067, J.__webglTexture);
    }
    let q = { [qr]: 10497, [yt]: 33071, [Xr]: 33648 },
        he = {
            [st]: 9728,
            [Ia]: 9984,
            [Da]: 9986,
            [tt]: 9729,
            [tu]: 9985,
            [$i]: 9987,
        };
    function le(R, T, J) {
        if (
            (J
                ? (r.texParameteri(R, 10242, q[T.wrapS]),
                  r.texParameteri(R, 10243, q[T.wrapT]),
                  (R === 32879 || R === 35866) &&
                      r.texParameteri(R, 32882, q[T.wrapR]),
                  r.texParameteri(R, 10240, he[T.magFilter]),
                  r.texParameteri(R, 10241, he[T.minFilter]))
                : (r.texParameteri(R, 10242, 33071),
                  r.texParameteri(R, 10243, 33071),
                  (R === 32879 || R === 35866) &&
                      r.texParameteri(R, 32882, 33071),
                  (T.wrapS !== yt || T.wrapT !== yt) &&
                      console.warn(
                          "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                      ),
                  r.texParameteri(R, 10240, k(T.magFilter)),
                  r.texParameteri(R, 10241, k(T.minFilter)),
                  T.minFilter !== st &&
                      T.minFilter !== tt &&
                      console.warn(
                          "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                      )),
            e.has("EXT_texture_filter_anisotropic") === !0)
        ) {
            let $ = e.get("EXT_texture_filter_anisotropic");
            if (
                (T.type === on && e.has("OES_texture_float_linear") === !1) ||
                (a === !1 &&
                    T.type === Xn &&
                    e.has("OES_texture_half_float_linear") === !1)
            )
                return;
            (T.anisotropy > 1 || n.get(T).__currentAnisotropy) &&
                (r.texParameterf(
                    R,
                    $.TEXTURE_MAX_ANISOTROPY_EXT,
                    Math.min(T.anisotropy, i.getMaxAnisotropy())
                ),
                (n.get(T).__currentAnisotropy = T.anisotropy));
        }
    }
    function fe(R, T) {
        R.__webglInit === void 0 &&
            ((R.__webglInit = !0),
            T.addEventListener("dispose", z),
            (R.__webglTexture = r.createTexture()),
            o.memory.textures++);
    }
    function Ne(R, T, J) {
        let $ = 3553;
        T.isDataTexture2DArray && ($ = 35866),
            T.isDataTexture3D && ($ = 32879),
            fe(R, T),
            t.activeTexture(33984 + J),
            t.bindTexture($, R.__webglTexture),
            r.pixelStorei(37440, T.flipY),
            r.pixelStorei(37441, T.premultiplyAlpha),
            r.pixelStorei(3317, T.unpackAlignment),
            r.pixelStorei(37443, 0);
        let se = y(T) && _(T.image) === !1,
            Z = p(T.image, se, !1, h),
            Me = _(Z) || a,
            ve = s.convert(T.format),
            te = s.convert(T.type),
            L = C(T.internalFormat, ve, te, T.encoding);
        le($, T, Me);
        let ee,
            Q = T.mipmaps,
            Ee = a && T.isVideoTexture !== !0,
            pe = R.__version === void 0,
            Le = I(T, Z, Me);
        if (T.isDepthTexture)
            (L = 6402),
                a
                    ? T.type === on
                        ? (L = 36012)
                        : T.type === Vr
                        ? (L = 33190)
                        : T.type === Ai
                        ? (L = 35056)
                        : (L = 33189)
                    : T.type === on &&
                      console.error(
                          "WebGLRenderer: Floating point depth texture requires WebGL2."
                      ),
                T.format === Yn &&
                    L === 6402 &&
                    T.type !== ys &&
                    T.type !== Vr &&
                    (console.warn(
                        "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                    ),
                    (T.type = ys),
                    (te = s.convert(T.type))),
                T.format === Pi &&
                    L === 6402 &&
                    ((L = 34041),
                    T.type !== Ai &&
                        (console.warn(
                            "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                        ),
                        (T.type = Ai),
                        (te = s.convert(T.type)))),
                Ee && pe
                    ? t.texStorage2D(3553, 1, L, Z.width, Z.height)
                    : t.texImage2D(
                          3553,
                          0,
                          L,
                          Z.width,
                          Z.height,
                          0,
                          ve,
                          te,
                          null
                      );
        else if (T.isDataTexture)
            if (Q.length > 0 && Me) {
                Ee &&
                    pe &&
                    t.texStorage2D(3553, Le, L, Q[0].width, Q[0].height);
                for (let ae = 0, Ce = Q.length; ae < Ce; ae++)
                    (ee = Q[ae]),
                        Ee
                            ? t.texSubImage2D(
                                  3553,
                                  0,
                                  0,
                                  0,
                                  ee.width,
                                  ee.height,
                                  ve,
                                  te,
                                  ee.data
                              )
                            : t.texImage2D(
                                  3553,
                                  ae,
                                  L,
                                  ee.width,
                                  ee.height,
                                  0,
                                  ve,
                                  te,
                                  ee.data
                              );
                T.generateMipmaps = !1;
            } else
                Ee
                    ? (pe && t.texStorage2D(3553, Le, L, Z.width, Z.height),
                      t.texSubImage2D(
                          3553,
                          0,
                          0,
                          0,
                          Z.width,
                          Z.height,
                          ve,
                          te,
                          Z.data
                      ))
                    : t.texImage2D(
                          3553,
                          0,
                          L,
                          Z.width,
                          Z.height,
                          0,
                          ve,
                          te,
                          Z.data
                      );
        else if (T.isCompressedTexture) {
            Ee && pe && t.texStorage2D(3553, Le, L, Q[0].width, Q[0].height);
            for (let ae = 0, Ce = Q.length; ae < Ce; ae++)
                (ee = Q[ae]),
                    T.format !== lt && T.format !== Jn
                        ? ve !== null
                            ? Ee
                                ? t.compressedTexSubImage2D(
                                      3553,
                                      ae,
                                      0,
                                      0,
                                      ee.width,
                                      ee.height,
                                      ve,
                                      ee.data
                                  )
                                : t.compressedTexImage2D(
                                      3553,
                                      ae,
                                      L,
                                      ee.width,
                                      ee.height,
                                      0,
                                      ee.data
                                  )
                            : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                              )
                        : Ee
                        ? t.texSubImage2D(
                              3553,
                              ae,
                              0,
                              0,
                              ee.width,
                              ee.height,
                              ve,
                              te,
                              ee.data
                          )
                        : t.texImage2D(
                              3553,
                              ae,
                              L,
                              ee.width,
                              ee.height,
                              0,
                              ve,
                              te,
                              ee.data
                          );
        } else if (T.isDataTexture2DArray)
            Ee
                ? (pe &&
                      t.texStorage3D(35866, Le, L, Z.width, Z.height, Z.depth),
                  t.texSubImage3D(
                      35866,
                      0,
                      0,
                      0,
                      0,
                      Z.width,
                      Z.height,
                      Z.depth,
                      ve,
                      te,
                      Z.data
                  ))
                : t.texImage3D(
                      35866,
                      0,
                      L,
                      Z.width,
                      Z.height,
                      Z.depth,
                      0,
                      ve,
                      te,
                      Z.data
                  );
        else if (T.isDataTexture3D)
            Ee
                ? (pe &&
                      t.texStorage3D(32879, Le, L, Z.width, Z.height, Z.depth),
                  t.texSubImage3D(
                      32879,
                      0,
                      0,
                      0,
                      0,
                      Z.width,
                      Z.height,
                      Z.depth,
                      ve,
                      te,
                      Z.data
                  ))
                : t.texImage3D(
                      32879,
                      0,
                      L,
                      Z.width,
                      Z.height,
                      Z.depth,
                      0,
                      ve,
                      te,
                      Z.data
                  );
        else if (T.isFramebufferTexture)
            Ee && pe
                ? t.texStorage2D(3553, Le, L, Z.width, Z.height)
                : t.texImage2D(3553, 0, L, Z.width, Z.height, 0, ve, te, null);
        else if (Q.length > 0 && Me) {
            Ee && pe && t.texStorage2D(3553, Le, L, Q[0].width, Q[0].height);
            for (let ae = 0, Ce = Q.length; ae < Ce; ae++)
                (ee = Q[ae]),
                    Ee
                        ? t.texSubImage2D(3553, ae, 0, 0, ve, te, ee)
                        : t.texImage2D(3553, ae, L, ve, te, ee);
            T.generateMipmaps = !1;
        } else
            Ee
                ? (pe && t.texStorage2D(3553, Le, L, Z.width, Z.height),
                  t.texSubImage2D(3553, 0, 0, 0, ve, te, Z))
                : t.texImage2D(3553, 0, L, ve, te, Z);
        w(T, Me) && A($),
            (R.__version = T.version),
            T.onUpdate && T.onUpdate(T);
    }
    function Y(R, T, J) {
        if (T.image.length !== 6) return;
        fe(R, T),
            t.activeTexture(33984 + J),
            t.bindTexture(34067, R.__webglTexture),
            r.pixelStorei(37440, T.flipY),
            r.pixelStorei(37441, T.premultiplyAlpha),
            r.pixelStorei(3317, T.unpackAlignment),
            r.pixelStorei(37443, 0);
        let $ = T && (T.isCompressedTexture || T.image[0].isCompressedTexture),
            se = T.image[0] && T.image[0].isDataTexture,
            Z = [];
        for (let ae = 0; ae < 6; ae++)
            !$ && !se
                ? (Z[ae] = p(T.image[ae], !1, !0, c))
                : (Z[ae] = se ? T.image[ae].image : T.image[ae]);
        let Me = Z[0],
            ve = _(Me) || a,
            te = s.convert(T.format),
            L = s.convert(T.type),
            ee = C(T.internalFormat, te, L, T.encoding),
            Q = a && T.isVideoTexture !== !0,
            Ee = R.__version === void 0,
            pe = I(T, Me, ve);
        le(34067, T, ve);
        let Le;
        if ($) {
            Q && Ee && t.texStorage2D(34067, pe, ee, Me.width, Me.height);
            for (let ae = 0; ae < 6; ae++) {
                Le = Z[ae].mipmaps;
                for (let Ce = 0; Ce < Le.length; Ce++) {
                    let Xe = Le[Ce];
                    T.format !== lt && T.format !== Jn
                        ? te !== null
                            ? Q
                                ? t.compressedTexSubImage2D(
                                      34069 + ae,
                                      Ce,
                                      0,
                                      0,
                                      Xe.width,
                                      Xe.height,
                                      te,
                                      Xe.data
                                  )
                                : t.compressedTexImage2D(
                                      34069 + ae,
                                      Ce,
                                      ee,
                                      Xe.width,
                                      Xe.height,
                                      0,
                                      Xe.data
                                  )
                            : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                              )
                        : Q
                        ? t.texSubImage2D(
                              34069 + ae,
                              Ce,
                              0,
                              0,
                              Xe.width,
                              Xe.height,
                              te,
                              L,
                              Xe.data
                          )
                        : t.texImage2D(
                              34069 + ae,
                              Ce,
                              ee,
                              Xe.width,
                              Xe.height,
                              0,
                              te,
                              L,
                              Xe.data
                          );
                }
            }
        } else {
            (Le = T.mipmaps),
                Q &&
                    Ee &&
                    (Le.length > 0 && pe++,
                    t.texStorage2D(34067, pe, ee, Z[0].width, Z[0].height));
            for (let ae = 0; ae < 6; ae++)
                if (se) {
                    Q
                        ? t.texSubImage2D(
                              34069 + ae,
                              0,
                              0,
                              0,
                              Z[ae].width,
                              Z[ae].height,
                              te,
                              L,
                              Z[ae].data
                          )
                        : t.texImage2D(
                              34069 + ae,
                              0,
                              ee,
                              Z[ae].width,
                              Z[ae].height,
                              0,
                              te,
                              L,
                              Z[ae].data
                          );
                    for (let Ce = 0; Ce < Le.length; Ce++) {
                        let Ge = Le[Ce].image[ae].image;
                        Q
                            ? t.texSubImage2D(
                                  34069 + ae,
                                  Ce + 1,
                                  0,
                                  0,
                                  Ge.width,
                                  Ge.height,
                                  te,
                                  L,
                                  Ge.data
                              )
                            : t.texImage2D(
                                  34069 + ae,
                                  Ce + 1,
                                  ee,
                                  Ge.width,
                                  Ge.height,
                                  0,
                                  te,
                                  L,
                                  Ge.data
                              );
                    }
                } else {
                    Q
                        ? t.texSubImage2D(34069 + ae, 0, 0, 0, te, L, Z[ae])
                        : t.texImage2D(34069 + ae, 0, ee, te, L, Z[ae]);
                    for (let Ce = 0; Ce < Le.length; Ce++) {
                        let Xe = Le[Ce];
                        Q
                            ? t.texSubImage2D(
                                  34069 + ae,
                                  Ce + 1,
                                  0,
                                  0,
                                  te,
                                  L,
                                  Xe.image[ae]
                              )
                            : t.texImage2D(
                                  34069 + ae,
                                  Ce + 1,
                                  ee,
                                  te,
                                  L,
                                  Xe.image[ae]
                              );
                    }
                }
        }
        w(T, ve) && A(34067),
            (R.__version = T.version),
            T.onUpdate && T.onUpdate(T);
    }
    function Re(R, T, J, $, se) {
        let Z = s.convert(J.format),
            Me = s.convert(J.type),
            ve = C(J.internalFormat, Z, Me, J.encoding);
        n.get(T).__hasExternalTextures ||
            (se === 32879 || se === 35866
                ? t.texImage3D(
                      se,
                      0,
                      ve,
                      T.width,
                      T.height,
                      T.depth,
                      0,
                      Z,
                      Me,
                      null
                  )
                : t.texImage2D(se, 0, ve, T.width, T.height, 0, Z, Me, null)),
            t.bindFramebuffer(36160, R),
            T.useRenderToTexture
                ? f.framebufferTexture2DMultisampleEXT(
                      36160,
                      $,
                      se,
                      n.get(J).__webglTexture,
                      0,
                      ue(T)
                  )
                : r.framebufferTexture2D(
                      36160,
                      $,
                      se,
                      n.get(J).__webglTexture,
                      0
                  ),
            t.bindFramebuffer(36160, null);
    }
    function ye(R, T, J) {
        if ((r.bindRenderbuffer(36161, R), T.depthBuffer && !T.stencilBuffer)) {
            let $ = 33189;
            if (J || T.useRenderToTexture) {
                let se = T.depthTexture;
                se &&
                    se.isDepthTexture &&
                    (se.type === on
                        ? ($ = 36012)
                        : se.type === Vr && ($ = 33190));
                let Z = ue(T);
                T.useRenderToTexture
                    ? f.renderbufferStorageMultisampleEXT(
                          36161,
                          Z,
                          $,
                          T.width,
                          T.height
                      )
                    : r.renderbufferStorageMultisample(
                          36161,
                          Z,
                          $,
                          T.width,
                          T.height
                      );
            } else r.renderbufferStorage(36161, $, T.width, T.height);
            r.framebufferRenderbuffer(36160, 36096, 36161, R);
        } else if (T.depthBuffer && T.stencilBuffer) {
            let $ = ue(T);
            J && T.useRenderbuffer
                ? r.renderbufferStorageMultisample(
                      36161,
                      $,
                      35056,
                      T.width,
                      T.height
                  )
                : T.useRenderToTexture
                ? f.renderbufferStorageMultisampleEXT(
                      36161,
                      $,
                      35056,
                      T.width,
                      T.height
                  )
                : r.renderbufferStorage(36161, 34041, T.width, T.height),
                r.framebufferRenderbuffer(36160, 33306, 36161, R);
        } else {
            let $ =
                    T.isWebGLMultipleRenderTargets === !0
                        ? T.texture[0]
                        : T.texture,
                se = s.convert($.format),
                Z = s.convert($.type),
                Me = C($.internalFormat, se, Z, $.encoding),
                ve = ue(T);
            J && T.useRenderbuffer
                ? r.renderbufferStorageMultisample(
                      36161,
                      ve,
                      Me,
                      T.width,
                      T.height
                  )
                : T.useRenderToTexture
                ? f.renderbufferStorageMultisampleEXT(
                      36161,
                      ve,
                      Me,
                      T.width,
                      T.height
                  )
                : r.renderbufferStorage(36161, Me, T.width, T.height);
        }
        r.bindRenderbuffer(36161, null);
    }
    function ge(R, T) {
        if (T && T.isWebGLCubeRenderTarget)
            throw new Error(
                "Depth Texture with cube render targets is not supported"
            );
        if (
            (t.bindFramebuffer(36160, R),
            !(T.depthTexture && T.depthTexture.isDepthTexture))
        )
            throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
        (!n.get(T.depthTexture).__webglTexture ||
            T.depthTexture.image.width !== T.width ||
            T.depthTexture.image.height !== T.height) &&
            ((T.depthTexture.image.width = T.width),
            (T.depthTexture.image.height = T.height),
            (T.depthTexture.needsUpdate = !0)),
            O(T.depthTexture, 0);
        let $ = n.get(T.depthTexture).__webglTexture,
            se = ue(T);
        if (T.depthTexture.format === Yn)
            T.useRenderToTexture
                ? f.framebufferTexture2DMultisampleEXT(
                      36160,
                      36096,
                      3553,
                      $,
                      0,
                      se
                  )
                : r.framebufferTexture2D(36160, 36096, 3553, $, 0);
        else if (T.depthTexture.format === Pi)
            T.useRenderToTexture
                ? f.framebufferTexture2DMultisampleEXT(
                      36160,
                      33306,
                      3553,
                      $,
                      0,
                      se
                  )
                : r.framebufferTexture2D(36160, 33306, 3553, $, 0);
        else throw new Error("Unknown depthTexture format");
    }
    function xe(R) {
        let T = n.get(R),
            J = R.isWebGLCubeRenderTarget === !0;
        if (R.depthTexture && !T.__autoAllocateDepthBuffer) {
            if (J)
                throw new Error(
                    "target.depthTexture not supported in Cube render targets"
                );
            ge(T.__webglFramebuffer, R);
        } else if (J) {
            T.__webglDepthbuffer = [];
            for (let $ = 0; $ < 6; $++)
                t.bindFramebuffer(36160, T.__webglFramebuffer[$]),
                    (T.__webglDepthbuffer[$] = r.createRenderbuffer()),
                    ye(T.__webglDepthbuffer[$], R, !1);
        } else
            t.bindFramebuffer(36160, T.__webglFramebuffer),
                (T.__webglDepthbuffer = r.createRenderbuffer()),
                ye(T.__webglDepthbuffer, R, !1);
        t.bindFramebuffer(36160, null);
    }
    function Oe(R, T, J) {
        let $ = n.get(R);
        T !== void 0 && Re($.__webglFramebuffer, R, R.texture, 36064, 3553),
            J !== void 0 && xe(R);
    }
    function V(R) {
        let T = R.texture,
            J = n.get(R),
            $ = n.get(T);
        R.addEventListener("dispose", P),
            R.isWebGLMultipleRenderTargets !== !0 &&
                ($.__webglTexture === void 0 &&
                    ($.__webglTexture = r.createTexture()),
                ($.__version = T.version),
                o.memory.textures++);
        let se = R.isWebGLCubeRenderTarget === !0,
            Z = R.isWebGLMultipleRenderTargets === !0,
            Me = T.isDataTexture3D || T.isDataTexture2DArray,
            ve = _(R) || a;
        if (
            (a &&
                T.format === Jn &&
                (T.type === on || T.type === Xn) &&
                ((T.format = lt),
                console.warn(
                    "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                )),
            se)
        ) {
            J.__webglFramebuffer = [];
            for (let te = 0; te < 6; te++)
                J.__webglFramebuffer[te] = r.createFramebuffer();
        } else if (((J.__webglFramebuffer = r.createFramebuffer()), Z))
            if (i.drawBuffers) {
                let te = R.texture;
                for (let L = 0, ee = te.length; L < ee; L++) {
                    let Q = n.get(te[L]);
                    Q.__webglTexture === void 0 &&
                        ((Q.__webglTexture = r.createTexture()),
                        o.memory.textures++);
                }
            } else
                console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                );
        else if (R.useRenderbuffer)
            if (a) {
                (J.__webglMultisampledFramebuffer = r.createFramebuffer()),
                    (J.__webglColorRenderbuffer = r.createRenderbuffer()),
                    r.bindRenderbuffer(36161, J.__webglColorRenderbuffer);
                let te = s.convert(T.format),
                    L = s.convert(T.type),
                    ee = C(T.internalFormat, te, L, T.encoding),
                    Q = ue(R);
                r.renderbufferStorageMultisample(
                    36161,
                    Q,
                    ee,
                    R.width,
                    R.height
                ),
                    t.bindFramebuffer(36160, J.__webglMultisampledFramebuffer),
                    r.framebufferRenderbuffer(
                        36160,
                        36064,
                        36161,
                        J.__webglColorRenderbuffer
                    ),
                    r.bindRenderbuffer(36161, null),
                    R.depthBuffer &&
                        ((J.__webglDepthRenderbuffer = r.createRenderbuffer()),
                        ye(J.__webglDepthRenderbuffer, R, !0)),
                    t.bindFramebuffer(36160, null);
            } else
                console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
        if (se) {
            t.bindTexture(34067, $.__webglTexture), le(34067, T, ve);
            for (let te = 0; te < 6; te++)
                Re(J.__webglFramebuffer[te], R, T, 36064, 34069 + te);
            w(T, ve) && A(34067), t.unbindTexture();
        } else if (Z) {
            let te = R.texture;
            for (let L = 0, ee = te.length; L < ee; L++) {
                let Q = te[L],
                    Ee = n.get(Q);
                t.bindTexture(3553, Ee.__webglTexture),
                    le(3553, Q, ve),
                    Re(J.__webglFramebuffer, R, Q, 36064 + L, 3553),
                    w(Q, ve) && A(3553);
            }
            t.unbindTexture();
        } else {
            let te = 3553;
            Me &&
                (a
                    ? (te = T.isDataTexture3D ? 32879 : 35866)
                    : console.warn(
                          "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                      )),
                t.bindTexture(te, $.__webglTexture),
                le(te, T, ve),
                Re(J.__webglFramebuffer, R, T, 36064, te),
                w(T, ve) && A(te),
                t.unbindTexture();
        }
        R.depthBuffer && xe(R);
    }
    function j(R) {
        let T = _(R) || a,
            J = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture];
        for (let $ = 0, se = J.length; $ < se; $++) {
            let Z = J[$];
            if (w(Z, T)) {
                let Me = R.isWebGLCubeRenderTarget ? 34067 : 3553,
                    ve = n.get(Z).__webglTexture;
                t.bindTexture(Me, ve), A(Me), t.unbindTexture();
            }
        }
    }
    function K(R) {
        if (R.useRenderbuffer)
            if (a) {
                let T = R.width,
                    J = R.height,
                    $ = 16384,
                    se = [36064],
                    Z = R.stencilBuffer ? 33306 : 36096;
                R.depthBuffer && se.push(Z),
                    R.ignoreDepthForMultisampleCopy ||
                        (R.depthBuffer && ($ |= 256),
                        R.stencilBuffer && ($ |= 1024));
                let Me = n.get(R);
                t.bindFramebuffer(36008, Me.__webglMultisampledFramebuffer),
                    t.bindFramebuffer(36009, Me.__webglFramebuffer),
                    R.ignoreDepthForMultisampleCopy &&
                        (r.invalidateFramebuffer(36008, [Z]),
                        r.invalidateFramebuffer(36009, [Z])),
                    r.blitFramebuffer(0, 0, T, J, 0, 0, T, J, $, 9728),
                    r.invalidateFramebuffer(36008, se),
                    t.bindFramebuffer(36008, null),
                    t.bindFramebuffer(36009, Me.__webglMultisampledFramebuffer);
            } else
                console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                );
    }
    function ue(R) {
        return a && (R.useRenderbuffer || R.useRenderToTexture)
            ? Math.min(u, R.samples)
            : 0;
    }
    function oe(R) {
        let T = o.render.frame;
        m.get(R) !== T && (m.set(R, T), R.update());
    }
    let Se = !1,
        Te = !1;
    function Pe(R, T) {
        R &&
            R.isWebGLRenderTarget &&
            (Se === !1 &&
                (console.warn(
                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                (Se = !0)),
            (R = R.texture)),
            O(R, T);
    }
    function Ye(R, T) {
        R &&
            R.isWebGLCubeRenderTarget &&
            (Te === !1 &&
                (console.warn(
                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (Te = !0)),
            (R = R.texture)),
            G(R, T);
    }
    (this.allocateTextureUnit = F),
        (this.resetTextureUnits = U),
        (this.setTexture2D = O),
        (this.setTexture2DArray = ne),
        (this.setTexture3D = ce),
        (this.setTextureCube = G),
        (this.rebindTextures = Oe),
        (this.setupRenderTarget = V),
        (this.updateRenderTargetMipmap = j),
        (this.updateMultisampleRenderTarget = K),
        (this.setupDepthRenderbuffer = xe),
        (this.setupFrameBufferTexture = Re),
        (this.safeSetTexture2D = Pe),
        (this.safeSetTextureCube = Ye);
}
function Xx(r, e, t) {
    let n = t.isWebGL2;
    function i(s) {
        let o;
        if (s === an) return 5121;
        if (s === cd) return 32819;
        if (s === hd) return 32820;
        if (s === ud) return 33635;
        if (s === od) return 5120;
        if (s === ad) return 5122;
        if (s === ys) return 5123;
        if (s === ld) return 5124;
        if (s === Vr) return 5125;
        if (s === on) return 5126;
        if (s === Xn)
            return n
                ? 5131
                : ((o = e.get("OES_texture_half_float")),
                  o !== null ? o.HALF_FLOAT_OES : null);
        if (s === dd) return 6406;
        if (s === Jn) return 6407;
        if (s === lt) return 6408;
        if (s === fd) return 6409;
        if (s === pd) return 6410;
        if (s === Yn) return 6402;
        if (s === Pi) return 34041;
        if (s === md) return 6403;
        if (s === gd) return 36244;
        if (s === xd) return 33319;
        if (s === yd) return 33320;
        if (s === vd) return 36248;
        if (s === _d) return 36249;
        if (s === Ql || s === Kl || s === ec || s === tc)
            if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
                if (s === Ql) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === Kl) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === ec) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === tc) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        if (s === nc || s === ic || s === sc || s === rc)
            if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
                if (s === nc) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (s === ic) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (s === sc) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (s === rc) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        if (s === Md)
            return (
                (o = e.get("WEBGL_compressed_texture_etc1")),
                o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
            );
        if (
            (s === oc || s === ac) &&
            ((o = e.get("WEBGL_compressed_texture_etc")), o !== null)
        ) {
            if (s === oc) return o.COMPRESSED_RGB8_ETC2;
            if (s === ac) return o.COMPRESSED_RGBA8_ETC2_EAC;
        }
        if (
            s === wd ||
            s === bd ||
            s === Sd ||
            s === Td ||
            s === Ed ||
            s === Ad ||
            s === Rd ||
            s === Cd ||
            s === Ld ||
            s === Pd ||
            s === Id ||
            s === Dd ||
            s === Fd ||
            s === Nd ||
            s === Bd ||
            s === Ud ||
            s === Od ||
            s === Hd ||
            s === kd ||
            s === Vd ||
            s === Gd ||
            s === Wd ||
            s === qd ||
            s === Xd ||
            s === Jd ||
            s === Yd ||
            s === Zd ||
            s === $d
        )
            return (
                (o = e.get("WEBGL_compressed_texture_astc")),
                o !== null ? s : null
            );
        if (s === zd)
            return (
                (o = e.get("EXT_texture_compression_bptc")),
                o !== null ? s : null
            );
        if (s === Ai)
            return n
                ? 34042
                : ((o = e.get("WEBGL_depth_texture")),
                  o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
    }
    return { convert: i };
}
var Qr = class extends at {
    constructor(e = []) {
        super(), (this.cameras = e);
    }
};
Qr.prototype.isArrayCamera = !0;
var _n = class extends Be {
    constructor() {
        super(), (this.type = "Group");
    }
};
_n.prototype.isGroup = !0;
var Jx = { type: "move" },
    ms = class {
        constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
            return (
                this._hand === null &&
                    ((this._hand = new _n()),
                    (this._hand.matrixAutoUpdate = !1),
                    (this._hand.visible = !1),
                    (this._hand.joints = {}),
                    (this._hand.inputState = { pinching: !1 })),
                this._hand
            );
        }
        getTargetRaySpace() {
            return (
                this._targetRay === null &&
                    ((this._targetRay = new _n()),
                    (this._targetRay.matrixAutoUpdate = !1),
                    (this._targetRay.visible = !1),
                    (this._targetRay.hasLinearVelocity = !1),
                    (this._targetRay.linearVelocity = new M()),
                    (this._targetRay.hasAngularVelocity = !1),
                    (this._targetRay.angularVelocity = new M())),
                this._targetRay
            );
        }
        getGripSpace() {
            return (
                this._grip === null &&
                    ((this._grip = new _n()),
                    (this._grip.matrixAutoUpdate = !1),
                    (this._grip.visible = !1),
                    (this._grip.hasLinearVelocity = !1),
                    (this._grip.linearVelocity = new M()),
                    (this._grip.hasAngularVelocity = !1),
                    (this._grip.angularVelocity = new M())),
                this._grip
            );
        }
        dispatchEvent(e) {
            return (
                this._targetRay !== null && this._targetRay.dispatchEvent(e),
                this._grip !== null && this._grip.dispatchEvent(e),
                this._hand !== null && this._hand.dispatchEvent(e),
                this
            );
        }
        disconnect(e) {
            return (
                this.dispatchEvent({ type: "disconnected", data: e }),
                this._targetRay !== null && (this._targetRay.visible = !1),
                this._grip !== null && (this._grip.visible = !1),
                this._hand !== null && (this._hand.visible = !1),
                this
            );
        }
        update(e, t, n) {
            let i = null,
                s = null,
                o = null,
                a = this._targetRay,
                l = this._grip,
                c = this._hand;
            if (e && t.session.visibilityState !== "visible-blurred")
                if (
                    (a !== null &&
                        ((i = t.getPose(e.targetRaySpace, n)),
                        i !== null &&
                            (a.matrix.fromArray(i.transform.matrix),
                            a.matrix.decompose(a.position, a.rotation, a.scale),
                            i.linearVelocity
                                ? ((a.hasLinearVelocity = !0),
                                  a.linearVelocity.copy(i.linearVelocity))
                                : (a.hasLinearVelocity = !1),
                            i.angularVelocity
                                ? ((a.hasAngularVelocity = !0),
                                  a.angularVelocity.copy(i.angularVelocity))
                                : (a.hasAngularVelocity = !1),
                            this.dispatchEvent(Jx))),
                    c && e.hand)
                ) {
                    o = !0;
                    for (let x of e.hand.values()) {
                        let v = t.getJointPose(x, n);
                        if (c.joints[x.jointName] === void 0) {
                            let p = new _n();
                            (p.matrixAutoUpdate = !1),
                                (p.visible = !1),
                                (c.joints[x.jointName] = p),
                                c.add(p);
                        }
                        let g = c.joints[x.jointName];
                        v !== null &&
                            (g.matrix.fromArray(v.transform.matrix),
                            g.matrix.decompose(g.position, g.rotation, g.scale),
                            (g.jointRadius = v.radius)),
                            (g.visible = v !== null);
                    }
                    let h = c.joints["index-finger-tip"],
                        u = c.joints["thumb-tip"],
                        d = h.position.distanceTo(u.position),
                        f = 0.02,
                        m = 0.005;
                    c.inputState.pinching && d > f + m
                        ? ((c.inputState.pinching = !1),
                          this.dispatchEvent({
                              type: "pinchend",
                              handedness: e.handedness,
                              target: this,
                          }))
                        : !c.inputState.pinching &&
                          d <= f - m &&
                          ((c.inputState.pinching = !0),
                          this.dispatchEvent({
                              type: "pinchstart",
                              handedness: e.handedness,
                              target: this,
                          }));
                } else
                    l !== null &&
                        e.gripSpace &&
                        ((s = t.getPose(e.gripSpace, n)),
                        s !== null &&
                            (l.matrix.fromArray(s.transform.matrix),
                            l.matrix.decompose(l.position, l.rotation, l.scale),
                            s.linearVelocity
                                ? ((l.hasLinearVelocity = !0),
                                  l.linearVelocity.copy(s.linearVelocity))
                                : (l.hasLinearVelocity = !1),
                            s.angularVelocity
                                ? ((l.hasAngularVelocity = !0),
                                  l.angularVelocity.copy(s.angularVelocity))
                                : (l.hasAngularVelocity = !1)));
            return (
                a !== null && (a.visible = i !== null),
                l !== null && (l.visible = s !== null),
                c !== null && (c.visible = o !== null),
                this
            );
        }
    },
    Is = class extends ft {
        constructor(e, t, n, i, s, o, a, l, c, h) {
            if (((h = h !== void 0 ? h : Yn), h !== Yn && h !== Pi))
                throw new Error(
                    "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
                );
            n === void 0 && h === Yn && (n = ys),
                n === void 0 && h === Pi && (n = Ai),
                super(null, i, s, o, a, l, h, n, c),
                (this.image = { width: e, height: t }),
                (this.magFilter = a !== void 0 ? a : st),
                (this.minFilter = l !== void 0 ? l : st),
                (this.flipY = !1),
                (this.generateMipmaps = !1);
        }
    };
Is.prototype.isDepthTexture = !0;
var Ja = class extends cn {
    constructor(e, t) {
        super();
        let n = this,
            i = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = e.extensions.has("WEBGL_multisampled_render_to_texture"),
            c = null,
            h = null,
            u = null,
            d = null,
            f = !1,
            m = null,
            x = t.getContextAttributes(),
            v = null,
            g = null,
            p = [],
            _ = new Map(),
            y = new at();
        y.layers.enable(1), (y.viewport = new Ve());
        let w = new at();
        w.layers.enable(2), (w.viewport = new Ve());
        let A = [y, w],
            C = new Qr();
        C.layers.enable(1), C.layers.enable(2);
        let I = null,
            k = null;
        (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (G) {
                let q = p[G];
                return (
                    q === void 0 && ((q = new ms()), (p[G] = q)),
                    q.getTargetRaySpace()
                );
            }),
            (this.getControllerGrip = function (G) {
                let q = p[G];
                return (
                    q === void 0 && ((q = new ms()), (p[G] = q)),
                    q.getGripSpace()
                );
            }),
            (this.getHand = function (G) {
                let q = p[G];
                return (
                    q === void 0 && ((q = new ms()), (p[G] = q)),
                    q.getHandSpace()
                );
            });
        function z(G) {
            let q = _.get(G.inputSource);
            q && q.dispatchEvent({ type: G.type, data: G.inputSource });
        }
        function P() {
            _.forEach(function (G, q) {
                G.disconnect(q);
            }),
                _.clear(),
                (I = null),
                (k = null),
                e.setRenderTarget(v),
                (d = null),
                (u = null),
                (h = null),
                (i = null),
                (g = null),
                ce.stop(),
                (n.isPresenting = !1),
                n.dispatchEvent({ type: "sessionend" });
        }
        (this.setFramebufferScaleFactor = function (G) {
            (s = G),
                n.isPresenting === !0 &&
                    console.warn(
                        "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
        }),
            (this.setReferenceSpaceType = function (G) {
                (a = G),
                    n.isPresenting === !0 &&
                        console.warn(
                            "THREE.WebXRManager: Cannot change reference space type while presenting."
                        );
            }),
            (this.getReferenceSpace = function () {
                return o;
            }),
            (this.getBaseLayer = function () {
                return u !== null ? u : d;
            }),
            (this.getBinding = function () {
                return h;
            }),
            (this.getFrame = function () {
                return m;
            }),
            (this.getSession = function () {
                return i;
            }),
            (this.setSession = async function (G) {
                if (((i = G), i !== null)) {
                    if (
                        ((v = e.getRenderTarget()),
                        i.addEventListener("select", z),
                        i.addEventListener("selectstart", z),
                        i.addEventListener("selectend", z),
                        i.addEventListener("squeeze", z),
                        i.addEventListener("squeezestart", z),
                        i.addEventListener("squeezeend", z),
                        i.addEventListener("end", P),
                        i.addEventListener("inputsourceschange", b),
                        x.xrCompatible !== !0 && (await t.makeXRCompatible()),
                        i.renderState.layers === void 0 ||
                            e.capabilities.isWebGL2 === !1)
                    ) {
                        let q = {
                            antialias:
                                i.renderState.layers === void 0
                                    ? x.antialias
                                    : !0,
                            alpha: x.alpha,
                            depth: x.depth,
                            stencil: x.stencil,
                            framebufferScaleFactor: s,
                        };
                        (d = new XRWebGLLayer(i, t, q)),
                            i.updateRenderState({ baseLayer: d }),
                            (g = new St(
                                d.framebufferWidth,
                                d.framebufferHeight,
                                {
                                    format: lt,
                                    type: an,
                                    encoding: e.outputEncoding,
                                }
                            ));
                    } else {
                        f = x.antialias;
                        let q = null,
                            he = null,
                            le = null;
                        x.depth &&
                            ((le = x.stencil ? 35056 : 33190),
                            (q = x.stencil ? Pi : Yn),
                            (he = x.stencil ? Ai : ys));
                        let fe = {
                            colorFormat: x.alpha || f ? 32856 : 32849,
                            depthFormat: le,
                            scaleFactor: s,
                        };
                        (h = new XRWebGLBinding(i, t)),
                            (u = h.createProjectionLayer(fe)),
                            i.updateRenderState({ layers: [u] }),
                            f
                                ? (g = new ws(u.textureWidth, u.textureHeight, {
                                      format: lt,
                                      type: an,
                                      depthTexture: new Is(
                                          u.textureWidth,
                                          u.textureHeight,
                                          he,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          q
                                      ),
                                      stencilBuffer: x.stencil,
                                      ignoreDepth: u.ignoreDepthValues,
                                      useRenderToTexture: l,
                                      encoding: e.outputEncoding,
                                  }))
                                : (g = new St(u.textureWidth, u.textureHeight, {
                                      format: x.alpha ? lt : Jn,
                                      type: an,
                                      depthTexture: new Is(
                                          u.textureWidth,
                                          u.textureHeight,
                                          he,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          void 0,
                                          q
                                      ),
                                      stencilBuffer: x.stencil,
                                      ignoreDepth: u.ignoreDepthValues,
                                      encoding: e.outputEncoding,
                                  }));
                    }
                    this.setFoveation(1),
                        (o = await i.requestReferenceSpace(a)),
                        ce.setContext(i),
                        ce.start(),
                        (n.isPresenting = !0),
                        n.dispatchEvent({ type: "sessionstart" });
                }
            });
        function b(G) {
            let q = i.inputSources;
            for (let he = 0; he < p.length; he++) _.set(q[he], p[he]);
            for (let he = 0; he < G.removed.length; he++) {
                let le = G.removed[he],
                    fe = _.get(le);
                fe &&
                    (fe.dispatchEvent({ type: "disconnected", data: le }),
                    _.delete(le));
            }
            for (let he = 0; he < G.added.length; he++) {
                let le = G.added[he],
                    fe = _.get(le);
                fe && fe.dispatchEvent({ type: "connected", data: le });
            }
        }
        let E = new M(),
            D = new M();
        function U(G, q, he) {
            E.setFromMatrixPosition(q.matrixWorld),
                D.setFromMatrixPosition(he.matrixWorld);
            let le = E.distanceTo(D),
                fe = q.projectionMatrix.elements,
                Ne = he.projectionMatrix.elements,
                Y = fe[14] / (fe[10] - 1),
                Re = fe[14] / (fe[10] + 1),
                ye = (fe[9] + 1) / fe[5],
                ge = (fe[9] - 1) / fe[5],
                xe = (fe[8] - 1) / fe[0],
                Oe = (Ne[8] + 1) / Ne[0],
                V = Y * xe,
                j = Y * Oe,
                K = le / (-xe + Oe),
                ue = K * -xe;
            q.matrixWorld.decompose(G.position, G.quaternion, G.scale),
                G.translateX(ue),
                G.translateZ(K),
                G.matrixWorld.compose(G.position, G.quaternion, G.scale),
                G.matrixWorldInverse.copy(G.matrixWorld).invert();
            let oe = Y + K,
                Se = Re + K,
                Te = V - ue,
                Pe = j + (le - ue),
                Ye = ((ye * Re) / Se) * oe,
                R = ((ge * Re) / Se) * oe;
            G.projectionMatrix.makePerspective(Te, Pe, Ye, R, oe, Se);
        }
        function F(G, q) {
            q === null
                ? G.matrixWorld.copy(G.matrix)
                : G.matrixWorld.multiplyMatrices(q.matrixWorld, G.matrix),
                G.matrixWorldInverse.copy(G.matrixWorld).invert();
        }
        (this.updateCamera = function (G) {
            if (i === null) return;
            (C.near = w.near = y.near = G.near),
                (C.far = w.far = y.far = G.far),
                (I !== C.near || k !== C.far) &&
                    (i.updateRenderState({
                        depthNear: C.near,
                        depthFar: C.far,
                    }),
                    (I = C.near),
                    (k = C.far));
            let q = G.parent,
                he = C.cameras;
            F(C, q);
            for (let fe = 0; fe < he.length; fe++) F(he[fe], q);
            C.matrixWorld.decompose(C.position, C.quaternion, C.scale),
                G.position.copy(C.position),
                G.quaternion.copy(C.quaternion),
                G.scale.copy(C.scale),
                G.matrix.copy(C.matrix),
                G.matrixWorld.copy(C.matrixWorld);
            let le = G.children;
            for (let fe = 0, Ne = le.length; fe < Ne; fe++)
                le[fe].updateMatrixWorld(!0);
            he.length === 2
                ? U(C, y, w)
                : C.projectionMatrix.copy(y.projectionMatrix);
        }),
            (this.getCamera = function () {
                return C;
            }),
            (this.getFoveation = function () {
                if (u !== null) return u.fixedFoveation;
                if (d !== null) return d.fixedFoveation;
            }),
            (this.setFoveation = function (G) {
                u !== null && (u.fixedFoveation = G),
                    d !== null &&
                        d.fixedFoveation !== void 0 &&
                        (d.fixedFoveation = G);
            });
        let O = null;
        function ne(G, q) {
            if (((c = q.getViewerPose(o)), (m = q), c !== null)) {
                let le = c.views;
                d !== null &&
                    (e.setRenderTargetFramebuffer(g, d.framebuffer),
                    e.setRenderTarget(g));
                let fe = !1;
                le.length !== C.cameras.length &&
                    ((C.cameras.length = 0), (fe = !0));
                for (let Ne = 0; Ne < le.length; Ne++) {
                    let Y = le[Ne],
                        Re = null;
                    if (d !== null) Re = d.getViewport(Y);
                    else {
                        let ge = h.getViewSubImage(u, Y);
                        (Re = ge.viewport),
                            Ne === 0 &&
                                (e.setRenderTargetTextures(
                                    g,
                                    ge.colorTexture,
                                    u.ignoreDepthValues
                                        ? void 0
                                        : ge.depthStencilTexture
                                ),
                                e.setRenderTarget(g));
                    }
                    let ye = A[Ne];
                    ye.matrix.fromArray(Y.transform.matrix),
                        ye.projectionMatrix.fromArray(Y.projectionMatrix),
                        ye.viewport.set(Re.x, Re.y, Re.width, Re.height),
                        Ne === 0 && C.matrix.copy(ye.matrix),
                        fe === !0 && C.cameras.push(ye);
                }
            }
            let he = i.inputSources;
            for (let le = 0; le < p.length; le++) {
                let fe = p[le],
                    Ne = he[le];
                fe.update(Ne, q, o);
            }
            O && O(G, q), (m = null);
        }
        let ce = new au();
        ce.setAnimationLoop(ne),
            (this.setAnimationLoop = function (G) {
                O = G;
            }),
            (this.dispose = function () {});
    }
};
function Yx(r) {
    function e(g, p) {
        g.fogColor.value.copy(p.color),
            p.isFog
                ? ((g.fogNear.value = p.near), (g.fogFar.value = p.far))
                : p.isFogExp2 && (g.fogDensity.value = p.density);
    }
    function t(g, p, _, y, w) {
        p.isMeshBasicMaterial
            ? n(g, p)
            : p.isMeshLambertMaterial
            ? (n(g, p), l(g, p))
            : p.isMeshToonMaterial
            ? (n(g, p), h(g, p))
            : p.isMeshPhongMaterial
            ? (n(g, p), c(g, p))
            : p.isMeshStandardMaterial
            ? (n(g, p), p.isMeshPhysicalMaterial ? d(g, p, w) : u(g, p))
            : p.isMeshMatcapMaterial
            ? (n(g, p), f(g, p))
            : p.isMeshDepthMaterial
            ? (n(g, p), m(g, p))
            : p.isMeshDistanceMaterial
            ? (n(g, p), x(g, p))
            : p.isMeshNormalMaterial
            ? (n(g, p), v(g, p))
            : p.isLineBasicMaterial
            ? (i(g, p), p.isLineDashedMaterial && s(g, p))
            : p.isPointsMaterial
            ? o(g, p, _, y)
            : p.isSpriteMaterial
            ? a(g, p)
            : p.isShadowMaterial
            ? (g.color.value.copy(p.color), (g.opacity.value = p.opacity))
            : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
    }
    function n(g, p) {
        (g.opacity.value = p.opacity),
            p.color && g.diffuse.value.copy(p.color),
            p.emissive &&
                g.emissive.value
                    .copy(p.emissive)
                    .multiplyScalar(p.emissiveIntensity),
            p.map && (g.map.value = p.map),
            p.alphaMap && (g.alphaMap.value = p.alphaMap),
            p.specularMap && (g.specularMap.value = p.specularMap),
            p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
        let _ = r.get(p).envMap;
        _ &&
            ((g.envMap.value = _),
            (g.flipEnvMap.value =
                _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
            (g.reflectivity.value = p.reflectivity),
            (g.ior.value = p.ior),
            (g.refractionRatio.value = p.refractionRatio)),
            p.lightMap &&
                ((g.lightMap.value = p.lightMap),
                (g.lightMapIntensity.value = p.lightMapIntensity)),
            p.aoMap &&
                ((g.aoMap.value = p.aoMap),
                (g.aoMapIntensity.value = p.aoMapIntensity));
        let y;
        p.map
            ? (y = p.map)
            : p.specularMap
            ? (y = p.specularMap)
            : p.displacementMap
            ? (y = p.displacementMap)
            : p.normalMap
            ? (y = p.normalMap)
            : p.bumpMap
            ? (y = p.bumpMap)
            : p.roughnessMap
            ? (y = p.roughnessMap)
            : p.metalnessMap
            ? (y = p.metalnessMap)
            : p.alphaMap
            ? (y = p.alphaMap)
            : p.emissiveMap
            ? (y = p.emissiveMap)
            : p.clearcoatMap
            ? (y = p.clearcoatMap)
            : p.clearcoatNormalMap
            ? (y = p.clearcoatNormalMap)
            : p.clearcoatRoughnessMap
            ? (y = p.clearcoatRoughnessMap)
            : p.specularIntensityMap
            ? (y = p.specularIntensityMap)
            : p.specularColorMap
            ? (y = p.specularColorMap)
            : p.transmissionMap
            ? (y = p.transmissionMap)
            : p.thicknessMap
            ? (y = p.thicknessMap)
            : p.sheenColorMap
            ? (y = p.sheenColorMap)
            : p.sheenRoughnessMap && (y = p.sheenRoughnessMap),
            y !== void 0 &&
                (y.isWebGLRenderTarget && (y = y.texture),
                y.matrixAutoUpdate === !0 && y.updateMatrix(),
                g.uvTransform.value.copy(y.matrix));
        let w;
        p.aoMap ? (w = p.aoMap) : p.lightMap && (w = p.lightMap),
            w !== void 0 &&
                (w.isWebGLRenderTarget && (w = w.texture),
                w.matrixAutoUpdate === !0 && w.updateMatrix(),
                g.uv2Transform.value.copy(w.matrix));
    }
    function i(g, p) {
        g.diffuse.value.copy(p.color), (g.opacity.value = p.opacity);
    }
    function s(g, p) {
        (g.dashSize.value = p.dashSize),
            (g.totalSize.value = p.dashSize + p.gapSize),
            (g.scale.value = p.scale);
    }
    function o(g, p, _, y) {
        g.diffuse.value.copy(p.color),
            (g.opacity.value = p.opacity),
            (g.size.value = p.size * _),
            (g.scale.value = y * 0.5),
            p.map && (g.map.value = p.map),
            p.alphaMap && (g.alphaMap.value = p.alphaMap),
            p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
        let w;
        p.map ? (w = p.map) : p.alphaMap && (w = p.alphaMap),
            w !== void 0 &&
                (w.matrixAutoUpdate === !0 && w.updateMatrix(),
                g.uvTransform.value.copy(w.matrix));
    }
    function a(g, p) {
        g.diffuse.value.copy(p.color),
            (g.opacity.value = p.opacity),
            (g.rotation.value = p.rotation),
            p.map && (g.map.value = p.map),
            p.alphaMap && (g.alphaMap.value = p.alphaMap),
            p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
        let _;
        p.map ? (_ = p.map) : p.alphaMap && (_ = p.alphaMap),
            _ !== void 0 &&
                (_.matrixAutoUpdate === !0 && _.updateMatrix(),
                g.uvTransform.value.copy(_.matrix));
    }
    function l(g, p) {
        p.emissiveMap && (g.emissiveMap.value = p.emissiveMap);
    }
    function c(g, p) {
        g.specular.value.copy(p.specular),
            (g.shininess.value = Math.max(p.shininess, 1e-4)),
            p.emissiveMap && (g.emissiveMap.value = p.emissiveMap),
            p.bumpMap &&
                ((g.bumpMap.value = p.bumpMap),
                (g.bumpScale.value = p.bumpScale),
                p.side === it && (g.bumpScale.value *= -1)),
            p.normalMap &&
                ((g.normalMap.value = p.normalMap),
                g.normalScale.value.copy(p.normalScale),
                p.side === it && g.normalScale.value.negate()),
            p.displacementMap &&
                ((g.displacementMap.value = p.displacementMap),
                (g.displacementScale.value = p.displacementScale),
                (g.displacementBias.value = p.displacementBias));
    }
    function h(g, p) {
        p.gradientMap && (g.gradientMap.value = p.gradientMap),
            p.emissiveMap && (g.emissiveMap.value = p.emissiveMap),
            p.bumpMap &&
                ((g.bumpMap.value = p.bumpMap),
                (g.bumpScale.value = p.bumpScale),
                p.side === it && (g.bumpScale.value *= -1)),
            p.normalMap &&
                ((g.normalMap.value = p.normalMap),
                g.normalScale.value.copy(p.normalScale),
                p.side === it && g.normalScale.value.negate()),
            p.displacementMap &&
                ((g.displacementMap.value = p.displacementMap),
                (g.displacementScale.value = p.displacementScale),
                (g.displacementBias.value = p.displacementBias));
    }
    function u(g, p) {
        (g.roughness.value = p.roughness),
            (g.metalness.value = p.metalness),
            p.roughnessMap && (g.roughnessMap.value = p.roughnessMap),
            p.metalnessMap && (g.metalnessMap.value = p.metalnessMap),
            p.emissiveMap && (g.emissiveMap.value = p.emissiveMap),
            p.bumpMap &&
                ((g.bumpMap.value = p.bumpMap),
                (g.bumpScale.value = p.bumpScale),
                p.side === it && (g.bumpScale.value *= -1)),
            p.normalMap &&
                ((g.normalMap.value = p.normalMap),
                g.normalScale.value.copy(p.normalScale),
                p.side === it && g.normalScale.value.negate()),
            p.displacementMap &&
                ((g.displacementMap.value = p.displacementMap),
                (g.displacementScale.value = p.displacementScale),
                (g.displacementBias.value = p.displacementBias)),
            r.get(p).envMap && (g.envMapIntensity.value = p.envMapIntensity);
    }
    function d(g, p, _) {
        u(g, p),
            (g.ior.value = p.ior),
            p.sheen > 0 &&
                (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
                (g.sheenRoughness.value = p.sheenRoughness),
                p.sheenColorMap && (g.sheenColorMap.value = p.sheenColorMap),
                p.sheenRoughnessMap &&
                    (g.sheenRoughnessMap.value = p.sheenRoughnessMap)),
            p.clearcoat > 0 &&
                ((g.clearcoat.value = p.clearcoat),
                (g.clearcoatRoughness.value = p.clearcoatRoughness),
                p.clearcoatMap && (g.clearcoatMap.value = p.clearcoatMap),
                p.clearcoatRoughnessMap &&
                    (g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
                p.clearcoatNormalMap &&
                    (g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
                    (g.clearcoatNormalMap.value = p.clearcoatNormalMap),
                    p.side === it && g.clearcoatNormalScale.value.negate())),
            p.transmission > 0 &&
                ((g.transmission.value = p.transmission),
                (g.transmissionSamplerMap.value = _.texture),
                g.transmissionSamplerSize.value.set(_.width, _.height),
                p.transmissionMap &&
                    (g.transmissionMap.value = p.transmissionMap),
                (g.thickness.value = p.thickness),
                p.thicknessMap && (g.thicknessMap.value = p.thicknessMap),
                (g.attenuationDistance.value = p.attenuationDistance),
                g.attenuationColor.value.copy(p.attenuationColor)),
            (g.specularIntensity.value = p.specularIntensity),
            g.specularColor.value.copy(p.specularColor),
            p.specularIntensityMap &&
                (g.specularIntensityMap.value = p.specularIntensityMap),
            p.specularColorMap &&
                (g.specularColorMap.value = p.specularColorMap);
    }
    function f(g, p) {
        p.matcap && (g.matcap.value = p.matcap),
            p.bumpMap &&
                ((g.bumpMap.value = p.bumpMap),
                (g.bumpScale.value = p.bumpScale),
                p.side === it && (g.bumpScale.value *= -1)),
            p.normalMap &&
                ((g.normalMap.value = p.normalMap),
                g.normalScale.value.copy(p.normalScale),
                p.side === it && g.normalScale.value.negate()),
            p.displacementMap &&
                ((g.displacementMap.value = p.displacementMap),
                (g.displacementScale.value = p.displacementScale),
                (g.displacementBias.value = p.displacementBias));
    }
    function m(g, p) {
        p.displacementMap &&
            ((g.displacementMap.value = p.displacementMap),
            (g.displacementScale.value = p.displacementScale),
            (g.displacementBias.value = p.displacementBias));
    }
    function x(g, p) {
        p.displacementMap &&
            ((g.displacementMap.value = p.displacementMap),
            (g.displacementScale.value = p.displacementScale),
            (g.displacementBias.value = p.displacementBias)),
            g.referencePosition.value.copy(p.referencePosition),
            (g.nearDistance.value = p.nearDistance),
            (g.farDistance.value = p.farDistance);
    }
    function v(g, p) {
        p.bumpMap &&
            ((g.bumpMap.value = p.bumpMap),
            (g.bumpScale.value = p.bumpScale),
            p.side === it && (g.bumpScale.value *= -1)),
            p.normalMap &&
                ((g.normalMap.value = p.normalMap),
                g.normalScale.value.copy(p.normalScale),
                p.side === it && g.normalScale.value.negate()),
            p.displacementMap &&
                ((g.displacementMap.value = p.displacementMap),
                (g.displacementScale.value = p.displacementScale),
                (g.displacementBias.value = p.displacementBias));
    }
    return { refreshFogUniforms: e, refreshMaterialUniforms: t };
}
function Zx() {
    let r = qo("canvas");
    return (r.style.display = "block"), r;
}
function qe(r = {}) {
    let e = r.canvas !== void 0 ? r.canvas : Zx(),
        t = r.context !== void 0 ? r.context : null,
        n = r.alpha !== void 0 ? r.alpha : !1,
        i = r.depth !== void 0 ? r.depth : !0,
        s = r.stencil !== void 0 ? r.stencil : !0,
        o = r.antialias !== void 0 ? r.antialias : !1,
        a = r.premultipliedAlpha !== void 0 ? r.premultipliedAlpha : !0,
        l = r.preserveDrawingBuffer !== void 0 ? r.preserveDrawingBuffer : !1,
        c = r.powerPreference !== void 0 ? r.powerPreference : "default",
        h =
            r.failIfMajorPerformanceCaveat !== void 0
                ? r.failIfMajorPerformanceCaveat
                : !1,
        u = null,
        d = null,
        f = [],
        m = [];
    (this.domElement = e),
        (this.debug = { checkShaderErrors: !0 }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.outputEncoding = Ot),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = wn),
        (this.toneMappingExposure = 1);
    let x = this,
        v = !1,
        g = 0,
        p = 0,
        _ = null,
        y = -1,
        w = null,
        A = new Ve(),
        C = new Ve(),
        I = null,
        k = e.width,
        z = e.height,
        P = 1,
        b = null,
        E = null,
        D = new Ve(0, 0, k, z),
        U = new Ve(0, 0, k, z),
        F = !1,
        O = [],
        ne = new Ni(),
        ce = !1,
        G = !1,
        q = null,
        he = new me(),
        le = new M(),
        fe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
        };
    function Ne() {
        return _ === null ? P : 1;
    }
    let Y = t;
    function Re(S, N) {
        for (let H = 0; H < S.length; H++) {
            let B = S[H],
                X = e.getContext(B, N);
            if (X !== null) return X;
        }
        return null;
    }
    try {
        let S = {
            alpha: n,
            depth: i,
            stencil: s,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: h,
        };
        if (
            ("setAttribute" in e &&
                e.setAttribute("data-engine", `three.js r${Dl}`),
            e.addEventListener("webglcontextlost", Ee, !1),
            e.addEventListener("webglcontextrestored", pe, !1),
            Y === null)
        ) {
            let N = ["webgl2", "webgl", "experimental-webgl"];
            if (
                (x.isWebGL1Renderer === !0 && N.shift(),
                (Y = Re(N, S)),
                Y === null)
            )
                throw Re(N)
                    ? new Error(
                          "Error creating WebGL context with your selected attributes."
                      )
                    : new Error("Error creating WebGL context.");
        }
        Y.getShaderPrecisionFormat === void 0 &&
            (Y.getShaderPrecisionFormat = function () {
                return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
    } catch (S) {
        throw (console.error("THREE.WebGLRenderer: " + S.message), S);
    }
    let ye,
        ge,
        xe,
        Oe,
        V,
        j,
        K,
        ue,
        oe,
        Se,
        Te,
        Pe,
        Ye,
        R,
        T,
        J,
        $,
        se,
        Z,
        Me,
        ve,
        te,
        L;
    function ee() {
        (ye = new yg(Y)),
            (ge = new dg(Y, ye, r)),
            ye.init(ge),
            (te = new Xx(Y, ye, ge)),
            (xe = new Wx(Y, ye, ge)),
            (O[0] = 1029),
            (Oe = new Mg(Y)),
            (V = new Dx()),
            (j = new qx(Y, ye, xe, V, ge, te, Oe)),
            (K = new pg(x)),
            (ue = new xg(x)),
            (oe = new zf(Y, ge)),
            (L = new hg(Y, ye, oe, ge)),
            (Se = new vg(Y, oe, Oe, L)),
            (Te = new Tg(Y, Se, oe, Oe)),
            (Z = new Sg(Y, ge, j)),
            (J = new fg(V)),
            (Pe = new Ix(x, K, ue, ye, ge, L, J)),
            (Ye = new Yx(V)),
            (R = new Nx()),
            (T = new kx(ye, ge)),
            (se = new cg(x, K, xe, Te, a)),
            ($ = new yu(x, Te, ge)),
            (Me = new ug(Y, ye, Oe, ge)),
            (ve = new _g(Y, ye, Oe, ge)),
            (Oe.programs = Pe.programs),
            (x.capabilities = ge),
            (x.extensions = ye),
            (x.properties = V),
            (x.renderLists = R),
            (x.shadowMap = $),
            (x.state = xe),
            (x.info = Oe);
    }
    ee();
    let Q = new Ja(x, Y);
    (this.xr = Q),
        (this.getContext = function () {
            return Y;
        }),
        (this.getContextAttributes = function () {
            return Y.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
            let S = ye.get("WEBGL_lose_context");
            S && S.loseContext();
        }),
        (this.forceContextRestore = function () {
            let S = ye.get("WEBGL_lose_context");
            S && S.restoreContext();
        }),
        (this.getPixelRatio = function () {
            return P;
        }),
        (this.setPixelRatio = function (S) {
            S !== void 0 && ((P = S), this.setSize(k, z, !1));
        }),
        (this.getSize = function (S) {
            return S.set(k, z);
        }),
        (this.setSize = function (S, N, H) {
            if (Q.isPresenting) {
                console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                );
                return;
            }
            (k = S),
                (z = N),
                (e.width = Math.floor(S * P)),
                (e.height = Math.floor(N * P)),
                H !== !1 &&
                    ((e.style.width = S + "px"), (e.style.height = N + "px")),
                this.setViewport(0, 0, S, N);
        }),
        (this.getDrawingBufferSize = function (S) {
            return S.set(k * P, z * P).floor();
        }),
        (this.setDrawingBufferSize = function (S, N, H) {
            (k = S),
                (z = N),
                (P = H),
                (e.width = Math.floor(S * H)),
                (e.height = Math.floor(N * H)),
                this.setViewport(0, 0, S, N);
        }),
        (this.getCurrentViewport = function (S) {
            return S.copy(A);
        }),
        (this.getViewport = function (S) {
            return S.copy(D);
        }),
        (this.setViewport = function (S, N, H, B) {
            S.isVector4 ? D.set(S.x, S.y, S.z, S.w) : D.set(S, N, H, B),
                xe.viewport(A.copy(D).multiplyScalar(P).floor());
        }),
        (this.getScissor = function (S) {
            return S.copy(U);
        }),
        (this.setScissor = function (S, N, H, B) {
            S.isVector4 ? U.set(S.x, S.y, S.z, S.w) : U.set(S, N, H, B),
                xe.scissor(C.copy(U).multiplyScalar(P).floor());
        }),
        (this.getScissorTest = function () {
            return F;
        }),
        (this.setScissorTest = function (S) {
            xe.setScissorTest((F = S));
        }),
        (this.setOpaqueSort = function (S) {
            b = S;
        }),
        (this.setTransparentSort = function (S) {
            E = S;
        }),
        (this.getClearColor = function (S) {
            return S.copy(se.getClearColor());
        }),
        (this.setClearColor = function () {
            se.setClearColor.apply(se, arguments);
        }),
        (this.getClearAlpha = function () {
            return se.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
            se.setClearAlpha.apply(se, arguments);
        }),
        (this.clear = function (S, N, H) {
            let B = 0;
            (S === void 0 || S) && (B |= 16384),
                (N === void 0 || N) && (B |= 256),
                (H === void 0 || H) && (B |= 1024),
                Y.clear(B);
        }),
        (this.clearColor = function () {
            this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
            this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
            this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
            e.removeEventListener("webglcontextlost", Ee, !1),
                e.removeEventListener("webglcontextrestored", pe, !1),
                R.dispose(),
                T.dispose(),
                V.dispose(),
                K.dispose(),
                ue.dispose(),
                Te.dispose(),
                L.dispose(),
                Pe.dispose(),
                Q.dispose(),
                Q.removeEventListener("sessionstart", kt),
                Q.removeEventListener("sessionend", Vt),
                q && (q.dispose(), (q = null)),
                Nn.stop();
        });
    function Ee(S) {
        S.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (v = !0);
    }
    function pe() {
        console.log("THREE.WebGLRenderer: Context Restored."), (v = !1);
        let S = Oe.autoReset,
            N = $.enabled,
            H = $.autoUpdate,
            B = $.needsUpdate,
            X = $.type;
        ee(),
            (Oe.autoReset = S),
            ($.enabled = N),
            ($.autoUpdate = H),
            ($.needsUpdate = B),
            ($.type = X);
    }
    function Le(S) {
        let N = S.target;
        N.removeEventListener("dispose", Le), ae(N);
    }
    function ae(S) {
        Ce(S), V.remove(S);
    }
    function Ce(S) {
        let N = V.get(S).programs;
        N !== void 0 &&
            (N.forEach(function (H) {
                Pe.releaseProgram(H);
            }),
            S.isShaderMaterial && Pe.releaseShaderCache(S));
    }
    (this.renderBufferDirect = function (S, N, H, B, X, we) {
        N === null && (N = fe);
        let Ae = X.isMesh && X.matrixWorld.determinant() < 0,
            Ie = Ru(S, N, H, B, X);
        xe.setMaterial(B, Ae);
        let be = H.index,
            He = H.attributes.position;
        if (be === null) {
            if (He === void 0 || He.count === 0) return;
        } else if (be.count === 0) return;
        let De = 1;
        B.wireframe === !0 && ((be = Se.getWireframeAttribute(H)), (De = 2)),
            L.setup(X, B, Ie, H, be);
        let Ue,
            je = Me;
        be !== null && ((Ue = oe.get(be)), (je = ve), je.setIndex(Ue));
        let zn = be !== null ? be.count : He.count,
            ni = H.drawRange.start * De,
            ke = H.drawRange.count * De,
            Gt = we !== null ? we.start * De : 0,
            ot = we !== null ? we.count * De : 1 / 0,
            Wt = Math.max(ni, Gt),
            Ks = Math.min(zn, ni + ke, Gt + ot) - 1,
            qt = Math.max(0, Ks - Wt + 1);
        if (qt !== 0) {
            if (X.isMesh)
                B.wireframe === !0
                    ? (xe.setLineWidth(B.wireframeLinewidth * Ne()),
                      je.setMode(1))
                    : je.setMode(4);
            else if (X.isLine) {
                let Qt = B.linewidth;
                Qt === void 0 && (Qt = 1),
                    xe.setLineWidth(Qt * Ne()),
                    X.isLineSegments
                        ? je.setMode(1)
                        : X.isLineLoop
                        ? je.setMode(2)
                        : je.setMode(3);
            } else X.isPoints ? je.setMode(0) : X.isSprite && je.setMode(4);
            if (X.isInstancedMesh) je.renderInstances(Wt, qt, X.count);
            else if (H.isInstancedBufferGeometry) {
                let Qt = Math.min(H.instanceCount, H._maxInstanceCount);
                je.renderInstances(Wt, qt, Qt);
            } else je.render(Wt, qt);
        }
    }),
        (this.compile = function (S, N) {
            (d = T.get(S)),
                d.init(),
                m.push(d),
                S.traverseVisible(function (H) {
                    H.isLight &&
                        H.layers.test(N.layers) &&
                        (d.pushLight(H), H.castShadow && d.pushShadow(H));
                }),
                d.setupLights(x.physicallyCorrectLights),
                S.traverse(function (H) {
                    let B = H.material;
                    if (B)
                        if (Array.isArray(B))
                            for (let X = 0; X < B.length; X++) {
                                let we = B[X];
                                Yo(we, S, H);
                            }
                        else Yo(B, S, H);
                }),
                m.pop(),
                (d = null);
        });
    let Xe = null;
    function Ge(S) {
        Xe && Xe(S);
    }
    function kt() {
        Nn.stop();
    }
    function Vt() {
        Nn.start();
    }
    let Nn = new au();
    Nn.setAnimationLoop(Ge),
        typeof window < "u" && Nn.setContext(window),
        (this.setAnimationLoop = function (S) {
            (Xe = S),
                Q.setAnimationLoop(S),
                S === null ? Nn.stop() : Nn.start();
        }),
        Q.addEventListener("sessionstart", kt),
        Q.addEventListener("sessionend", Vt),
        (this.render = function (S, N) {
            if (N !== void 0 && N.isCamera !== !0) {
                console.error(
                    "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
                return;
            }
            if (v === !0) return;
            S.autoUpdate === !0 && S.updateMatrixWorld(),
                N.parent === null && N.updateMatrixWorld(),
                Q.enabled === !0 &&
                    Q.isPresenting === !0 &&
                    (Q.cameraAutoUpdate === !0 && Q.updateCamera(N),
                    (N = Q.getCamera())),
                S.isScene === !0 && S.onBeforeRender(x, S, N, _),
                (d = T.get(S, m.length)),
                d.init(),
                m.push(d),
                he.multiplyMatrices(N.projectionMatrix, N.matrixWorldInverse),
                ne.setFromProjectionMatrix(he),
                (G = this.localClippingEnabled),
                (ce = J.init(this.clippingPlanes, G, N)),
                (u = R.get(S, f.length)),
                u.init(),
                f.push(u),
                Gl(S, N, 0, x.sortObjects),
                u.finish(),
                x.sortObjects === !0 && u.sort(b, E),
                ce === !0 && J.beginShadows();
            let H = d.state.shadowsArray;
            if (
                ($.render(H, S, N),
                ce === !0 && J.endShadows(),
                this.info.autoReset === !0 && this.info.reset(),
                se.render(u, S),
                d.setupLights(x.physicallyCorrectLights),
                N.isArrayCamera)
            ) {
                let B = N.cameras;
                for (let X = 0, we = B.length; X < we; X++) {
                    let Ae = B[X];
                    Wl(u, S, Ae, Ae.viewport);
                }
            } else Wl(u, S, N);
            _ !== null &&
                (j.updateMultisampleRenderTarget(_),
                j.updateRenderTargetMipmap(_)),
                S.isScene === !0 && S.onAfterRender(x, S, N),
                xe.buffers.depth.setTest(!0),
                xe.buffers.depth.setMask(!0),
                xe.buffers.color.setMask(!0),
                xe.setPolygonOffset(!1),
                L.resetDefaultState(),
                (y = -1),
                (w = null),
                m.pop(),
                m.length > 0 ? (d = m[m.length - 1]) : (d = null),
                f.pop(),
                f.length > 0 ? (u = f[f.length - 1]) : (u = null);
        });
    function Gl(S, N, H, B) {
        if (S.visible === !1) return;
        if (S.layers.test(N.layers)) {
            if (S.isGroup) H = S.renderOrder;
            else if (S.isLOD) S.autoUpdate === !0 && S.update(N);
            else if (S.isLight) d.pushLight(S), S.castShadow && d.pushShadow(S);
            else if (S.isSprite) {
                if (!S.frustumCulled || ne.intersectsSprite(S)) {
                    B &&
                        le
                            .setFromMatrixPosition(S.matrixWorld)
                            .applyMatrix4(he);
                    let Ae = Te.update(S),
                        Ie = S.material;
                    Ie.visible && u.push(S, Ae, Ie, H, le.z, null);
                }
            } else if (
                (S.isMesh || S.isLine || S.isPoints) &&
                (S.isSkinnedMesh &&
                    S.skeleton.frame !== Oe.render.frame &&
                    (S.skeleton.update(), (S.skeleton.frame = Oe.render.frame)),
                !S.frustumCulled || ne.intersectsObject(S))
            ) {
                B && le.setFromMatrixPosition(S.matrixWorld).applyMatrix4(he);
                let Ae = Te.update(S),
                    Ie = S.material;
                if (Array.isArray(Ie)) {
                    let be = Ae.groups;
                    for (let He = 0, De = be.length; He < De; He++) {
                        let Ue = be[He],
                            je = Ie[Ue.materialIndex];
                        je && je.visible && u.push(S, Ae, je, H, le.z, Ue);
                    }
                } else Ie.visible && u.push(S, Ae, Ie, H, le.z, null);
            }
        }
        let we = S.children;
        for (let Ae = 0, Ie = we.length; Ae < Ie; Ae++) Gl(we[Ae], N, H, B);
    }
    function Wl(S, N, H, B) {
        let X = S.opaque,
            we = S.transmissive,
            Ae = S.transparent;
        d.setupLightsView(H),
            we.length > 0 && Eu(X, N, H),
            B && xe.viewport(A.copy(B)),
            X.length > 0 && Qs(X, N, H),
            we.length > 0 && Qs(we, N, H),
            Ae.length > 0 && Qs(Ae, N, H);
    }
    function Eu(S, N, H) {
        if (q === null) {
            let Ae = o === !0 && ge.isWebGL2 === !0 ? ws : St;
            q = new Ae(1024, 1024, {
                generateMipmaps: !0,
                type: te.convert(Xn) !== null ? Xn : an,
                minFilter: $i,
                magFilter: st,
                wrapS: yt,
                wrapT: yt,
                useRenderToTexture: ye.has(
                    "WEBGL_multisampled_render_to_texture"
                ),
            });
        }
        let B = x.getRenderTarget();
        x.setRenderTarget(q), x.clear();
        let X = x.toneMapping;
        (x.toneMapping = wn),
            Qs(S, N, H),
            (x.toneMapping = X),
            j.updateMultisampleRenderTarget(q),
            j.updateRenderTargetMipmap(q),
            x.setRenderTarget(B);
    }
    function Qs(S, N, H) {
        let B = N.isScene === !0 ? N.overrideMaterial : null;
        for (let X = 0, we = S.length; X < we; X++) {
            let Ae = S[X],
                Ie = Ae.object,
                be = Ae.geometry,
                He = B === null ? Ae.material : B,
                De = Ae.group;
            Ie.layers.test(H.layers) && Au(Ie, N, H, be, He, De);
        }
    }
    function Au(S, N, H, B, X, we) {
        S.onBeforeRender(x, N, H, B, X, we),
            S.modelViewMatrix.multiplyMatrices(
                H.matrixWorldInverse,
                S.matrixWorld
            ),
            S.normalMatrix.getNormalMatrix(S.modelViewMatrix),
            X.onBeforeRender(x, N, H, B, S, we),
            X.transparent === !0 && X.side === Li
                ? ((X.side = it),
                  (X.needsUpdate = !0),
                  x.renderBufferDirect(H, N, B, X, S, we),
                  (X.side = Ci),
                  (X.needsUpdate = !0),
                  x.renderBufferDirect(H, N, B, X, S, we),
                  (X.side = Li))
                : x.renderBufferDirect(H, N, B, X, S, we),
            S.onAfterRender(x, N, H, B, X, we);
    }
    function Yo(S, N, H) {
        N.isScene !== !0 && (N = fe);
        let B = V.get(S),
            X = d.state.lights,
            we = d.state.shadowsArray,
            Ae = X.state.version,
            Ie = Pe.getParameters(S, X.state, we, N, H),
            be = Pe.getProgramCacheKey(Ie),
            He = B.programs;
        (B.environment = S.isMeshStandardMaterial ? N.environment : null),
            (B.fog = N.fog),
            (B.envMap = (S.isMeshStandardMaterial ? ue : K).get(
                S.envMap || B.environment
            )),
            He === void 0 &&
                (S.addEventListener("dispose", Le),
                (He = new Map()),
                (B.programs = He));
        let De = He.get(be);
        if (De !== void 0) {
            if (B.currentProgram === De && B.lightsStateVersion === Ae)
                return ql(S, Ie), De;
        } else
            (Ie.uniforms = Pe.getUniforms(S)),
                S.onBuild(H, Ie, x),
                S.onBeforeCompile(Ie, x),
                (De = Pe.acquireProgram(Ie, be)),
                He.set(be, De),
                (B.uniforms = Ie.uniforms);
        let Ue = B.uniforms;
        ((!S.isShaderMaterial && !S.isRawShaderMaterial) ||
            S.clipping === !0) &&
            (Ue.clippingPlanes = J.uniform),
            ql(S, Ie),
            (B.needsLights = Lu(S)),
            (B.lightsStateVersion = Ae),
            B.needsLights &&
                ((Ue.ambientLightColor.value = X.state.ambient),
                (Ue.lightProbe.value = X.state.probe),
                (Ue.directionalLights.value = X.state.directional),
                (Ue.directionalLightShadows.value = X.state.directionalShadow),
                (Ue.spotLights.value = X.state.spot),
                (Ue.spotLightShadows.value = X.state.spotShadow),
                (Ue.rectAreaLights.value = X.state.rectArea),
                (Ue.ltc_1.value = X.state.rectAreaLTC1),
                (Ue.ltc_2.value = X.state.rectAreaLTC2),
                (Ue.pointLights.value = X.state.point),
                (Ue.pointLightShadows.value = X.state.pointShadow),
                (Ue.hemisphereLights.value = X.state.hemi),
                (Ue.directionalShadowMap.value = X.state.directionalShadowMap),
                (Ue.directionalShadowMatrix.value =
                    X.state.directionalShadowMatrix),
                (Ue.spotShadowMap.value = X.state.spotShadowMap),
                (Ue.spotShadowMatrix.value = X.state.spotShadowMatrix),
                (Ue.pointShadowMap.value = X.state.pointShadowMap),
                (Ue.pointShadowMatrix.value = X.state.pointShadowMatrix));
        let je = De.getUniforms(),
            zn = Sn.seqWithValue(je.seq, Ue);
        return (B.currentProgram = De), (B.uniformsList = zn), De;
    }
    function ql(S, N) {
        let H = V.get(S);
        (H.outputEncoding = N.outputEncoding),
            (H.instancing = N.instancing),
            (H.skinning = N.skinning),
            (H.morphTargets = N.morphTargets),
            (H.morphNormals = N.morphNormals),
            (H.morphTargetsCount = N.morphTargetsCount),
            (H.numClippingPlanes = N.numClippingPlanes),
            (H.numIntersection = N.numClipIntersection),
            (H.vertexAlphas = N.vertexAlphas),
            (H.vertexTangents = N.vertexTangents),
            (H.toneMapping = N.toneMapping);
    }
    function Ru(S, N, H, B, X) {
        N.isScene !== !0 && (N = fe), j.resetTextureUnits();
        let we = N.fog,
            Ae = B.isMeshStandardMaterial ? N.environment : null,
            Ie = _ === null ? x.outputEncoding : _.texture.encoding,
            be = (B.isMeshStandardMaterial ? ue : K).get(B.envMap || Ae),
            He =
                B.vertexColors === !0 &&
                !!H.attributes.color &&
                H.attributes.color.itemSize === 4,
            De = !!B.normalMap && !!H.attributes.tangent,
            Ue = !!H.morphAttributes.position,
            je = !!H.morphAttributes.normal,
            zn = H.morphAttributes.position
                ? H.morphAttributes.position.length
                : 0,
            ni = B.toneMapped ? x.toneMapping : wn,
            ke = V.get(B),
            Gt = d.state.lights;
        if (ce === !0 && (G === !0 || S !== w)) {
            let Dt = S === w && B.id === y;
            J.setState(B, S, Dt);
        }
        let ot = !1;
        B.version === ke.__version
            ? ((ke.needsLights && ke.lightsStateVersion !== Gt.state.version) ||
                  ke.outputEncoding !== Ie ||
                  (X.isInstancedMesh && ke.instancing === !1) ||
                  (!X.isInstancedMesh && ke.instancing === !0) ||
                  (X.isSkinnedMesh && ke.skinning === !1) ||
                  (!X.isSkinnedMesh && ke.skinning === !0) ||
                  ke.envMap !== be ||
                  (B.fog && ke.fog !== we) ||
                  (ke.numClippingPlanes !== void 0 &&
                      (ke.numClippingPlanes !== J.numPlanes ||
                          ke.numIntersection !== J.numIntersection)) ||
                  ke.vertexAlphas !== He ||
                  ke.vertexTangents !== De ||
                  ke.morphTargets !== Ue ||
                  ke.morphNormals !== je ||
                  ke.toneMapping !== ni ||
                  (ge.isWebGL2 === !0 && ke.morphTargetsCount !== zn)) &&
              (ot = !0)
            : ((ot = !0), (ke.__version = B.version));
        let Wt = ke.currentProgram;
        ot === !0 && (Wt = Yo(B, N, X));
        let Ks = !1,
            qt = !1,
            Qt = !1,
            gt = Wt.getUniforms(),
            es = ke.uniforms;
        if (
            (xe.useProgram(Wt.program) && ((Ks = !0), (qt = !0), (Qt = !0)),
            B.id !== y && ((y = B.id), (qt = !0)),
            Ks || w !== S)
        ) {
            if (
                (gt.setValue(Y, "projectionMatrix", S.projectionMatrix),
                ge.logarithmicDepthBuffer &&
                    gt.setValue(
                        Y,
                        "logDepthBufFC",
                        2 / (Math.log(S.far + 1) / Math.LN2)
                    ),
                w !== S && ((w = S), (qt = !0), (Qt = !0)),
                B.isShaderMaterial ||
                    B.isMeshPhongMaterial ||
                    B.isMeshToonMaterial ||
                    B.isMeshStandardMaterial ||
                    B.envMap)
            ) {
                let Dt = gt.map.cameraPosition;
                Dt !== void 0 &&
                    Dt.setValue(Y, le.setFromMatrixPosition(S.matrixWorld));
            }
            (B.isMeshPhongMaterial ||
                B.isMeshToonMaterial ||
                B.isMeshLambertMaterial ||
                B.isMeshBasicMaterial ||
                B.isMeshStandardMaterial ||
                B.isShaderMaterial) &&
                gt.setValue(Y, "isOrthographic", S.isOrthographicCamera === !0),
                (B.isMeshPhongMaterial ||
                    B.isMeshToonMaterial ||
                    B.isMeshLambertMaterial ||
                    B.isMeshBasicMaterial ||
                    B.isMeshStandardMaterial ||
                    B.isShaderMaterial ||
                    B.isShadowMaterial ||
                    X.isSkinnedMesh) &&
                    gt.setValue(Y, "viewMatrix", S.matrixWorldInverse);
        }
        if (X.isSkinnedMesh) {
            gt.setOptional(Y, X, "bindMatrix"),
                gt.setOptional(Y, X, "bindMatrixInverse");
            let Dt = X.skeleton;
            Dt &&
                (ge.floatVertexTextures
                    ? (Dt.boneTexture === null && Dt.computeBoneTexture(),
                      gt.setValue(Y, "boneTexture", Dt.boneTexture, j),
                      gt.setValue(Y, "boneTextureSize", Dt.boneTextureSize))
                    : gt.setOptional(Y, Dt, "boneMatrices"));
        }
        return (
            H &&
                (H.morphAttributes.position !== void 0 ||
                    H.morphAttributes.normal !== void 0) &&
                Z.update(X, H, B, Wt),
            (qt || ke.receiveShadow !== X.receiveShadow) &&
                ((ke.receiveShadow = X.receiveShadow),
                gt.setValue(Y, "receiveShadow", X.receiveShadow)),
            qt &&
                (gt.setValue(Y, "toneMappingExposure", x.toneMappingExposure),
                ke.needsLights && Cu(es, Qt),
                we && B.fog && Ye.refreshFogUniforms(es, we),
                Ye.refreshMaterialUniforms(es, B, P, z, q),
                Sn.upload(Y, ke.uniformsList, es, j)),
            B.isShaderMaterial &&
                B.uniformsNeedUpdate === !0 &&
                (Sn.upload(Y, ke.uniformsList, es, j),
                (B.uniformsNeedUpdate = !1)),
            B.isSpriteMaterial && gt.setValue(Y, "center", X.center),
            gt.setValue(Y, "modelViewMatrix", X.modelViewMatrix),
            gt.setValue(Y, "normalMatrix", X.normalMatrix),
            gt.setValue(Y, "modelMatrix", X.matrixWorld),
            Wt
        );
    }
    function Cu(S, N) {
        (S.ambientLightColor.needsUpdate = N),
            (S.lightProbe.needsUpdate = N),
            (S.directionalLights.needsUpdate = N),
            (S.directionalLightShadows.needsUpdate = N),
            (S.pointLights.needsUpdate = N),
            (S.pointLightShadows.needsUpdate = N),
            (S.spotLights.needsUpdate = N),
            (S.spotLightShadows.needsUpdate = N),
            (S.rectAreaLights.needsUpdate = N),
            (S.hemisphereLights.needsUpdate = N);
    }
    function Lu(S) {
        return (
            S.isMeshLambertMaterial ||
            S.isMeshToonMaterial ||
            S.isMeshPhongMaterial ||
            S.isMeshStandardMaterial ||
            S.isShadowMaterial ||
            (S.isShaderMaterial && S.lights === !0)
        );
    }
    (this.getActiveCubeFace = function () {
        return g;
    }),
        (this.getActiveMipmapLevel = function () {
            return p;
        }),
        (this.getRenderTarget = function () {
            return _;
        }),
        (this.setRenderTargetTextures = function (S, N, H) {
            (V.get(S.texture).__webglTexture = N),
                (V.get(S.depthTexture).__webglTexture = H);
            let B = V.get(S);
            (B.__hasExternalTextures = !0),
                B.__hasExternalTextures &&
                    ((B.__autoAllocateDepthBuffer = H === void 0),
                    B.__autoAllocateDepthBuffer ||
                        (S.useRenderToTexture &&
                            (console.warn(
                                "render-to-texture extension was disabled because an external texture was provided"
                            ),
                            (S.useRenderToTexture = !1),
                            (S.useRenderbuffer = !0))));
        }),
        (this.setRenderTargetFramebuffer = function (S, N) {
            let H = V.get(S);
            (H.__webglFramebuffer = N),
                (H.__useDefaultFramebuffer = N === void 0);
        }),
        (this.setRenderTarget = function (S, N = 0, H = 0) {
            (_ = S), (g = N), (p = H);
            let B = !0;
            if (S) {
                let be = V.get(S);
                be.__useDefaultFramebuffer !== void 0
                    ? (xe.bindFramebuffer(36160, null), (B = !1))
                    : be.__webglFramebuffer === void 0
                    ? j.setupRenderTarget(S)
                    : be.__hasExternalTextures &&
                      j.rebindTextures(
                          S,
                          V.get(S.texture).__webglTexture,
                          V.get(S.depthTexture).__webglTexture
                      );
            }
            let X = null,
                we = !1,
                Ae = !1;
            if (S) {
                let be = S.texture;
                (be.isDataTexture3D || be.isDataTexture2DArray) && (Ae = !0);
                let He = V.get(S).__webglFramebuffer;
                S.isWebGLCubeRenderTarget
                    ? ((X = He[N]), (we = !0))
                    : S.useRenderbuffer
                    ? (X = V.get(S).__webglMultisampledFramebuffer)
                    : (X = He),
                    A.copy(S.viewport),
                    C.copy(S.scissor),
                    (I = S.scissorTest);
            } else
                A.copy(D).multiplyScalar(P).floor(),
                    C.copy(U).multiplyScalar(P).floor(),
                    (I = F);
            if (xe.bindFramebuffer(36160, X) && ge.drawBuffers && B) {
                let be = !1;
                if (S)
                    if (S.isWebGLMultipleRenderTargets) {
                        let He = S.texture;
                        if (O.length !== He.length || O[0] !== 36064) {
                            for (let De = 0, Ue = He.length; De < Ue; De++)
                                O[De] = 36064 + De;
                            (O.length = He.length), (be = !0);
                        }
                    } else
                        (O.length !== 1 || O[0] !== 36064) &&
                            ((O[0] = 36064), (O.length = 1), (be = !0));
                else
                    (O.length !== 1 || O[0] !== 1029) &&
                        ((O[0] = 1029), (O.length = 1), (be = !0));
                be &&
                    (ge.isWebGL2
                        ? Y.drawBuffers(O)
                        : ye.get("WEBGL_draw_buffers").drawBuffersWEBGL(O));
            }
            if ((xe.viewport(A), xe.scissor(C), xe.setScissorTest(I), we)) {
                let be = V.get(S.texture);
                Y.framebufferTexture2D(
                    36160,
                    36064,
                    34069 + N,
                    be.__webglTexture,
                    H
                );
            } else if (Ae) {
                let be = V.get(S.texture),
                    He = N || 0;
                Y.framebufferTextureLayer(
                    36160,
                    36064,
                    be.__webglTexture,
                    H || 0,
                    He
                );
            }
            y = -1;
        }),
        (this.readRenderTargetPixels = function (S, N, H, B, X, we, Ae) {
            if (!(S && S.isWebGLRenderTarget)) {
                console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
                return;
            }
            let Ie = V.get(S).__webglFramebuffer;
            if (
                (S.isWebGLCubeRenderTarget && Ae !== void 0 && (Ie = Ie[Ae]),
                Ie)
            ) {
                xe.bindFramebuffer(36160, Ie);
                try {
                    let be = S.texture,
                        He = be.format,
                        De = be.type;
                    if (He !== lt && te.convert(He) !== Y.getParameter(35739)) {
                        console.error(
                            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                        );
                        return;
                    }
                    let Ue =
                        De === Xn &&
                        (ye.has("EXT_color_buffer_half_float") ||
                            (ge.isWebGL2 && ye.has("EXT_color_buffer_float")));
                    if (
                        De !== an &&
                        te.convert(De) !== Y.getParameter(35738) &&
                        !(
                            De === on &&
                            (ge.isWebGL2 ||
                                ye.has("OES_texture_float") ||
                                ye.has("WEBGL_color_buffer_float"))
                        ) &&
                        !Ue
                    ) {
                        console.error(
                            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                        );
                        return;
                    }
                    Y.checkFramebufferStatus(36160) === 36053
                        ? N >= 0 &&
                          N <= S.width - B &&
                          H >= 0 &&
                          H <= S.height - X &&
                          Y.readPixels(
                              N,
                              H,
                              B,
                              X,
                              te.convert(He),
                              te.convert(De),
                              we
                          )
                        : console.error(
                              "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                          );
                } finally {
                    let be = _ !== null ? V.get(_).__webglFramebuffer : null;
                    xe.bindFramebuffer(36160, be);
                }
            }
        }),
        (this.copyFramebufferToTexture = function (S, N, H = 0) {
            if (N.isFramebufferTexture !== !0) {
                console.error(
                    "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
                );
                return;
            }
            let B = Math.pow(2, -H),
                X = Math.floor(N.image.width * B),
                we = Math.floor(N.image.height * B);
            j.setTexture2D(N, 0),
                Y.copyTexSubImage2D(3553, H, 0, 0, S.x, S.y, X, we),
                xe.unbindTexture();
        }),
        (this.copyTextureToTexture = function (S, N, H, B = 0) {
            let X = N.image.width,
                we = N.image.height,
                Ae = te.convert(H.format),
                Ie = te.convert(H.type);
            j.setTexture2D(H, 0),
                Y.pixelStorei(37440, H.flipY),
                Y.pixelStorei(37441, H.premultiplyAlpha),
                Y.pixelStorei(3317, H.unpackAlignment),
                N.isDataTexture
                    ? Y.texSubImage2D(
                          3553,
                          B,
                          S.x,
                          S.y,
                          X,
                          we,
                          Ae,
                          Ie,
                          N.image.data
                      )
                    : N.isCompressedTexture
                    ? Y.compressedTexSubImage2D(
                          3553,
                          B,
                          S.x,
                          S.y,
                          N.mipmaps[0].width,
                          N.mipmaps[0].height,
                          Ae,
                          N.mipmaps[0].data
                      )
                    : Y.texSubImage2D(3553, B, S.x, S.y, Ae, Ie, N.image),
                B === 0 && H.generateMipmaps && Y.generateMipmap(3553),
                xe.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (S, N, H, B, X = 0) {
            if (x.isWebGL1Renderer) {
                console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                );
                return;
            }
            let we = S.max.x - S.min.x + 1,
                Ae = S.max.y - S.min.y + 1,
                Ie = S.max.z - S.min.z + 1,
                be = te.convert(B.format),
                He = te.convert(B.type),
                De;
            if (B.isDataTexture3D) j.setTexture3D(B, 0), (De = 32879);
            else if (B.isDataTexture2DArray)
                j.setTexture2DArray(B, 0), (De = 35866);
            else {
                console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
                return;
            }
            Y.pixelStorei(37440, B.flipY),
                Y.pixelStorei(37441, B.premultiplyAlpha),
                Y.pixelStorei(3317, B.unpackAlignment);
            let Ue = Y.getParameter(3314),
                je = Y.getParameter(32878),
                zn = Y.getParameter(3316),
                ni = Y.getParameter(3315),
                ke = Y.getParameter(32877),
                Gt = H.isCompressedTexture ? H.mipmaps[0] : H.image;
            Y.pixelStorei(3314, Gt.width),
                Y.pixelStorei(32878, Gt.height),
                Y.pixelStorei(3316, S.min.x),
                Y.pixelStorei(3315, S.min.y),
                Y.pixelStorei(32877, S.min.z),
                H.isDataTexture || H.isDataTexture3D
                    ? Y.texSubImage3D(
                          De,
                          X,
                          N.x,
                          N.y,
                          N.z,
                          we,
                          Ae,
                          Ie,
                          be,
                          He,
                          Gt.data
                      )
                    : H.isCompressedTexture
                    ? (console.warn(
                          "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                      ),
                      Y.compressedTexSubImage3D(
                          De,
                          X,
                          N.x,
                          N.y,
                          N.z,
                          we,
                          Ae,
                          Ie,
                          be,
                          Gt.data
                      ))
                    : Y.texSubImage3D(
                          De,
                          X,
                          N.x,
                          N.y,
                          N.z,
                          we,
                          Ae,
                          Ie,
                          be,
                          He,
                          Gt
                      ),
                Y.pixelStorei(3314, Ue),
                Y.pixelStorei(32878, je),
                Y.pixelStorei(3316, zn),
                Y.pixelStorei(3315, ni),
                Y.pixelStorei(32877, ke),
                X === 0 && B.generateMipmaps && Y.generateMipmap(De),
                xe.unbindTexture();
        }),
        (this.initTexture = function (S) {
            j.setTexture2D(S, 0), xe.unbindTexture();
        }),
        (this.resetState = function () {
            (g = 0), (p = 0), (_ = null), xe.reset(), L.reset();
        }),
        typeof __THREE_DEVTOOLS__ < "u" &&
            __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
            );
}
qe.prototype.isWebGLRenderer = !0;
var Ya = class extends qe {};
Ya.prototype.isWebGL1Renderer = !0;
var Kr = class r {
    constructor(e, t = 25e-5) {
        (this.name = ""), (this.color = new re(e)), (this.density = t);
    }
    clone() {
        return new r(this.color, this.density);
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density,
        };
    }
};
Kr.prototype.isFogExp2 = !0;
var eo = class r {
    constructor(e, t = 1, n = 1e3) {
        (this.name = ""),
            (this.color = new re(e)),
            (this.near = t),
            (this.far = n);
    }
    clone() {
        return new r(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
        };
    }
};
eo.prototype.isFog = !0;
var Ds = class extends Be {
    constructor() {
        super(),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.overrideMaterial = null),
            (this.autoUpdate = !0),
            typeof __THREE_DEVTOOLS__ < "u" &&
                __THREE_DEVTOOLS__.dispatchEvent(
                    new CustomEvent("observe", { detail: this })
                );
    }
    copy(e, t) {
        return (
            super.copy(e, t),
            e.background !== null && (this.background = e.background.clone()),
            e.environment !== null &&
                (this.environment = e.environment.clone()),
            e.fog !== null && (this.fog = e.fog.clone()),
            e.overrideMaterial !== null &&
                (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.autoUpdate = e.autoUpdate),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
        );
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
    }
};
Ds.prototype.isScene = !0;
var An = class {
    constructor(e, t) {
        (this.array = e),
            (this.stride = t),
            (this.count = e !== void 0 ? e.length / t : 0),
            (this.usage = vs),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = Ct());
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setUsage(e) {
        return (this.usage = e), this;
    }
    copy(e) {
        return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
        );
    }
    copyAt(e, t, n) {
        (e *= this.stride), (n *= t.stride);
        for (let i = 0, s = this.stride; i < s; i++)
            this.array[e + i] = t.array[n + i];
        return this;
    }
    set(e, t = 0) {
        return this.array.set(e, t), this;
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
                (this.array.buffer._uuid = Ct()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                    this.array.slice(0).buffer);
        let t = new this.array.constructor(
                e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n;
    }
    onUpload(e) {
        return (this.onUploadCallback = e), this;
    }
    toJSON(e) {
        return (
            e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
            this.array.buffer._uuid === void 0 &&
                (this.array.buffer._uuid = Ct()),
            e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
                (e.arrayBuffers[this.array.buffer._uuid] =
                    Array.prototype.slice.call(
                        new Uint32Array(this.array.buffer)
                    )),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
            }
        );
    }
};
An.prototype.isInterleavedBuffer = !0;
var Ke = new M(),
    Kn = class r {
        constructor(e, t, n, i = !1) {
            (this.name = ""),
                (this.data = e),
                (this.itemSize = t),
                (this.offset = n),
                (this.normalized = i === !0);
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        set needsUpdate(e) {
            this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
            for (let t = 0, n = this.data.count; t < n; t++)
                (Ke.x = this.getX(t)),
                    (Ke.y = this.getY(t)),
                    (Ke.z = this.getZ(t)),
                    Ke.applyMatrix4(e),
                    this.setXYZ(t, Ke.x, Ke.y, Ke.z);
            return this;
        }
        applyNormalMatrix(e) {
            for (let t = 0, n = this.count; t < n; t++)
                (Ke.x = this.getX(t)),
                    (Ke.y = this.getY(t)),
                    (Ke.z = this.getZ(t)),
                    Ke.applyNormalMatrix(e),
                    this.setXYZ(t, Ke.x, Ke.y, Ke.z);
            return this;
        }
        transformDirection(e) {
            for (let t = 0, n = this.count; t < n; t++)
                (Ke.x = this.getX(t)),
                    (Ke.y = this.getY(t)),
                    (Ke.z = this.getZ(t)),
                    Ke.transformDirection(e),
                    this.setXYZ(t, Ke.x, Ke.y, Ke.z);
            return this;
        }
        setX(e, t) {
            return (
                (this.data.array[e * this.data.stride + this.offset] = t), this
            );
        }
        setY(e, t) {
            return (
                (this.data.array[e * this.data.stride + this.offset + 1] = t),
                this
            );
        }
        setZ(e, t) {
            return (
                (this.data.array[e * this.data.stride + this.offset + 2] = t),
                this
            );
        }
        setW(e, t) {
            return (
                (this.data.array[e * this.data.stride + this.offset + 3] = t),
                this
            );
        }
        getX(e) {
            return this.data.array[e * this.data.stride + this.offset];
        }
        getY(e) {
            return this.data.array[e * this.data.stride + this.offset + 1];
        }
        getZ(e) {
            return this.data.array[e * this.data.stride + this.offset + 2];
        }
        getW(e) {
            return this.data.array[e * this.data.stride + this.offset + 3];
        }
        setXY(e, t, n) {
            return (
                (e = e * this.data.stride + this.offset),
                (this.data.array[e + 0] = t),
                (this.data.array[e + 1] = n),
                this
            );
        }
        setXYZ(e, t, n, i) {
            return (
                (e = e * this.data.stride + this.offset),
                (this.data.array[e + 0] = t),
                (this.data.array[e + 1] = n),
                (this.data.array[e + 2] = i),
                this
            );
        }
        setXYZW(e, t, n, i, s) {
            return (
                (e = e * this.data.stride + this.offset),
                (this.data.array[e + 0] = t),
                (this.data.array[e + 1] = n),
                (this.data.array[e + 2] = i),
                (this.data.array[e + 3] = s),
                this
            );
        }
        clone(e) {
            if (e === void 0) {
                console.log(
                    "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
                );
                let t = [];
                for (let n = 0; n < this.count; n++) {
                    let i = n * this.data.stride + this.offset;
                    for (let s = 0; s < this.itemSize; s++)
                        t.push(this.data.array[i + s]);
                }
                return new ze(
                    new this.array.constructor(t),
                    this.itemSize,
                    this.normalized
                );
            } else
                return (
                    e.interleavedBuffers === void 0 &&
                        (e.interleavedBuffers = {}),
                    e.interleavedBuffers[this.data.uuid] === void 0 &&
                        (e.interleavedBuffers[this.data.uuid] =
                            this.data.clone(e)),
                    new r(
                        e.interleavedBuffers[this.data.uuid],
                        this.itemSize,
                        this.offset,
                        this.normalized
                    )
                );
        }
        toJSON(e) {
            if (e === void 0) {
                console.log(
                    "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
                );
                let t = [];
                for (let n = 0; n < this.count; n++) {
                    let i = n * this.data.stride + this.offset;
                    for (let s = 0; s < this.itemSize; s++)
                        t.push(this.data.array[i + s]);
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized,
                };
            } else
                return (
                    e.interleavedBuffers === void 0 &&
                        (e.interleavedBuffers = {}),
                    e.interleavedBuffers[this.data.uuid] === void 0 &&
                        (e.interleavedBuffers[this.data.uuid] =
                            this.data.toJSON(e)),
                    {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized,
                    }
                );
        }
    };
Kn.prototype.isInterleavedBufferAttribute = !0;
var Fs = class extends ct {
    constructor(e) {
        super(),
            (this.type = "SpriteMaterial"),
            (this.color = new re(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.rotation = 0),
            (this.sizeAttenuation = !0),
            (this.transparent = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.rotation = e.rotation),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
        );
    }
};
Fs.prototype.isSpriteMaterial = !0;
var yi,
    os = new M(),
    vi = new M(),
    _i = new M(),
    Mi = new W(),
    as = new W(),
    vu = new me(),
    Mr = new M(),
    ls = new M(),
    wr = new M(),
    Vc = new W(),
    wa = new W(),
    Gc = new W(),
    Ns = class extends Be {
        constructor(e) {
            if ((super(), (this.type = "Sprite"), yi === void 0)) {
                yi = new _e();
                let t = new Float32Array([
                        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1,
                        1, -0.5, 0.5, 0, 0, 1,
                    ]),
                    n = new An(t, 5);
                yi.setIndex([0, 1, 2, 0, 2, 3]),
                    yi.setAttribute("position", new Kn(n, 3, 0, !1)),
                    yi.setAttribute("uv", new Kn(n, 2, 3, !1));
            }
            (this.geometry = yi),
                (this.material = e !== void 0 ? e : new Fs()),
                (this.center = new W(0.5, 0.5));
        }
        raycast(e, t) {
            e.camera === null &&
                console.error(
                    'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
                ),
                vi.setFromMatrixScale(this.matrixWorld),
                vu.copy(e.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(
                    e.camera.matrixWorldInverse,
                    this.matrixWorld
                ),
                _i.setFromMatrixPosition(this.modelViewMatrix),
                e.camera.isPerspectiveCamera &&
                    this.material.sizeAttenuation === !1 &&
                    vi.multiplyScalar(-_i.z);
            let n = this.material.rotation,
                i,
                s;
            n !== 0 && ((s = Math.cos(n)), (i = Math.sin(n)));
            let o = this.center;
            br(Mr.set(-0.5, -0.5, 0), _i, o, vi, i, s),
                br(ls.set(0.5, -0.5, 0), _i, o, vi, i, s),
                br(wr.set(0.5, 0.5, 0), _i, o, vi, i, s),
                Vc.set(0, 0),
                wa.set(1, 0),
                Gc.set(1, 1);
            let a = e.ray.intersectTriangle(Mr, ls, wr, !1, os);
            if (
                a === null &&
                (br(ls.set(-0.5, 0.5, 0), _i, o, vi, i, s),
                wa.set(0, 1),
                (a = e.ray.intersectTriangle(Mr, wr, ls, !1, os)),
                a === null)
            )
                return;
            let l = e.ray.origin.distanceTo(os);
            l < e.near ||
                l > e.far ||
                t.push({
                    distance: l,
                    point: os.clone(),
                    uv: vt.getUV(os, Mr, ls, wr, Vc, wa, Gc, new W()),
                    face: null,
                    object: this,
                });
        }
        copy(e) {
            return (
                super.copy(e),
                e.center !== void 0 && this.center.copy(e.center),
                (this.material = e.material),
                this
            );
        }
    };
Ns.prototype.isSprite = !0;
function br(r, e, t, n, i, s) {
    Mi.subVectors(r, t).addScalar(0.5).multiply(n),
        i !== void 0
            ? ((as.x = s * Mi.x - i * Mi.y), (as.y = i * Mi.x + s * Mi.y))
            : as.copy(Mi),
        r.copy(e),
        (r.x += as.x),
        (r.y += as.y),
        r.applyMatrix4(vu);
}
var Sr = new M(),
    Wc = new M(),
    Za = class extends Be {
        constructor() {
            super(),
                (this._currentLevel = 0),
                (this.type = "LOD"),
                Object.defineProperties(this, {
                    levels: { enumerable: !0, value: [] },
                    isLOD: { value: !0 },
                }),
                (this.autoUpdate = !0);
        }
        copy(e) {
            super.copy(e, !1);
            let t = e.levels;
            for (let n = 0, i = t.length; n < i; n++) {
                let s = t[n];
                this.addLevel(s.object.clone(), s.distance);
            }
            return (this.autoUpdate = e.autoUpdate), this;
        }
        addLevel(e, t = 0) {
            t = Math.abs(t);
            let n = this.levels,
                i;
            for (i = 0; i < n.length && !(t < n[i].distance); i++);
            return (
                n.splice(i, 0, { distance: t, object: e }), this.add(e), this
            );
        }
        getCurrentLevel() {
            return this._currentLevel;
        }
        getObjectForDistance(e) {
            let t = this.levels;
            if (t.length > 0) {
                let n, i;
                for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                return t[n - 1].object;
            }
            return null;
        }
        raycast(e, t) {
            if (this.levels.length > 0) {
                Sr.setFromMatrixPosition(this.matrixWorld);
                let i = e.ray.origin.distanceTo(Sr);
                this.getObjectForDistance(i).raycast(e, t);
            }
        }
        update(e) {
            let t = this.levels;
            if (t.length > 1) {
                Sr.setFromMatrixPosition(e.matrixWorld),
                    Wc.setFromMatrixPosition(this.matrixWorld);
                let n = Sr.distanceTo(Wc) / e.zoom;
                t[0].object.visible = !0;
                let i, s;
                for (i = 1, s = t.length; i < s && n >= t[i].distance; i++)
                    (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
                for (this._currentLevel = i - 1; i < s; i++)
                    t[i].object.visible = !1;
            }
        }
        toJSON(e) {
            let t = super.toJSON(e);
            this.autoUpdate === !1 && (t.object.autoUpdate = !1),
                (t.object.levels = []);
            let n = this.levels;
            for (let i = 0, s = n.length; i < s; i++) {
                let o = n[i];
                t.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance,
                });
            }
            return t;
        }
    },
    qc = new M(),
    Xc = new Ve(),
    Jc = new Ve(),
    $x = new M(),
    Yc = new me(),
    zs = class extends nt {
        constructor(e, t) {
            super(e, t),
                (this.type = "SkinnedMesh"),
                (this.bindMode = "attached"),
                (this.bindMatrix = new me()),
                (this.bindMatrixInverse = new me());
        }
        copy(e) {
            return (
                super.copy(e),
                (this.bindMode = e.bindMode),
                this.bindMatrix.copy(e.bindMatrix),
                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                (this.skeleton = e.skeleton),
                this
            );
        }
        bind(e, t) {
            (this.skeleton = e),
                t === void 0 &&
                    (this.updateMatrixWorld(!0),
                    this.skeleton.calculateInverses(),
                    (t = this.matrixWorld)),
                this.bindMatrix.copy(t),
                this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            let e = new Ve(),
                t = this.geometry.attributes.skinWeight;
            for (let n = 0, i = t.count; n < i; n++) {
                (e.x = t.getX(n)),
                    (e.y = t.getY(n)),
                    (e.z = t.getZ(n)),
                    (e.w = t.getW(n));
                let s = 1 / e.manhattanLength();
                s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
                    t.setXYZW(n, e.x, e.y, e.z, e.w);
            }
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e),
                this.bindMode === "attached"
                    ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                    : this.bindMode === "detached"
                    ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                    : console.warn(
                          "THREE.SkinnedMesh: Unrecognized bindMode: " +
                              this.bindMode
                      );
        }
        boneTransform(e, t) {
            let n = this.skeleton,
                i = this.geometry;
            Xc.fromBufferAttribute(i.attributes.skinIndex, e),
                Jc.fromBufferAttribute(i.attributes.skinWeight, e),
                qc.copy(t).applyMatrix4(this.bindMatrix),
                t.set(0, 0, 0);
            for (let s = 0; s < 4; s++) {
                let o = Jc.getComponent(s);
                if (o !== 0) {
                    let a = Xc.getComponent(s);
                    Yc.multiplyMatrices(
                        n.bones[a].matrixWorld,
                        n.boneInverses[a]
                    ),
                        t.addScaledVector($x.copy(qc).applyMatrix4(Yc), o);
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse);
        }
    };
zs.prototype.isSkinnedMesh = !0;
var Bs = class extends Be {
    constructor() {
        super(), (this.type = "Bone");
    }
};
Bs.prototype.isBone = !0;
var Tn = class extends ft {
    constructor(e = null, t = 1, n = 1, i, s, o, a, l, c = st, h = st, u, d) {
        super(null, o, a, l, c, h, i, s, u, d),
            (this.image = { data: e, width: t, height: n }),
            (this.magFilter = c),
            (this.minFilter = h),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
    }
};
Tn.prototype.isDataTexture = !0;
var Zc = new me(),
    jx = new me(),
    $a = class r {
        constructor(e = [], t = []) {
            (this.uuid = Ct()),
                (this.bones = e.slice(0)),
                (this.boneInverses = t),
                (this.boneMatrices = null),
                (this.boneTexture = null),
                (this.boneTextureSize = 0),
                (this.frame = -1),
                this.init();
        }
        init() {
            let e = this.bones,
                t = this.boneInverses;
            if (
                ((this.boneMatrices = new Float32Array(e.length * 16)),
                t.length === 0)
            )
                this.calculateInverses();
            else if (e.length !== t.length) {
                console.warn(
                    "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
                ),
                    (this.boneInverses = []);
                for (let n = 0, i = this.bones.length; n < i; n++)
                    this.boneInverses.push(new me());
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let e = 0, t = this.bones.length; e < t; e++) {
                let n = new me();
                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
                    this.boneInverses.push(n);
            }
        }
        pose() {
            for (let e = 0, t = this.bones.length; e < t; e++) {
                let n = this.bones[e];
                n && n.matrixWorld.copy(this.boneInverses[e]).invert();
            }
            for (let e = 0, t = this.bones.length; e < t; e++) {
                let n = this.bones[e];
                n &&
                    (n.parent && n.parent.isBone
                        ? (n.matrix.copy(n.parent.matrixWorld).invert(),
                          n.matrix.multiply(n.matrixWorld))
                        : n.matrix.copy(n.matrixWorld),
                    n.matrix.decompose(n.position, n.quaternion, n.scale));
            }
        }
        update() {
            let e = this.bones,
                t = this.boneInverses,
                n = this.boneMatrices,
                i = this.boneTexture;
            for (let s = 0, o = e.length; s < o; s++) {
                let a = e[s] ? e[s].matrixWorld : jx;
                Zc.multiplyMatrices(a, t[s]), Zc.toArray(n, s * 16);
            }
            i !== null && (i.needsUpdate = !0);
        }
        clone() {
            return new r(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
            let e = Math.sqrt(this.bones.length * 4);
            (e = iu(e)), (e = Math.max(e, 4));
            let t = new Float32Array(e * e * 4);
            t.set(this.boneMatrices);
            let n = new Tn(t, e, e, lt, on);
            return (
                (n.needsUpdate = !0),
                (this.boneMatrices = t),
                (this.boneTexture = n),
                (this.boneTextureSize = e),
                this
            );
        }
        getBoneByName(e) {
            for (let t = 0, n = this.bones.length; t < n; t++) {
                let i = this.bones[t];
                if (i.name === e) return i;
            }
        }
        dispose() {
            this.boneTexture !== null &&
                (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
            this.uuid = e.uuid;
            for (let n = 0, i = e.bones.length; n < i; n++) {
                let s = e.bones[n],
                    o = t[s];
                o === void 0 &&
                    (console.warn(
                        "THREE.Skeleton: No bone found with UUID:",
                        s
                    ),
                    (o = new Bs())),
                    this.bones.push(o),
                    this.boneInverses.push(
                        new me().fromArray(e.boneInverses[n])
                    );
            }
            return this.init(), this;
        }
        toJSON() {
            let e = {
                metadata: {
                    version: 4.5,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON",
                },
                bones: [],
                boneInverses: [],
            };
            e.uuid = this.uuid;
            let t = this.bones,
                n = this.boneInverses;
            for (let i = 0, s = t.length; i < s; i++) {
                let o = t[i];
                e.bones.push(o.uuid);
                let a = n[i];
                e.boneInverses.push(a.toArray());
            }
            return e;
        }
    },
    Rn = class extends ze {
        constructor(e, t, n, i = 1) {
            typeof n == "number" &&
                ((i = n),
                (n = !1),
                console.error(
                    "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
                )),
                super(e, t, n),
                (this.meshPerAttribute = i);
        }
        copy(e) {
            return (
                super.copy(e),
                (this.meshPerAttribute = e.meshPerAttribute),
                this
            );
        }
        toJSON() {
            let e = super.toJSON();
            return (
                (e.meshPerAttribute = this.meshPerAttribute),
                (e.isInstancedBufferAttribute = !0),
                e
            );
        }
    };
Rn.prototype.isInstancedBufferAttribute = !0;
var $c = new me(),
    jc = new me(),
    Tr = [],
    cs = new nt(),
    to = class extends nt {
        constructor(e, t, n) {
            super(e, t),
                (this.instanceMatrix = new Rn(new Float32Array(n * 16), 16)),
                (this.instanceColor = null),
                (this.count = n),
                (this.frustumCulled = !1);
        }
        copy(e) {
            return (
                super.copy(e),
                this.instanceMatrix.copy(e.instanceMatrix),
                e.instanceColor !== null &&
                    (this.instanceColor = e.instanceColor.clone()),
                (this.count = e.count),
                this
            );
        }
        getColorAt(e, t) {
            t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
            t.fromArray(this.instanceMatrix.array, e * 16);
        }
        raycast(e, t) {
            let n = this.matrixWorld,
                i = this.count;
            if (
                ((cs.geometry = this.geometry),
                (cs.material = this.material),
                cs.material !== void 0)
            )
                for (let s = 0; s < i; s++) {
                    this.getMatrixAt(s, $c),
                        jc.multiplyMatrices(n, $c),
                        (cs.matrixWorld = jc),
                        cs.raycast(e, Tr);
                    for (let o = 0, a = Tr.length; o < a; o++) {
                        let l = Tr[o];
                        (l.instanceId = s), (l.object = this), t.push(l);
                    }
                    Tr.length = 0;
                }
        }
        setColorAt(e, t) {
            this.instanceColor === null &&
                (this.instanceColor = new Rn(
                    new Float32Array(this.instanceMatrix.count * 3),
                    3
                )),
                t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
            t.toArray(this.instanceMatrix.array, e * 16);
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({ type: "dispose" });
        }
    };
to.prototype.isInstancedMesh = !0;
var ht = class extends ct {
    constructor(e) {
        super(),
            (this.type = "LineBasicMaterial"),
            (this.color = new re(16777215)),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            this
        );
    }
};
ht.prototype.isLineBasicMaterial = !0;
var Qc = new M(),
    Kc = new M(),
    eh = new me(),
    ba = new un(),
    Er = new hn(),
    $t = class extends Be {
        constructor(e = new _e(), t = new ht()) {
            super(),
                (this.type = "Line"),
                (this.geometry = e),
                (this.material = t),
                this.updateMorphTargets();
        }
        copy(e) {
            return (
                super.copy(e),
                (this.material = e.material),
                (this.geometry = e.geometry),
                this
            );
        }
        computeLineDistances() {
            let e = this.geometry;
            if (e.isBufferGeometry)
                if (e.index === null) {
                    let t = e.attributes.position,
                        n = [0];
                    for (let i = 1, s = t.count; i < s; i++)
                        Qc.fromBufferAttribute(t, i - 1),
                            Kc.fromBufferAttribute(t, i),
                            (n[i] = n[i - 1]),
                            (n[i] += Qc.distanceTo(Kc));
                    e.setAttribute("lineDistance", new de(n, 1));
                } else
                    console.warn(
                        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                    );
            else
                e.isGeometry &&
                    console.error(
                        "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
            return this;
        }
        raycast(e, t) {
            let n = this.geometry,
                i = this.matrixWorld,
                s = e.params.Line.threshold,
                o = n.drawRange;
            if (
                (n.boundingSphere === null && n.computeBoundingSphere(),
                Er.copy(n.boundingSphere),
                Er.applyMatrix4(i),
                (Er.radius += s),
                e.ray.intersectsSphere(Er) === !1)
            )
                return;
            eh.copy(i).invert(), ba.copy(e.ray).applyMatrix4(eh);
            let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                l = a * a,
                c = new M(),
                h = new M(),
                u = new M(),
                d = new M(),
                f = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
                let m = n.index,
                    v = n.attributes.position;
                if (m !== null) {
                    let g = Math.max(0, o.start),
                        p = Math.min(m.count, o.start + o.count);
                    for (let _ = g, y = p - 1; _ < y; _ += f) {
                        let w = m.getX(_),
                            A = m.getX(_ + 1);
                        if (
                            (c.fromBufferAttribute(v, w),
                            h.fromBufferAttribute(v, A),
                            ba.distanceSqToSegment(c, h, d, u) > l)
                        )
                            continue;
                        d.applyMatrix4(this.matrixWorld);
                        let I = e.ray.origin.distanceTo(d);
                        I < e.near ||
                            I > e.far ||
                            t.push({
                                distance: I,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: _,
                                face: null,
                                faceIndex: null,
                                object: this,
                            });
                    }
                } else {
                    let g = Math.max(0, o.start),
                        p = Math.min(v.count, o.start + o.count);
                    for (let _ = g, y = p - 1; _ < y; _ += f) {
                        if (
                            (c.fromBufferAttribute(v, _),
                            h.fromBufferAttribute(v, _ + 1),
                            ba.distanceSqToSegment(c, h, d, u) > l)
                        )
                            continue;
                        d.applyMatrix4(this.matrixWorld);
                        let A = e.ray.origin.distanceTo(d);
                        A < e.near ||
                            A > e.far ||
                            t.push({
                                distance: A,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: _,
                                face: null,
                                faceIndex: null,
                                object: this,
                            });
                    }
                }
            } else
                n.isGeometry &&
                    console.error(
                        "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
        }
        updateMorphTargets() {
            let e = this.geometry;
            if (e.isBufferGeometry) {
                let t = e.morphAttributes,
                    n = Object.keys(t);
                if (n.length > 0) {
                    let i = t[n[0]];
                    if (i !== void 0) {
                        (this.morphTargetInfluences = []),
                            (this.morphTargetDictionary = {});
                        for (let s = 0, o = i.length; s < o; s++) {
                            let a = i[s].name || String(s);
                            this.morphTargetInfluences.push(0),
                                (this.morphTargetDictionary[a] = s);
                        }
                    }
                }
            } else {
                let t = e.morphTargets;
                t !== void 0 &&
                    t.length > 0 &&
                    console.error(
                        "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
            }
        }
    };
$t.prototype.isLine = !0;
var th = new M(),
    nh = new M(),
    bt = class extends $t {
        constructor(e, t) {
            super(e, t), (this.type = "LineSegments");
        }
        computeLineDistances() {
            let e = this.geometry;
            if (e.isBufferGeometry)
                if (e.index === null) {
                    let t = e.attributes.position,
                        n = [];
                    for (let i = 0, s = t.count; i < s; i += 2)
                        th.fromBufferAttribute(t, i),
                            nh.fromBufferAttribute(t, i + 1),
                            (n[i] = i === 0 ? 0 : n[i - 1]),
                            (n[i + 1] = n[i] + th.distanceTo(nh));
                    e.setAttribute("lineDistance", new de(n, 1));
                } else
                    console.warn(
                        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                    );
            else
                e.isGeometry &&
                    console.error(
                        "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
            return this;
        }
    };
bt.prototype.isLineSegments = !0;
var no = class extends $t {
    constructor(e, t) {
        super(e, t), (this.type = "LineLoop");
    }
};
no.prototype.isLineLoop = !0;
var Cn = class extends ct {
    constructor(e) {
        super(),
            (this.type = "PointsMaterial"),
            (this.color = new re(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            this
        );
    }
};
Cn.prototype.isPointsMaterial = !0;
var ih = new me(),
    ja = new un(),
    Ar = new hn(),
    Rr = new M(),
    Bi = class extends Be {
        constructor(e = new _e(), t = new Cn()) {
            super(),
                (this.type = "Points"),
                (this.geometry = e),
                (this.material = t),
                this.updateMorphTargets();
        }
        copy(e) {
            return (
                super.copy(e),
                (this.material = e.material),
                (this.geometry = e.geometry),
                this
            );
        }
        raycast(e, t) {
            let n = this.geometry,
                i = this.matrixWorld,
                s = e.params.Points.threshold,
                o = n.drawRange;
            if (
                (n.boundingSphere === null && n.computeBoundingSphere(),
                Ar.copy(n.boundingSphere),
                Ar.applyMatrix4(i),
                (Ar.radius += s),
                e.ray.intersectsSphere(Ar) === !1)
            )
                return;
            ih.copy(i).invert(), ja.copy(e.ray).applyMatrix4(ih);
            let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                l = a * a;
            if (n.isBufferGeometry) {
                let c = n.index,
                    u = n.attributes.position;
                if (c !== null) {
                    let d = Math.max(0, o.start),
                        f = Math.min(c.count, o.start + o.count);
                    for (let m = d, x = f; m < x; m++) {
                        let v = c.getX(m);
                        Rr.fromBufferAttribute(u, v),
                            sh(Rr, v, l, i, e, t, this);
                    }
                } else {
                    let d = Math.max(0, o.start),
                        f = Math.min(u.count, o.start + o.count);
                    for (let m = d, x = f; m < x; m++)
                        Rr.fromBufferAttribute(u, m),
                            sh(Rr, m, l, i, e, t, this);
                }
            } else
                console.error(
                    "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
        }
        updateMorphTargets() {
            let e = this.geometry;
            if (e.isBufferGeometry) {
                let t = e.morphAttributes,
                    n = Object.keys(t);
                if (n.length > 0) {
                    let i = t[n[0]];
                    if (i !== void 0) {
                        (this.morphTargetInfluences = []),
                            (this.morphTargetDictionary = {});
                        for (let s = 0, o = i.length; s < o; s++) {
                            let a = i[s].name || String(s);
                            this.morphTargetInfluences.push(0),
                                (this.morphTargetDictionary[a] = s);
                        }
                    }
                }
            } else {
                let t = e.morphTargets;
                t !== void 0 &&
                    t.length > 0 &&
                    console.error(
                        "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                    );
            }
        }
    };
Bi.prototype.isPoints = !0;
function sh(r, e, t, n, i, s, o) {
    let a = ja.distanceSqToPoint(r);
    if (a < t) {
        let l = new M();
        ja.closestPointToPoint(r, l), l.applyMatrix4(n);
        let c = i.ray.origin.distanceTo(l);
        if (c < i.near || c > i.far) return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o,
        });
    }
}
var Qa = class extends ft {
    constructor(e, t, n, i, s, o, a, l, c) {
        super(e, t, n, i, s, o, a, l, c),
            (this.format = a !== void 0 ? a : Jn),
            (this.minFilter = o !== void 0 ? o : tt),
            (this.magFilter = s !== void 0 ? s : tt),
            (this.generateMipmaps = !1);
        let h = this;
        function u() {
            (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
        }
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        let e = this.image;
        "requestVideoFrameCallback" in e === !1 &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
    }
};
Qa.prototype.isVideoTexture = !0;
var Ka = class extends ft {
    constructor(e, t, n) {
        super({ width: e, height: t }),
            (this.format = n),
            (this.magFilter = st),
            (this.minFilter = st),
            (this.generateMipmaps = !1),
            (this.needsUpdate = !0);
    }
};
Ka.prototype.isFramebufferTexture = !0;
var io = class extends ft {
    constructor(e, t, n, i, s, o, a, l, c, h, u, d) {
        super(null, o, a, l, c, h, i, s, u, d),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
    }
};
io.prototype.isCompressedTexture = !0;
var el = class extends ft {
    constructor(e, t, n, i, s, o, a, l, c) {
        super(e, t, n, i, s, o, a, l, c), (this.needsUpdate = !0);
    }
};
el.prototype.isCanvasTexture = !0;
var so = class r extends _e {
        constructor(e = 1, t = 8, n = 0, i = Math.PI * 2) {
            super(),
                (this.type = "CircleGeometry"),
                (this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: i,
                }),
                (t = Math.max(3, t));
            let s = [],
                o = [],
                a = [],
                l = [],
                c = new M(),
                h = new W();
            o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
            for (let u = 0, d = 3; u <= t; u++, d += 3) {
                let f = n + (u / t) * i;
                (c.x = e * Math.cos(f)),
                    (c.y = e * Math.sin(f)),
                    o.push(c.x, c.y, c.z),
                    a.push(0, 0, 1),
                    (h.x = (o[d] / e + 1) / 2),
                    (h.y = (o[d + 1] / e + 1) / 2),
                    l.push(h.x, h.y);
            }
            for (let u = 1; u <= t; u++) s.push(u, u + 1, 0);
            this.setIndex(s),
                this.setAttribute("position", new de(o, 3)),
                this.setAttribute("normal", new de(a, 3)),
                this.setAttribute("uv", new de(l, 2));
        }
        static fromJSON(e) {
            return new r(e.radius, e.segments, e.thetaStart, e.thetaLength);
        }
    },
    Ui = class r extends _e {
        constructor(
            e = 1,
            t = 1,
            n = 1,
            i = 8,
            s = 1,
            o = !1,
            a = 0,
            l = Math.PI * 2
        ) {
            super(),
                (this.type = "CylinderGeometry"),
                (this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: i,
                    heightSegments: s,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: l,
                });
            let c = this;
            (i = Math.floor(i)), (s = Math.floor(s));
            let h = [],
                u = [],
                d = [],
                f = [],
                m = 0,
                x = [],
                v = n / 2,
                g = 0;
            p(),
                o === !1 && (e > 0 && _(!0), t > 0 && _(!1)),
                this.setIndex(h),
                this.setAttribute("position", new de(u, 3)),
                this.setAttribute("normal", new de(d, 3)),
                this.setAttribute("uv", new de(f, 2));
            function p() {
                let y = new M(),
                    w = new M(),
                    A = 0,
                    C = (t - e) / n;
                for (let I = 0; I <= s; I++) {
                    let k = [],
                        z = I / s,
                        P = z * (t - e) + e;
                    for (let b = 0; b <= i; b++) {
                        let E = b / i,
                            D = E * l + a,
                            U = Math.sin(D),
                            F = Math.cos(D);
                        (w.x = P * U),
                            (w.y = -z * n + v),
                            (w.z = P * F),
                            u.push(w.x, w.y, w.z),
                            y.set(U, C, F).normalize(),
                            d.push(y.x, y.y, y.z),
                            f.push(E, 1 - z),
                            k.push(m++);
                    }
                    x.push(k);
                }
                for (let I = 0; I < i; I++)
                    for (let k = 0; k < s; k++) {
                        let z = x[k][I],
                            P = x[k + 1][I],
                            b = x[k + 1][I + 1],
                            E = x[k][I + 1];
                        h.push(z, P, E), h.push(P, b, E), (A += 6);
                    }
                c.addGroup(g, A, 0), (g += A);
            }
            function _(y) {
                let w = m,
                    A = new W(),
                    C = new M(),
                    I = 0,
                    k = y === !0 ? e : t,
                    z = y === !0 ? 1 : -1;
                for (let b = 1; b <= i; b++)
                    u.push(0, v * z, 0), d.push(0, z, 0), f.push(0.5, 0.5), m++;
                let P = m;
                for (let b = 0; b <= i; b++) {
                    let D = (b / i) * l + a,
                        U = Math.cos(D),
                        F = Math.sin(D);
                    (C.x = k * F),
                        (C.y = v * z),
                        (C.z = k * U),
                        u.push(C.x, C.y, C.z),
                        d.push(0, z, 0),
                        (A.x = U * 0.5 + 0.5),
                        (A.y = F * 0.5 * z + 0.5),
                        f.push(A.x, A.y),
                        m++;
                }
                for (let b = 0; b < i; b++) {
                    let E = w + b,
                        D = P + b;
                    y === !0 ? h.push(D, D + 1, E) : h.push(D + 1, D, E),
                        (I += 3);
                }
                c.addGroup(g, I, y === !0 ? 1 : 2), (g += I);
            }
        }
        static fromJSON(e) {
            return new r(
                e.radiusTop,
                e.radiusBottom,
                e.height,
                e.radialSegments,
                e.heightSegments,
                e.openEnded,
                e.thetaStart,
                e.thetaLength
            );
        }
    },
    ro = class r extends Ui {
        constructor(
            e = 1,
            t = 1,
            n = 8,
            i = 1,
            s = !1,
            o = 0,
            a = Math.PI * 2
        ) {
            super(0, e, t, n, i, s, o, a),
                (this.type = "ConeGeometry"),
                (this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: s,
                    thetaStart: o,
                    thetaLength: a,
                });
        }
        static fromJSON(e) {
            return new r(
                e.radius,
                e.height,
                e.radialSegments,
                e.heightSegments,
                e.openEnded,
                e.thetaStart,
                e.thetaLength
            );
        }
    },
    Ln = class r extends _e {
        constructor(e = [], t = [], n = 1, i = 0) {
            super(),
                (this.type = "PolyhedronGeometry"),
                (this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: i,
                });
            let s = [],
                o = [];
            a(i),
                c(n),
                h(),
                this.setAttribute("position", new de(s, 3)),
                this.setAttribute("normal", new de(s.slice(), 3)),
                this.setAttribute("uv", new de(o, 2)),
                i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
            function a(p) {
                let _ = new M(),
                    y = new M(),
                    w = new M();
                for (let A = 0; A < t.length; A += 3)
                    f(t[A + 0], _),
                        f(t[A + 1], y),
                        f(t[A + 2], w),
                        l(_, y, w, p);
            }
            function l(p, _, y, w) {
                let A = w + 1,
                    C = [];
                for (let I = 0; I <= A; I++) {
                    C[I] = [];
                    let k = p.clone().lerp(y, I / A),
                        z = _.clone().lerp(y, I / A),
                        P = A - I;
                    for (let b = 0; b <= P; b++)
                        b === 0 && I === A
                            ? (C[I][b] = k)
                            : (C[I][b] = k.clone().lerp(z, b / P));
                }
                for (let I = 0; I < A; I++)
                    for (let k = 0; k < 2 * (A - I) - 1; k++) {
                        let z = Math.floor(k / 2);
                        k % 2 === 0
                            ? (d(C[I][z + 1]), d(C[I + 1][z]), d(C[I][z]))
                            : (d(C[I][z + 1]),
                              d(C[I + 1][z + 1]),
                              d(C[I + 1][z]));
                    }
            }
            function c(p) {
                let _ = new M();
                for (let y = 0; y < s.length; y += 3)
                    (_.x = s[y + 0]),
                        (_.y = s[y + 1]),
                        (_.z = s[y + 2]),
                        _.normalize().multiplyScalar(p),
                        (s[y + 0] = _.x),
                        (s[y + 1] = _.y),
                        (s[y + 2] = _.z);
            }
            function h() {
                let p = new M();
                for (let _ = 0; _ < s.length; _ += 3) {
                    (p.x = s[_ + 0]), (p.y = s[_ + 1]), (p.z = s[_ + 2]);
                    let y = v(p) / 2 / Math.PI + 0.5,
                        w = g(p) / Math.PI + 0.5;
                    o.push(y, 1 - w);
                }
                m(), u();
            }
            function u() {
                for (let p = 0; p < o.length; p += 6) {
                    let _ = o[p + 0],
                        y = o[p + 2],
                        w = o[p + 4],
                        A = Math.max(_, y, w),
                        C = Math.min(_, y, w);
                    A > 0.9 &&
                        C < 0.1 &&
                        (_ < 0.2 && (o[p + 0] += 1),
                        y < 0.2 && (o[p + 2] += 1),
                        w < 0.2 && (o[p + 4] += 1));
                }
            }
            function d(p) {
                s.push(p.x, p.y, p.z);
            }
            function f(p, _) {
                let y = p * 3;
                (_.x = e[y + 0]), (_.y = e[y + 1]), (_.z = e[y + 2]);
            }
            function m() {
                let p = new M(),
                    _ = new M(),
                    y = new M(),
                    w = new M(),
                    A = new W(),
                    C = new W(),
                    I = new W();
                for (let k = 0, z = 0; k < s.length; k += 9, z += 6) {
                    p.set(s[k + 0], s[k + 1], s[k + 2]),
                        _.set(s[k + 3], s[k + 4], s[k + 5]),
                        y.set(s[k + 6], s[k + 7], s[k + 8]),
                        A.set(o[z + 0], o[z + 1]),
                        C.set(o[z + 2], o[z + 3]),
                        I.set(o[z + 4], o[z + 5]),
                        w.copy(p).add(_).add(y).divideScalar(3);
                    let P = v(w);
                    x(A, z + 0, p, P), x(C, z + 2, _, P), x(I, z + 4, y, P);
                }
            }
            function x(p, _, y, w) {
                w < 0 && p.x === 1 && (o[_] = p.x - 1),
                    y.x === 0 && y.z === 0 && (o[_] = w / 2 / Math.PI + 0.5);
            }
            function v(p) {
                return Math.atan2(p.z, -p.x);
            }
            function g(p) {
                return Math.atan2(-p.y, Math.sqrt(p.x * p.x + p.z * p.z));
            }
        }
        static fromJSON(e) {
            return new r(e.vertices, e.indices, e.radius, e.details);
        }
    },
    oo = class r extends Ln {
        constructor(e = 1, t = 0) {
            let n = (1 + Math.sqrt(5)) / 2,
                i = 1 / n,
                s = [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    0,
                    -i,
                    -n,
                    0,
                    -i,
                    n,
                    0,
                    i,
                    -n,
                    0,
                    i,
                    n,
                    -i,
                    -n,
                    0,
                    -i,
                    n,
                    0,
                    i,
                    -n,
                    0,
                    i,
                    n,
                    0,
                    -n,
                    0,
                    -i,
                    n,
                    0,
                    -i,
                    -n,
                    0,
                    i,
                    n,
                    0,
                    i,
                ],
                o = [
                    3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6,
                    15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8,
                    2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6,
                    13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11,
                    18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5,
                    19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14,
                    1, 14, 5, 1, 5, 9,
                ];
            super(s, o, e, t),
                (this.type = "DodecahedronGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
            return new r(e.radius, e.detail);
        }
    },
    Cr = new M(),
    Lr = new M(),
    Sa = new M(),
    Pr = new vt(),
    ao = class extends _e {
        constructor(e = null, t = 1) {
            if (
                (super(),
                (this.type = "EdgesGeometry"),
                (this.parameters = { geometry: e, thresholdAngle: t }),
                e !== null)
            ) {
                let i = Math.pow(10, 4),
                    s = Math.cos(Zn * t),
                    o = e.getIndex(),
                    a = e.getAttribute("position"),
                    l = o ? o.count : a.count,
                    c = [0, 0, 0],
                    h = ["a", "b", "c"],
                    u = new Array(3),
                    d = {},
                    f = [];
                for (let m = 0; m < l; m += 3) {
                    o
                        ? ((c[0] = o.getX(m)),
                          (c[1] = o.getX(m + 1)),
                          (c[2] = o.getX(m + 2)))
                        : ((c[0] = m), (c[1] = m + 1), (c[2] = m + 2));
                    let { a: x, b: v, c: g } = Pr;
                    if (
                        (x.fromBufferAttribute(a, c[0]),
                        v.fromBufferAttribute(a, c[1]),
                        g.fromBufferAttribute(a, c[2]),
                        Pr.getNormal(Sa),
                        (u[0] = `${Math.round(x.x * i)},${Math.round(
                            x.y * i
                        )},${Math.round(x.z * i)}`),
                        (u[1] = `${Math.round(v.x * i)},${Math.round(
                            v.y * i
                        )},${Math.round(v.z * i)}`),
                        (u[2] = `${Math.round(g.x * i)},${Math.round(
                            g.y * i
                        )},${Math.round(g.z * i)}`),
                        !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
                    )
                        for (let p = 0; p < 3; p++) {
                            let _ = (p + 1) % 3,
                                y = u[p],
                                w = u[_],
                                A = Pr[h[p]],
                                C = Pr[h[_]],
                                I = `${y}_${w}`,
                                k = `${w}_${y}`;
                            k in d && d[k]
                                ? (Sa.dot(d[k].normal) <= s &&
                                      (f.push(A.x, A.y, A.z),
                                      f.push(C.x, C.y, C.z)),
                                  (d[k] = null))
                                : I in d ||
                                  (d[I] = {
                                      index0: c[p],
                                      index1: c[_],
                                      normal: Sa.clone(),
                                  });
                        }
                }
                for (let m in d)
                    if (d[m]) {
                        let { index0: x, index1: v } = d[m];
                        Cr.fromBufferAttribute(a, x),
                            Lr.fromBufferAttribute(a, v),
                            f.push(Cr.x, Cr.y, Cr.z),
                            f.push(Lr.x, Lr.y, Lr.z);
                    }
                this.setAttribute("position", new de(f, 3));
            }
        }
    },
    Et = class {
        constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
            return (
                console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
        }
        getPointAt(e, t) {
            let n = this.getUtoTmapping(e);
            return this.getPoint(n, t);
        }
        getPoints(e = 5) {
            let t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return t;
        }
        getSpacedPoints(e = 5) {
            let t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
            return t;
        }
        getLength() {
            let e = this.getLengths();
            return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
            if (
                this.cacheArcLengths &&
                this.cacheArcLengths.length === e + 1 &&
                !this.needsUpdate
            )
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            let t = [],
                n,
                i = this.getPoint(0),
                s = 0;
            t.push(0);
            for (let o = 1; o <= e; o++)
                (n = this.getPoint(o / e)),
                    (s += n.distanceTo(i)),
                    t.push(s),
                    (i = n);
            return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
            let n = this.getLengths(),
                i = 0,
                s = n.length,
                o;
            t ? (o = t) : (o = e * n[s - 1]);
            let a = 0,
                l = s - 1,
                c;
            for (; a <= l; )
                if (((i = Math.floor(a + (l - a) / 2)), (c = n[i] - o), c < 0))
                    a = i + 1;
                else if (c > 0) l = i - 1;
                else {
                    l = i;
                    break;
                }
            if (((i = l), n[i] === o)) return i / (s - 1);
            let h = n[i],
                d = n[i + 1] - h,
                f = (o - h) / d;
            return (i + f) / (s - 1);
        }
        getTangent(e, t) {
            let i = e - 1e-4,
                s = e + 1e-4;
            i < 0 && (i = 0), s > 1 && (s = 1);
            let o = this.getPoint(i),
                a = this.getPoint(s),
                l = t || (o.isVector2 ? new W() : new M());
            return l.copy(a).sub(o).normalize(), l;
        }
        getTangentAt(e, t) {
            let n = this.getUtoTmapping(e);
            return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
            let n = new M(),
                i = [],
                s = [],
                o = [],
                a = new M(),
                l = new me();
            for (let f = 0; f <= e; f++) {
                let m = f / e;
                i[f] = this.getTangentAt(m, new M());
            }
            (s[0] = new M()), (o[0] = new M());
            let c = Number.MAX_VALUE,
                h = Math.abs(i[0].x),
                u = Math.abs(i[0].y),
                d = Math.abs(i[0].z);
            h <= c && ((c = h), n.set(1, 0, 0)),
                u <= c && ((c = u), n.set(0, 1, 0)),
                d <= c && n.set(0, 0, 1),
                a.crossVectors(i[0], n).normalize(),
                s[0].crossVectors(i[0], a),
                o[0].crossVectors(i[0], s[0]);
            for (let f = 1; f <= e; f++) {
                if (
                    ((s[f] = s[f - 1].clone()),
                    (o[f] = o[f - 1].clone()),
                    a.crossVectors(i[f - 1], i[f]),
                    a.length() > Number.EPSILON)
                ) {
                    a.normalize();
                    let m = Math.acos(mt(i[f - 1].dot(i[f]), -1, 1));
                    s[f].applyMatrix4(l.makeRotationAxis(a, m));
                }
                o[f].crossVectors(i[f], s[f]);
            }
            if (t === !0) {
                let f = Math.acos(mt(s[0].dot(s[e]), -1, 1));
                (f /= e), i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (f = -f);
                for (let m = 1; m <= e; m++)
                    s[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)),
                        o[m].crossVectors(i[m], s[m]);
            }
            return { tangents: i, normals: s, binormals: o };
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
            let e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON",
                },
            };
            return (
                (e.arcLengthDivisions = this.arcLengthDivisions),
                (e.type = this.type),
                e
            );
        }
        fromJSON(e) {
            return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
    },
    Oi = class extends Et {
        constructor(
            e = 0,
            t = 0,
            n = 1,
            i = 1,
            s = 0,
            o = Math.PI * 2,
            a = !1,
            l = 0
        ) {
            super(),
                (this.type = "EllipseCurve"),
                (this.aX = e),
                (this.aY = t),
                (this.xRadius = n),
                (this.yRadius = i),
                (this.aStartAngle = s),
                (this.aEndAngle = o),
                (this.aClockwise = a),
                (this.aRotation = l);
        }
        getPoint(e, t) {
            let n = t || new W(),
                i = Math.PI * 2,
                s = this.aEndAngle - this.aStartAngle,
                o = Math.abs(s) < Number.EPSILON;
            for (; s < 0; ) s += i;
            for (; s > i; ) s -= i;
            s < Number.EPSILON && (o ? (s = 0) : (s = i)),
                this.aClockwise === !0 &&
                    !o &&
                    (s === i ? (s = -i) : (s = s - i));
            let a = this.aStartAngle + e * s,
                l = this.aX + this.xRadius * Math.cos(a),
                c = this.aY + this.yRadius * Math.sin(a);
            if (this.aRotation !== 0) {
                let h = Math.cos(this.aRotation),
                    u = Math.sin(this.aRotation),
                    d = l - this.aX,
                    f = c - this.aY;
                (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
            }
            return n.set(l, c);
        }
        copy(e) {
            return (
                super.copy(e),
                (this.aX = e.aX),
                (this.aY = e.aY),
                (this.xRadius = e.xRadius),
                (this.yRadius = e.yRadius),
                (this.aStartAngle = e.aStartAngle),
                (this.aEndAngle = e.aEndAngle),
                (this.aClockwise = e.aClockwise),
                (this.aRotation = e.aRotation),
                this
            );
        }
        toJSON() {
            let e = super.toJSON();
            return (
                (e.aX = this.aX),
                (e.aY = this.aY),
                (e.xRadius = this.xRadius),
                (e.yRadius = this.yRadius),
                (e.aStartAngle = this.aStartAngle),
                (e.aEndAngle = this.aEndAngle),
                (e.aClockwise = this.aClockwise),
                (e.aRotation = this.aRotation),
                e
            );
        }
        fromJSON(e) {
            return (
                super.fromJSON(e),
                (this.aX = e.aX),
                (this.aY = e.aY),
                (this.xRadius = e.xRadius),
                (this.yRadius = e.yRadius),
                (this.aStartAngle = e.aStartAngle),
                (this.aEndAngle = e.aEndAngle),
                (this.aClockwise = e.aClockwise),
                (this.aRotation = e.aRotation),
                this
            );
        }
    };
Oi.prototype.isEllipseCurve = !0;
var lo = class extends Oi {
    constructor(e, t, n, i, s, o) {
        super(e, t, n, n, i, s, o), (this.type = "ArcCurve");
    }
};
lo.prototype.isArcCurve = !0;
function Ol() {
    let r = 0,
        e = 0,
        t = 0,
        n = 0;
    function i(s, o, a, l) {
        (r = s),
            (e = a),
            (t = -3 * s + 3 * o - 2 * a - l),
            (n = 2 * s - 2 * o + a + l);
    }
    return {
        initCatmullRom: function (s, o, a, l, c) {
            i(o, a, c * (a - s), c * (l - o));
        },
        initNonuniformCatmullRom: function (s, o, a, l, c, h, u) {
            let d = (o - s) / c - (a - s) / (c + h) + (a - o) / h,
                f = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
            (d *= h), (f *= h), i(o, a, d, f);
        },
        calc: function (s) {
            let o = s * s,
                a = o * s;
            return r + e * s + t * o + n * a;
        },
    };
}
var Ir = new M(),
    Ta = new Ol(),
    Ea = new Ol(),
    Aa = new Ol(),
    co = class extends Et {
        constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
            super(),
                (this.type = "CatmullRomCurve3"),
                (this.points = e),
                (this.closed = t),
                (this.curveType = n),
                (this.tension = i);
        }
        getPoint(e, t = new M()) {
            let n = t,
                i = this.points,
                s = i.length,
                o = (s - (this.closed ? 0 : 1)) * e,
                a = Math.floor(o),
                l = o - a;
            this.closed
                ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
                : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
            let c, h;
            this.closed || a > 0
                ? (c = i[(a - 1) % s])
                : (Ir.subVectors(i[0], i[1]).add(i[0]), (c = Ir));
            let u = i[a % s],
                d = i[(a + 1) % s];
            if (
                (this.closed || a + 2 < s
                    ? (h = i[(a + 2) % s])
                    : (Ir.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]),
                      (h = Ir)),
                this.curveType === "centripetal" ||
                    this.curveType === "chordal")
            ) {
                let f = this.curveType === "chordal" ? 0.5 : 0.25,
                    m = Math.pow(c.distanceToSquared(u), f),
                    x = Math.pow(u.distanceToSquared(d), f),
                    v = Math.pow(d.distanceToSquared(h), f);
                x < 1e-4 && (x = 1),
                    m < 1e-4 && (m = x),
                    v < 1e-4 && (v = x),
                    Ta.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, x, v),
                    Ea.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, x, v),
                    Aa.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, x, v);
            } else
                this.curveType === "catmullrom" &&
                    (Ta.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
                    Ea.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
                    Aa.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
            return n.set(Ta.calc(l), Ea.calc(l), Aa.calc(l)), n;
        }
        copy(e) {
            super.copy(e), (this.points = []);
            for (let t = 0, n = e.points.length; t < n; t++) {
                let i = e.points[t];
                this.points.push(i.clone());
            }
            return (
                (this.closed = e.closed),
                (this.curveType = e.curveType),
                (this.tension = e.tension),
                this
            );
        }
        toJSON() {
            let e = super.toJSON();
            e.points = [];
            for (let t = 0, n = this.points.length; t < n; t++) {
                let i = this.points[t];
                e.points.push(i.toArray());
            }
            return (
                (e.closed = this.closed),
                (e.curveType = this.curveType),
                (e.tension = this.tension),
                e
            );
        }
        fromJSON(e) {
            super.fromJSON(e), (this.points = []);
            for (let t = 0, n = e.points.length; t < n; t++) {
                let i = e.points[t];
                this.points.push(new M().fromArray(i));
            }
            return (
                (this.closed = e.closed),
                (this.curveType = e.curveType),
                (this.tension = e.tension),
                this
            );
        }
    };
co.prototype.isCatmullRomCurve3 = !0;
function rh(r, e, t, n, i) {
    let s = (n - e) * 0.5,
        o = (i - t) * 0.5,
        a = r * r,
        l = r * a;
    return (
        (2 * t - 2 * n + s + o) * l +
        (-3 * t + 3 * n - 2 * s - o) * a +
        s * r +
        t
    );
}
function Qx(r, e) {
    let t = 1 - r;
    return t * t * e;
}
function Kx(r, e) {
    return 2 * (1 - r) * r * e;
}
function ey(r, e) {
    return r * r * e;
}
function gs(r, e, t, n) {
    return Qx(r, e) + Kx(r, t) + ey(r, n);
}
function ty(r, e) {
    let t = 1 - r;
    return t * t * t * e;
}
function ny(r, e) {
    let t = 1 - r;
    return 3 * t * t * r * e;
}
function iy(r, e) {
    return 3 * (1 - r) * r * r * e;
}
function sy(r, e) {
    return r * r * r * e;
}
function xs(r, e, t, n, i) {
    return ty(r, e) + ny(r, t) + iy(r, n) + sy(r, i);
}
var Us = class extends Et {
    constructor(e = new W(), t = new W(), n = new W(), i = new W()) {
        super(),
            (this.type = "CubicBezierCurve"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
    }
    getPoint(e, t = new W()) {
        let n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(xs(e, i.x, s.x, o.x, a.x), xs(e, i.y, s.y, o.y, a.y)), n;
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        );
    }
    toJSON() {
        let e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        );
    }
};
Us.prototype.isCubicBezierCurve = !0;
var ho = class extends Et {
    constructor(e = new M(), t = new M(), n = new M(), i = new M()) {
        super(),
            (this.type = "CubicBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n),
            (this.v3 = i);
    }
    getPoint(e, t = new M()) {
        let n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return (
            n.set(
                xs(e, i.x, s.x, o.x, a.x),
                xs(e, i.y, s.y, o.y, a.y),
                xs(e, i.z, s.z, o.z, a.z)
            ),
            n
        );
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        );
    }
    toJSON() {
        let e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            (e.v3 = this.v3.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        );
    }
};
ho.prototype.isCubicBezierCurve3 = !0;
var Hi = class extends Et {
    constructor(e = new W(), t = new W()) {
        super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t);
    }
    getPoint(e, t = new W()) {
        let n = t;
        return (
            e === 1
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(e).add(this.v1)),
            n
        );
    }
    getPointAt(e, t) {
        return this.getPoint(e, t);
    }
    getTangent(e, t) {
        let n = t || new W();
        return n.copy(this.v2).sub(this.v1).normalize(), n;
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
        let e = super.toJSON();
        return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
};
Hi.prototype.isLineCurve = !0;
var tl = class extends Et {
        constructor(e = new M(), t = new M()) {
            super(),
                (this.type = "LineCurve3"),
                (this.isLineCurve3 = !0),
                (this.v1 = e),
                (this.v2 = t);
        }
        getPoint(e, t = new M()) {
            let n = t;
            return (
                e === 1
                    ? n.copy(this.v2)
                    : (n.copy(this.v2).sub(this.v1),
                      n.multiplyScalar(e).add(this.v1)),
                n
            );
        }
        getPointAt(e, t) {
            return this.getPoint(e, t);
        }
        copy(e) {
            return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
            let e = super.toJSON();
            return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
        }
        fromJSON(e) {
            return (
                super.fromJSON(e),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            );
        }
    },
    Os = class extends Et {
        constructor(e = new W(), t = new W(), n = new W()) {
            super(),
                (this.type = "QuadraticBezierCurve"),
                (this.v0 = e),
                (this.v1 = t),
                (this.v2 = n);
        }
        getPoint(e, t = new W()) {
            let n = t,
                i = this.v0,
                s = this.v1,
                o = this.v2;
            return n.set(gs(e, i.x, s.x, o.x), gs(e, i.y, s.y, o.y)), n;
        }
        copy(e) {
            return (
                super.copy(e),
                this.v0.copy(e.v0),
                this.v1.copy(e.v1),
                this.v2.copy(e.v2),
                this
            );
        }
        toJSON() {
            let e = super.toJSON();
            return (
                (e.v0 = this.v0.toArray()),
                (e.v1 = this.v1.toArray()),
                (e.v2 = this.v2.toArray()),
                e
            );
        }
        fromJSON(e) {
            return (
                super.fromJSON(e),
                this.v0.fromArray(e.v0),
                this.v1.fromArray(e.v1),
                this.v2.fromArray(e.v2),
                this
            );
        }
    };
Os.prototype.isQuadraticBezierCurve = !0;
var Hs = class extends Et {
    constructor(e = new M(), t = new M(), n = new M()) {
        super(),
            (this.type = "QuadraticBezierCurve3"),
            (this.v0 = e),
            (this.v1 = t),
            (this.v2 = n);
    }
    getPoint(e, t = new M()) {
        let n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2;
        return (
            n.set(
                gs(e, i.x, s.x, o.x),
                gs(e, i.y, s.y, o.y),
                gs(e, i.z, s.z, o.z)
            ),
            n
        );
    }
    copy(e) {
        return (
            super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        );
    }
    toJSON() {
        let e = super.toJSON();
        return (
            (e.v0 = this.v0.toArray()),
            (e.v1 = this.v1.toArray()),
            (e.v2 = this.v2.toArray()),
            e
        );
    }
    fromJSON(e) {
        return (
            super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        );
    }
};
Hs.prototype.isQuadraticBezierCurve3 = !0;
var ks = class extends Et {
    constructor(e = []) {
        super(), (this.type = "SplineCurve"), (this.points = e);
    }
    getPoint(e, t = new W()) {
        let n = t,
            i = this.points,
            s = (i.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = i[o === 0 ? o : o - 1],
            c = i[o],
            h = i[o > i.length - 2 ? i.length - 1 : o + 1],
            u = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(rh(a, l.x, c.x, h.x, u.x), rh(a, l.y, c.y, h.y, u.y)), n;
    }
    copy(e) {
        super.copy(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
            let i = e.points[t];
            this.points.push(i.clone());
        }
        return this;
    }
    toJSON() {
        let e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            let i = this.points[t];
            e.points.push(i.toArray());
        }
        return e;
    }
    fromJSON(e) {
        super.fromJSON(e), (this.points = []);
        for (let t = 0, n = e.points.length; t < n; t++) {
            let i = e.points[t];
            this.points.push(new W().fromArray(i));
        }
        return this;
    }
};
ks.prototype.isSplineCurve = !0;
var Hl = Object.freeze({
        __proto__: null,
        ArcCurve: lo,
        CatmullRomCurve3: co,
        CubicBezierCurve: Us,
        CubicBezierCurve3: ho,
        EllipseCurve: Oi,
        LineCurve: Hi,
        LineCurve3: tl,
        QuadraticBezierCurve: Os,
        QuadraticBezierCurve3: Hs,
        SplineCurve: ks,
    }),
    nl = class extends Et {
        constructor() {
            super(),
                (this.type = "CurvePath"),
                (this.curves = []),
                (this.autoClose = !1);
        }
        add(e) {
            this.curves.push(e);
        }
        closePath() {
            let e = this.curves[0].getPoint(0),
                t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Hi(t, e));
        }
        getPoint(e, t) {
            let n = e * this.getLength(),
                i = this.getCurveLengths(),
                s = 0;
            for (; s < i.length; ) {
                if (i[s] >= n) {
                    let o = i[s] - n,
                        a = this.curves[s],
                        l = a.getLength(),
                        c = l === 0 ? 0 : 1 - o / l;
                    return a.getPointAt(c, t);
                }
                s++;
            }
            return null;
        }
        getLength() {
            let e = this.getCurveLengths();
            return e[e.length - 1];
        }
        updateArcLengths() {
            (this.needsUpdate = !0),
                (this.cacheLengths = null),
                this.getCurveLengths();
        }
        getCurveLengths() {
            if (
                this.cacheLengths &&
                this.cacheLengths.length === this.curves.length
            )
                return this.cacheLengths;
            let e = [],
                t = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
                (t += this.curves[n].getLength()), e.push(t);
            return (this.cacheLengths = e), e;
        }
        getSpacedPoints(e = 40) {
            let t = [];
            for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
            return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
            let t = [],
                n;
            for (let i = 0, s = this.curves; i < s.length; i++) {
                let o = s[i],
                    a =
                        o && o.isEllipseCurve
                            ? e * 2
                            : o && (o.isLineCurve || o.isLineCurve3)
                            ? 1
                            : o && o.isSplineCurve
                            ? e * o.points.length
                            : e,
                    l = o.getPoints(a);
                for (let c = 0; c < l.length; c++) {
                    let h = l[c];
                    (n && n.equals(h)) || (t.push(h), (n = h));
                }
            }
            return (
                this.autoClose &&
                    t.length > 1 &&
                    !t[t.length - 1].equals(t[0]) &&
                    t.push(t[0]),
                t
            );
        }
        copy(e) {
            super.copy(e), (this.curves = []);
            for (let t = 0, n = e.curves.length; t < n; t++) {
                let i = e.curves[t];
                this.curves.push(i.clone());
            }
            return (this.autoClose = e.autoClose), this;
        }
        toJSON() {
            let e = super.toJSON();
            (e.autoClose = this.autoClose), (e.curves = []);
            for (let t = 0, n = this.curves.length; t < n; t++) {
                let i = this.curves[t];
                e.curves.push(i.toJSON());
            }
            return e;
        }
        fromJSON(e) {
            super.fromJSON(e),
                (this.autoClose = e.autoClose),
                (this.curves = []);
            for (let t = 0, n = e.curves.length; t < n; t++) {
                let i = e.curves[t];
                this.curves.push(new Hl[i.type]().fromJSON(i));
            }
            return this;
        }
    },
    ki = class extends nl {
        constructor(e) {
            super(),
                (this.type = "Path"),
                (this.currentPoint = new W()),
                e && this.setFromPoints(e);
        }
        setFromPoints(e) {
            this.moveTo(e[0].x, e[0].y);
            for (let t = 1, n = e.length; t < n; t++)
                this.lineTo(e[t].x, e[t].y);
            return this;
        }
        moveTo(e, t) {
            return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
            let n = new Hi(this.currentPoint.clone(), new W(e, t));
            return this.curves.push(n), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
            let s = new Os(this.currentPoint.clone(), new W(e, t), new W(n, i));
            return this.curves.push(s), this.currentPoint.set(n, i), this;
        }
        bezierCurveTo(e, t, n, i, s, o) {
            let a = new Us(
                this.currentPoint.clone(),
                new W(e, t),
                new W(n, i),
                new W(s, o)
            );
            return this.curves.push(a), this.currentPoint.set(s, o), this;
        }
        splineThru(e) {
            let t = [this.currentPoint.clone()].concat(e),
                n = new ks(t);
            return (
                this.curves.push(n),
                this.currentPoint.copy(e[e.length - 1]),
                this
            );
        }
        arc(e, t, n, i, s, o) {
            let a = this.currentPoint.x,
                l = this.currentPoint.y;
            return this.absarc(e + a, t + l, n, i, s, o), this;
        }
        absarc(e, t, n, i, s, o) {
            return this.absellipse(e, t, n, n, i, s, o), this;
        }
        ellipse(e, t, n, i, s, o, a, l) {
            let c = this.currentPoint.x,
                h = this.currentPoint.y;
            return this.absellipse(e + c, t + h, n, i, s, o, a, l), this;
        }
        absellipse(e, t, n, i, s, o, a, l) {
            let c = new Oi(e, t, n, i, s, o, a, l);
            if (this.curves.length > 0) {
                let u = c.getPoint(0);
                u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
            }
            this.curves.push(c);
            let h = c.getPoint(1);
            return this.currentPoint.copy(h), this;
        }
        copy(e) {
            return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
            let e = super.toJSON();
            return (e.currentPoint = this.currentPoint.toArray()), e;
        }
        fromJSON(e) {
            return (
                super.fromJSON(e),
                this.currentPoint.fromArray(e.currentPoint),
                this
            );
        }
    },
    Ut = class extends ki {
        constructor(e) {
            super(e),
                (this.uuid = Ct()),
                (this.type = "Shape"),
                (this.holes = []);
        }
        getPointsHoles(e) {
            let t = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
                t[n] = this.holes[n].getPoints(e);
            return t;
        }
        extractPoints(e) {
            return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
        }
        copy(e) {
            super.copy(e), (this.holes = []);
            for (let t = 0, n = e.holes.length; t < n; t++) {
                let i = e.holes[t];
                this.holes.push(i.clone());
            }
            return this;
        }
        toJSON() {
            let e = super.toJSON();
            (e.uuid = this.uuid), (e.holes = []);
            for (let t = 0, n = this.holes.length; t < n; t++) {
                let i = this.holes[t];
                e.holes.push(i.toJSON());
            }
            return e;
        }
        fromJSON(e) {
            super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
            for (let t = 0, n = e.holes.length; t < n; t++) {
                let i = e.holes[t];
                this.holes.push(new ki().fromJSON(i));
            }
            return this;
        }
    },
    ry = {
        triangulate: function (r, e, t = 2) {
            let n = e && e.length,
                i = n ? e[0] * t : r.length,
                s = _u(r, 0, i, t, !0),
                o = [];
            if (!s || s.next === s.prev) return o;
            let a, l, c, h, u, d, f;
            if ((n && (s = hy(r, e, s, t)), r.length > 80 * t)) {
                (a = c = r[0]), (l = h = r[1]);
                for (let m = t; m < i; m += t)
                    (u = r[m]),
                        (d = r[m + 1]),
                        u < a && (a = u),
                        d < l && (l = d),
                        u > c && (c = u),
                        d > h && (h = d);
                (f = Math.max(c - a, h - l)), (f = f !== 0 ? 1 / f : 0);
            }
            return Vs(s, o, t, a, l, f), o;
        },
    };
function _u(r, e, t, n, i) {
    let s, o;
    if (i === My(r, e, t, n) > 0)
        for (s = e; s < t; s += n) o = oh(s, r[s], r[s + 1], o);
    else for (s = t - n; s >= e; s -= n) o = oh(s, r[s], r[s + 1], o);
    return o && Jo(o, o.next) && (Ws(o), (o = o.next)), o;
}
function Pn(r, e) {
    if (!r) return r;
    e || (e = r);
    let t = r,
        n;
    do
        if (
            ((n = !1),
            !t.steiner && (Jo(t, t.next) || $e(t.prev, t, t.next) === 0))
        ) {
            if ((Ws(t), (t = e = t.prev), t === t.next)) break;
            n = !0;
        } else t = t.next;
    while (n || t !== e);
    return e;
}
function Vs(r, e, t, n, i, s, o) {
    if (!r) return;
    !o && s && my(r, n, i, s);
    let a = r,
        l,
        c;
    for (; r.prev !== r.next; ) {
        if (((l = r.prev), (c = r.next), s ? ay(r, n, i, s) : oy(r))) {
            e.push(l.i / t),
                e.push(r.i / t),
                e.push(c.i / t),
                Ws(r),
                (r = c.next),
                (a = c.next);
            continue;
        }
        if (((r = c), r === a)) {
            o
                ? o === 1
                    ? ((r = ly(Pn(r), e, t)), Vs(r, e, t, n, i, s, 2))
                    : o === 2 && cy(r, e, t, n, i, s)
                : Vs(Pn(r), e, t, n, i, s, 1);
            break;
        }
    }
}
function oy(r) {
    let e = r.prev,
        t = r,
        n = r.next;
    if ($e(e, t, n) >= 0) return !1;
    let i = r.next.next;
    for (; i !== r.prev; ) {
        if (
            Ei(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) &&
            $e(i.prev, i, i.next) >= 0
        )
            return !1;
        i = i.next;
    }
    return !0;
}
function ay(r, e, t, n) {
    let i = r.prev,
        s = r,
        o = r.next;
    if ($e(i, s, o) >= 0) return !1;
    let a = i.x < s.x ? (i.x < o.x ? i.x : o.x) : s.x < o.x ? s.x : o.x,
        l = i.y < s.y ? (i.y < o.y ? i.y : o.y) : s.y < o.y ? s.y : o.y,
        c = i.x > s.x ? (i.x > o.x ? i.x : o.x) : s.x > o.x ? s.x : o.x,
        h = i.y > s.y ? (i.y > o.y ? i.y : o.y) : s.y > o.y ? s.y : o.y,
        u = il(a, l, e, t, n),
        d = il(c, h, e, t, n),
        f = r.prevZ,
        m = r.nextZ;
    for (; f && f.z >= u && m && m.z <= d; ) {
        if (
            (f !== r.prev &&
                f !== r.next &&
                Ei(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
                $e(f.prev, f, f.next) >= 0) ||
            ((f = f.prevZ),
            m !== r.prev &&
                m !== r.next &&
                Ei(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) &&
                $e(m.prev, m, m.next) >= 0)
        )
            return !1;
        m = m.nextZ;
    }
    for (; f && f.z >= u; ) {
        if (
            f !== r.prev &&
            f !== r.next &&
            Ei(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) &&
            $e(f.prev, f, f.next) >= 0
        )
            return !1;
        f = f.prevZ;
    }
    for (; m && m.z <= d; ) {
        if (
            m !== r.prev &&
            m !== r.next &&
            Ei(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) &&
            $e(m.prev, m, m.next) >= 0
        )
            return !1;
        m = m.nextZ;
    }
    return !0;
}
function ly(r, e, t) {
    let n = r;
    do {
        let i = n.prev,
            s = n.next.next;
        !Jo(i, s) &&
            Mu(i, n, n.next, s) &&
            Gs(i, s) &&
            Gs(s, i) &&
            (e.push(i.i / t),
            e.push(n.i / t),
            e.push(s.i / t),
            Ws(n),
            Ws(n.next),
            (n = r = s)),
            (n = n.next);
    } while (n !== r);
    return Pn(n);
}
function cy(r, e, t, n, i, s) {
    let o = r;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && yy(o, a)) {
                let l = wu(o, a);
                (o = Pn(o, o.next)),
                    (l = Pn(l, l.next)),
                    Vs(o, e, t, n, i, s),
                    Vs(l, e, t, n, i, s);
                return;
            }
            a = a.next;
        }
        o = o.next;
    } while (o !== r);
}
function hy(r, e, t, n) {
    let i = [],
        s,
        o,
        a,
        l,
        c;
    for (s = 0, o = e.length; s < o; s++)
        (a = e[s] * n),
            (l = s < o - 1 ? e[s + 1] * n : r.length),
            (c = _u(r, a, l, n, !1)),
            c === c.next && (c.steiner = !0),
            i.push(xy(c));
    for (i.sort(uy), s = 0; s < i.length; s++) dy(i[s], t), (t = Pn(t, t.next));
    return t;
}
function uy(r, e) {
    return r.x - e.x;
}
function dy(r, e) {
    if (((e = fy(r, e)), e)) {
        let t = wu(e, r);
        Pn(e, e.next), Pn(t, t.next);
    }
}
function fy(r, e) {
    let t = e,
        n = r.x,
        i = r.y,
        s = -1 / 0,
        o;
    do {
        if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
            let d = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
            if (d <= n && d > s) {
                if (((s = d), d === n)) {
                    if (i === t.y) return t;
                    if (i === t.next.y) return t.next;
                }
                o = t.x < t.next.x ? t : t.next;
            }
        }
        t = t.next;
    } while (t !== e);
    if (!o) return null;
    if (n === s) return o;
    let a = o,
        l = o.x,
        c = o.y,
        h = 1 / 0,
        u;
    t = o;
    do
        n >= t.x &&
            t.x >= l &&
            n !== t.x &&
            Ei(i < c ? n : s, i, l, c, i < c ? s : n, i, t.x, t.y) &&
            ((u = Math.abs(i - t.y) / (n - t.x)),
            Gs(t, r) &&
                (u < h ||
                    (u === h && (t.x > o.x || (t.x === o.x && py(o, t))))) &&
                ((o = t), (h = u))),
            (t = t.next);
    while (t !== a);
    return o;
}
function py(r, e) {
    return $e(r.prev, r, e.prev) < 0 && $e(e.next, r, r.next) < 0;
}
function my(r, e, t, n) {
    let i = r;
    do
        i.z === null && (i.z = il(i.x, i.y, e, t, n)),
            (i.prevZ = i.prev),
            (i.nextZ = i.next),
            (i = i.next);
    while (i !== r);
    (i.prevZ.nextZ = null), (i.prevZ = null), gy(i);
}
function gy(r) {
    let e,
        t,
        n,
        i,
        s,
        o,
        a,
        l,
        c = 1;
    do {
        for (t = r, r = null, s = null, o = 0; t; ) {
            for (
                o++, n = t, a = 0, e = 0;
                e < c && (a++, (n = n.nextZ), !!n);
                e++
            );
            for (l = c; a > 0 || (l > 0 && n); )
                a !== 0 && (l === 0 || !n || t.z <= n.z)
                    ? ((i = t), (t = t.nextZ), a--)
                    : ((i = n), (n = n.nextZ), l--),
                    s ? (s.nextZ = i) : (r = i),
                    (i.prevZ = s),
                    (s = i);
            t = n;
        }
        (s.nextZ = null), (c *= 2);
    } while (o > 1);
    return r;
}
function il(r, e, t, n, i) {
    return (
        (r = 32767 * (r - t) * i),
        (e = 32767 * (e - n) * i),
        (r = (r | (r << 8)) & 16711935),
        (r = (r | (r << 4)) & 252645135),
        (r = (r | (r << 2)) & 858993459),
        (r = (r | (r << 1)) & 1431655765),
        (e = (e | (e << 8)) & 16711935),
        (e = (e | (e << 4)) & 252645135),
        (e = (e | (e << 2)) & 858993459),
        (e = (e | (e << 1)) & 1431655765),
        r | (e << 1)
    );
}
function xy(r) {
    let e = r,
        t = r;
    do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
    while (e !== r);
    return t;
}
function Ei(r, e, t, n, i, s, o, a) {
    return (
        (i - o) * (e - a) - (r - o) * (s - a) >= 0 &&
        (r - o) * (n - a) - (t - o) * (e - a) >= 0 &&
        (t - o) * (s - a) - (i - o) * (n - a) >= 0
    );
}
function yy(r, e) {
    return (
        r.next.i !== e.i &&
        r.prev.i !== e.i &&
        !vy(r, e) &&
        ((Gs(r, e) &&
            Gs(e, r) &&
            _y(r, e) &&
            ($e(r.prev, r, e.prev) || $e(r, e.prev, e))) ||
            (Jo(r, e) &&
                $e(r.prev, r, r.next) > 0 &&
                $e(e.prev, e, e.next) > 0))
    );
}
function $e(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function Jo(r, e) {
    return r.x === e.x && r.y === e.y;
}
function Mu(r, e, t, n) {
    let i = Fr($e(r, e, t)),
        s = Fr($e(r, e, n)),
        o = Fr($e(t, n, r)),
        a = Fr($e(t, n, e));
    return !!(
        (i !== s && o !== a) ||
        (i === 0 && Dr(r, t, e)) ||
        (s === 0 && Dr(r, n, e)) ||
        (o === 0 && Dr(t, r, n)) ||
        (a === 0 && Dr(t, e, n))
    );
}
function Dr(r, e, t) {
    return (
        e.x <= Math.max(r.x, t.x) &&
        e.x >= Math.min(r.x, t.x) &&
        e.y <= Math.max(r.y, t.y) &&
        e.y >= Math.min(r.y, t.y)
    );
}
function Fr(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function vy(r, e) {
    let t = r;
    do {
        if (
            t.i !== r.i &&
            t.next.i !== r.i &&
            t.i !== e.i &&
            t.next.i !== e.i &&
            Mu(t, t.next, r, e)
        )
            return !0;
        t = t.next;
    } while (t !== r);
    return !1;
}
function Gs(r, e) {
    return $e(r.prev, r, r.next) < 0
        ? $e(r, e, r.next) >= 0 && $e(r, r.prev, e) >= 0
        : $e(r, e, r.prev) < 0 || $e(r, r.next, e) < 0;
}
function _y(r, e) {
    let t = r,
        n = !1,
        i = (r.x + e.x) / 2,
        s = (r.y + e.y) / 2;
    do
        t.y > s != t.next.y > s &&
            t.next.y !== t.y &&
            i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
            (n = !n),
            (t = t.next);
    while (t !== r);
    return n;
}
function wu(r, e) {
    let t = new sl(r.i, r.x, r.y),
        n = new sl(e.i, e.x, e.y),
        i = r.next,
        s = e.prev;
    return (
        (r.next = e),
        (e.prev = r),
        (t.next = i),
        (i.prev = t),
        (n.next = t),
        (t.prev = n),
        (s.next = n),
        (n.prev = s),
        n
    );
}
function oh(r, e, t, n) {
    let i = new sl(r, e, t);
    return (
        n
            ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
            : ((i.prev = i), (i.next = i)),
        i
    );
}
function Ws(r) {
    (r.next.prev = r.prev),
        (r.prev.next = r.next),
        r.prevZ && (r.prevZ.nextZ = r.nextZ),
        r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function sl(r, e, t) {
    (this.i = r),
        (this.x = e),
        (this.y = t),
        (this.prev = null),
        (this.next = null),
        (this.z = null),
        (this.prevZ = null),
        (this.nextZ = null),
        (this.steiner = !1);
}
function My(r, e, t, n) {
    let i = 0;
    for (let s = e, o = t - n; s < t; s += n)
        (i += (r[o] - r[s]) * (r[s + 1] + r[o + 1])), (o = s);
    return i;
}
var ln = class r {
    static area(e) {
        let t = e.length,
            n = 0;
        for (let i = t - 1, s = 0; s < t; i = s++)
            n += e[i].x * e[s].y - e[s].x * e[i].y;
        return n * 0.5;
    }
    static isClockWise(e) {
        return r.area(e) < 0;
    }
    static triangulateShape(e, t) {
        let n = [],
            i = [],
            s = [];
        ah(e), lh(n, e);
        let o = e.length;
        t.forEach(ah);
        for (let l = 0; l < t.length; l++)
            i.push(o), (o += t[l].length), lh(n, t[l]);
        let a = ry.triangulate(n, i);
        for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
        return s;
    }
};
function ah(r) {
    let e = r.length;
    e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function lh(r, e) {
    for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
}
var In = class r extends _e {
        constructor(
            e = new Ut([
                new W(0.5, 0.5),
                new W(-0.5, 0.5),
                new W(-0.5, -0.5),
                new W(0.5, -0.5),
            ]),
            t = {}
        ) {
            super(),
                (this.type = "ExtrudeGeometry"),
                (this.parameters = { shapes: e, options: t }),
                (e = Array.isArray(e) ? e : [e]);
            let n = this,
                i = [],
                s = [];
            for (let a = 0, l = e.length; a < l; a++) {
                let c = e[a];
                o(c);
            }
            this.setAttribute("position", new de(i, 3)),
                this.setAttribute("uv", new de(s, 2)),
                this.computeVertexNormals();
            function o(a) {
                let l = [],
                    c = t.curveSegments !== void 0 ? t.curveSegments : 12,
                    h = t.steps !== void 0 ? t.steps : 1,
                    u = t.depth !== void 0 ? t.depth : 1,
                    d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                    f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
                    m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
                    x = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                    v = t.bevelSegments !== void 0 ? t.bevelSegments : 3,
                    g = t.extrudePath,
                    p = t.UVGenerator !== void 0 ? t.UVGenerator : wy;
                t.amount !== void 0 &&
                    (console.warn(
                        "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                    ),
                    (u = t.amount));
                let _,
                    y = !1,
                    w,
                    A,
                    C,
                    I;
                g &&
                    ((_ = g.getSpacedPoints(h)),
                    (y = !0),
                    (d = !1),
                    (w = g.computeFrenetFrames(h, !1)),
                    (A = new M()),
                    (C = new M()),
                    (I = new M())),
                    d || ((v = 0), (f = 0), (m = 0), (x = 0));
                let k = a.extractPoints(c),
                    z = k.shape,
                    P = k.holes;
                if (!ln.isClockWise(z)) {
                    z = z.reverse();
                    for (let V = 0, j = P.length; V < j; V++) {
                        let K = P[V];
                        ln.isClockWise(K) && (P[V] = K.reverse());
                    }
                }
                let E = ln.triangulateShape(z, P),
                    D = z;
                for (let V = 0, j = P.length; V < j; V++) {
                    let K = P[V];
                    z = z.concat(K);
                }
                function U(V, j, K) {
                    return (
                        j ||
                            console.error(
                                "THREE.ExtrudeGeometry: vec does not exist"
                            ),
                        j.clone().multiplyScalar(K).add(V)
                    );
                }
                let F = z.length,
                    O = E.length;
                function ne(V, j, K) {
                    let ue,
                        oe,
                        Se,
                        Te = V.x - j.x,
                        Pe = V.y - j.y,
                        Ye = K.x - V.x,
                        R = K.y - V.y,
                        T = Te * Te + Pe * Pe,
                        J = Te * R - Pe * Ye;
                    if (Math.abs(J) > Number.EPSILON) {
                        let $ = Math.sqrt(T),
                            se = Math.sqrt(Ye * Ye + R * R),
                            Z = j.x - Pe / $,
                            Me = j.y + Te / $,
                            ve = K.x - R / se,
                            te = K.y + Ye / se,
                            L =
                                ((ve - Z) * R - (te - Me) * Ye) /
                                (Te * R - Pe * Ye);
                        (ue = Z + Te * L - V.x), (oe = Me + Pe * L - V.y);
                        let ee = ue * ue + oe * oe;
                        if (ee <= 2) return new W(ue, oe);
                        Se = Math.sqrt(ee / 2);
                    } else {
                        let $ = !1;
                        Te > Number.EPSILON
                            ? Ye > Number.EPSILON && ($ = !0)
                            : Te < -Number.EPSILON
                            ? Ye < -Number.EPSILON && ($ = !0)
                            : Math.sign(Pe) === Math.sign(R) && ($ = !0),
                            $
                                ? ((ue = -Pe), (oe = Te), (Se = Math.sqrt(T)))
                                : ((ue = Te),
                                  (oe = Pe),
                                  (Se = Math.sqrt(T / 2)));
                    }
                    return new W(ue / Se, oe / Se);
                }
                let ce = [];
                for (
                    let V = 0, j = D.length, K = j - 1, ue = V + 1;
                    V < j;
                    V++, K++, ue++
                )
                    K === j && (K = 0),
                        ue === j && (ue = 0),
                        (ce[V] = ne(D[V], D[K], D[ue]));
                let G = [],
                    q,
                    he = ce.concat();
                for (let V = 0, j = P.length; V < j; V++) {
                    let K = P[V];
                    q = [];
                    for (
                        let ue = 0, oe = K.length, Se = oe - 1, Te = ue + 1;
                        ue < oe;
                        ue++, Se++, Te++
                    )
                        Se === oe && (Se = 0),
                            Te === oe && (Te = 0),
                            (q[ue] = ne(K[ue], K[Se], K[Te]));
                    G.push(q), (he = he.concat(q));
                }
                for (let V = 0; V < v; V++) {
                    let j = V / v,
                        K = f * Math.cos((j * Math.PI) / 2),
                        ue = m * Math.sin((j * Math.PI) / 2) + x;
                    for (let oe = 0, Se = D.length; oe < Se; oe++) {
                        let Te = U(D[oe], ce[oe], ue);
                        Re(Te.x, Te.y, -K);
                    }
                    for (let oe = 0, Se = P.length; oe < Se; oe++) {
                        let Te = P[oe];
                        q = G[oe];
                        for (let Pe = 0, Ye = Te.length; Pe < Ye; Pe++) {
                            let R = U(Te[Pe], q[Pe], ue);
                            Re(R.x, R.y, -K);
                        }
                    }
                }
                let le = m + x;
                for (let V = 0; V < F; V++) {
                    let j = d ? U(z[V], he[V], le) : z[V];
                    y
                        ? (C.copy(w.normals[0]).multiplyScalar(j.x),
                          A.copy(w.binormals[0]).multiplyScalar(j.y),
                          I.copy(_[0]).add(C).add(A),
                          Re(I.x, I.y, I.z))
                        : Re(j.x, j.y, 0);
                }
                for (let V = 1; V <= h; V++)
                    for (let j = 0; j < F; j++) {
                        let K = d ? U(z[j], he[j], le) : z[j];
                        y
                            ? (C.copy(w.normals[V]).multiplyScalar(K.x),
                              A.copy(w.binormals[V]).multiplyScalar(K.y),
                              I.copy(_[V]).add(C).add(A),
                              Re(I.x, I.y, I.z))
                            : Re(K.x, K.y, (u / h) * V);
                    }
                for (let V = v - 1; V >= 0; V--) {
                    let j = V / v,
                        K = f * Math.cos((j * Math.PI) / 2),
                        ue = m * Math.sin((j * Math.PI) / 2) + x;
                    for (let oe = 0, Se = D.length; oe < Se; oe++) {
                        let Te = U(D[oe], ce[oe], ue);
                        Re(Te.x, Te.y, u + K);
                    }
                    for (let oe = 0, Se = P.length; oe < Se; oe++) {
                        let Te = P[oe];
                        q = G[oe];
                        for (let Pe = 0, Ye = Te.length; Pe < Ye; Pe++) {
                            let R = U(Te[Pe], q[Pe], ue);
                            y
                                ? Re(R.x, R.y + _[h - 1].y, _[h - 1].x + K)
                                : Re(R.x, R.y, u + K);
                        }
                    }
                }
                fe(), Ne();
                function fe() {
                    let V = i.length / 3;
                    if (d) {
                        let j = 0,
                            K = F * j;
                        for (let ue = 0; ue < O; ue++) {
                            let oe = E[ue];
                            ye(oe[2] + K, oe[1] + K, oe[0] + K);
                        }
                        (j = h + v * 2), (K = F * j);
                        for (let ue = 0; ue < O; ue++) {
                            let oe = E[ue];
                            ye(oe[0] + K, oe[1] + K, oe[2] + K);
                        }
                    } else {
                        for (let j = 0; j < O; j++) {
                            let K = E[j];
                            ye(K[2], K[1], K[0]);
                        }
                        for (let j = 0; j < O; j++) {
                            let K = E[j];
                            ye(K[0] + F * h, K[1] + F * h, K[2] + F * h);
                        }
                    }
                    n.addGroup(V, i.length / 3 - V, 0);
                }
                function Ne() {
                    let V = i.length / 3,
                        j = 0;
                    Y(D, j), (j += D.length);
                    for (let K = 0, ue = P.length; K < ue; K++) {
                        let oe = P[K];
                        Y(oe, j), (j += oe.length);
                    }
                    n.addGroup(V, i.length / 3 - V, 1);
                }
                function Y(V, j) {
                    let K = V.length;
                    for (; --K >= 0; ) {
                        let ue = K,
                            oe = K - 1;
                        oe < 0 && (oe = V.length - 1);
                        for (let Se = 0, Te = h + v * 2; Se < Te; Se++) {
                            let Pe = F * Se,
                                Ye = F * (Se + 1),
                                R = j + ue + Pe,
                                T = j + oe + Pe,
                                J = j + oe + Ye,
                                $ = j + ue + Ye;
                            ge(R, T, J, $);
                        }
                    }
                }
                function Re(V, j, K) {
                    l.push(V), l.push(j), l.push(K);
                }
                function ye(V, j, K) {
                    xe(V), xe(j), xe(K);
                    let ue = i.length / 3,
                        oe = p.generateTopUV(n, i, ue - 3, ue - 2, ue - 1);
                    Oe(oe[0]), Oe(oe[1]), Oe(oe[2]);
                }
                function ge(V, j, K, ue) {
                    xe(V), xe(j), xe(ue), xe(j), xe(K), xe(ue);
                    let oe = i.length / 3,
                        Se = p.generateSideWallUV(
                            n,
                            i,
                            oe - 6,
                            oe - 3,
                            oe - 2,
                            oe - 1
                        );
                    Oe(Se[0]),
                        Oe(Se[1]),
                        Oe(Se[3]),
                        Oe(Se[1]),
                        Oe(Se[2]),
                        Oe(Se[3]);
                }
                function xe(V) {
                    i.push(l[V * 3 + 0]),
                        i.push(l[V * 3 + 1]),
                        i.push(l[V * 3 + 2]);
                }
                function Oe(V) {
                    s.push(V.x), s.push(V.y);
                }
            }
        }
        toJSON() {
            let e = super.toJSON(),
                t = this.parameters.shapes,
                n = this.parameters.options;
            return by(t, n, e);
        }
        static fromJSON(e, t) {
            let n = [];
            for (let s = 0, o = e.shapes.length; s < o; s++) {
                let a = t[e.shapes[s]];
                n.push(a);
            }
            let i = e.options.extrudePath;
            return (
                i !== void 0 &&
                    (e.options.extrudePath = new Hl[i.type]().fromJSON(i)),
                new r(n, e.options)
            );
        }
    },
    wy = {
        generateTopUV: function (r, e, t, n, i) {
            let s = e[t * 3],
                o = e[t * 3 + 1],
                a = e[n * 3],
                l = e[n * 3 + 1],
                c = e[i * 3],
                h = e[i * 3 + 1];
            return [new W(s, o), new W(a, l), new W(c, h)];
        },
        generateSideWallUV: function (r, e, t, n, i, s) {
            let o = e[t * 3],
                a = e[t * 3 + 1],
                l = e[t * 3 + 2],
                c = e[n * 3],
                h = e[n * 3 + 1],
                u = e[n * 3 + 2],
                d = e[i * 3],
                f = e[i * 3 + 1],
                m = e[i * 3 + 2],
                x = e[s * 3],
                v = e[s * 3 + 1],
                g = e[s * 3 + 2];
            return Math.abs(a - h) < Math.abs(o - c)
                ? [
                      new W(o, 1 - l),
                      new W(c, 1 - u),
                      new W(d, 1 - m),
                      new W(x, 1 - g),
                  ]
                : [
                      new W(a, 1 - l),
                      new W(h, 1 - u),
                      new W(f, 1 - m),
                      new W(v, 1 - g),
                  ];
        },
    };
function by(r, e, t) {
    if (((t.shapes = []), Array.isArray(r)))
        for (let n = 0, i = r.length; n < i; n++) {
            let s = r[n];
            t.shapes.push(s.uuid);
        }
    else t.shapes.push(r.uuid);
    return (
        e.extrudePath !== void 0 &&
            (t.options.extrudePath = e.extrudePath.toJSON()),
        t
    );
}
var uo = class r extends Ln {
        constructor(e = 1, t = 0) {
            let n = (1 + Math.sqrt(5)) / 2,
                i = [
                    -1,
                    n,
                    0,
                    1,
                    n,
                    0,
                    -1,
                    -n,
                    0,
                    1,
                    -n,
                    0,
                    0,
                    -1,
                    n,
                    0,
                    1,
                    n,
                    0,
                    -1,
                    -n,
                    0,
                    1,
                    -n,
                    n,
                    0,
                    -1,
                    n,
                    0,
                    1,
                    -n,
                    0,
                    -1,
                    -n,
                    0,
                    1,
                ],
                s = [
                    0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5,
                    11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2,
                    6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7,
                    9, 8, 1,
                ];
            super(i, s, e, t),
                (this.type = "IcosahedronGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
            return new r(e.radius, e.detail);
        }
    },
    fo = class r extends _e {
        constructor(
            e = [new W(0, 0.5), new W(0.5, 0), new W(0, -0.5)],
            t = 12,
            n = 0,
            i = Math.PI * 2
        ) {
            super(),
                (this.type = "LatheGeometry"),
                (this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: i,
                }),
                (t = Math.floor(t)),
                (i = mt(i, 0, Math.PI * 2));
            let s = [],
                o = [],
                a = [],
                l = [],
                c = [],
                h = 1 / t,
                u = new M(),
                d = new W(),
                f = new M(),
                m = new M(),
                x = new M(),
                v = 0,
                g = 0;
            for (let p = 0; p <= e.length - 1; p++)
                switch (p) {
                    case 0:
                        (v = e[p + 1].x - e[p].x),
                            (g = e[p + 1].y - e[p].y),
                            (f.x = g * 1),
                            (f.y = -v),
                            (f.z = g * 0),
                            x.copy(f),
                            f.normalize(),
                            l.push(f.x, f.y, f.z);
                        break;
                    case e.length - 1:
                        l.push(x.x, x.y, x.z);
                        break;
                    default:
                        (v = e[p + 1].x - e[p].x),
                            (g = e[p + 1].y - e[p].y),
                            (f.x = g * 1),
                            (f.y = -v),
                            (f.z = g * 0),
                            m.copy(f),
                            (f.x += x.x),
                            (f.y += x.y),
                            (f.z += x.z),
                            f.normalize(),
                            l.push(f.x, f.y, f.z),
                            x.copy(m);
                }
            for (let p = 0; p <= t; p++) {
                let _ = n + p * h * i,
                    y = Math.sin(_),
                    w = Math.cos(_);
                for (let A = 0; A <= e.length - 1; A++) {
                    (u.x = e[A].x * y),
                        (u.y = e[A].y),
                        (u.z = e[A].x * w),
                        o.push(u.x, u.y, u.z),
                        (d.x = p / t),
                        (d.y = A / (e.length - 1)),
                        a.push(d.x, d.y);
                    let C = l[3 * A + 0] * y,
                        I = l[3 * A + 1],
                        k = l[3 * A + 0] * w;
                    c.push(C, I, k);
                }
            }
            for (let p = 0; p < t; p++)
                for (let _ = 0; _ < e.length - 1; _++) {
                    let y = _ + p * e.length,
                        w = y,
                        A = y + e.length,
                        C = y + e.length + 1,
                        I = y + 1;
                    s.push(w, A, I), s.push(A, C, I);
                }
            this.setIndex(s),
                this.setAttribute("position", new de(o, 3)),
                this.setAttribute("uv", new de(a, 2)),
                this.setAttribute("normal", new de(c, 3));
        }
        static fromJSON(e) {
            return new r(e.points, e.segments, e.phiStart, e.phiLength);
        }
    },
    qs = class r extends Ln {
        constructor(e = 1, t = 0) {
            let n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                i = [
                    0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3,
                    4, 1, 4, 2,
                ];
            super(n, i, e, t),
                (this.type = "OctahedronGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
            return new r(e.radius, e.detail);
        }
    },
    po = class r extends _e {
        constructor(e = 0.5, t = 1, n = 8, i = 1, s = 0, o = Math.PI * 2) {
            super(),
                (this.type = "RingGeometry"),
                (this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: s,
                    thetaLength: o,
                }),
                (n = Math.max(3, n)),
                (i = Math.max(1, i));
            let a = [],
                l = [],
                c = [],
                h = [],
                u = e,
                d = (t - e) / i,
                f = new M(),
                m = new W();
            for (let x = 0; x <= i; x++) {
                for (let v = 0; v <= n; v++) {
                    let g = s + (v / n) * o;
                    (f.x = u * Math.cos(g)),
                        (f.y = u * Math.sin(g)),
                        l.push(f.x, f.y, f.z),
                        c.push(0, 0, 1),
                        (m.x = (f.x / t + 1) / 2),
                        (m.y = (f.y / t + 1) / 2),
                        h.push(m.x, m.y);
                }
                u += d;
            }
            for (let x = 0; x < i; x++) {
                let v = x * (n + 1);
                for (let g = 0; g < n; g++) {
                    let p = g + v,
                        _ = p,
                        y = p + n + 1,
                        w = p + n + 2,
                        A = p + 1;
                    a.push(_, y, A), a.push(y, w, A);
                }
            }
            this.setIndex(a),
                this.setAttribute("position", new de(l, 3)),
                this.setAttribute("normal", new de(c, 3)),
                this.setAttribute("uv", new de(h, 2));
        }
        static fromJSON(e) {
            return new r(
                e.innerRadius,
                e.outerRadius,
                e.thetaSegments,
                e.phiSegments,
                e.thetaStart,
                e.thetaLength
            );
        }
    },
    Xs = class r extends _e {
        constructor(
            e = new Ut([new W(0, 0.5), new W(-0.5, -0.5), new W(0.5, -0.5)]),
            t = 12
        ) {
            super(),
                (this.type = "ShapeGeometry"),
                (this.parameters = { shapes: e, curveSegments: t });
            let n = [],
                i = [],
                s = [],
                o = [],
                a = 0,
                l = 0;
            if (Array.isArray(e) === !1) c(e);
            else
                for (let h = 0; h < e.length; h++)
                    c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
            this.setIndex(n),
                this.setAttribute("position", new de(i, 3)),
                this.setAttribute("normal", new de(s, 3)),
                this.setAttribute("uv", new de(o, 2));
            function c(h) {
                let u = i.length / 3,
                    d = h.extractPoints(t),
                    f = d.shape,
                    m = d.holes;
                ln.isClockWise(f) === !1 && (f = f.reverse());
                for (let v = 0, g = m.length; v < g; v++) {
                    let p = m[v];
                    ln.isClockWise(p) === !0 && (m[v] = p.reverse());
                }
                let x = ln.triangulateShape(f, m);
                for (let v = 0, g = m.length; v < g; v++) {
                    let p = m[v];
                    f = f.concat(p);
                }
                for (let v = 0, g = f.length; v < g; v++) {
                    let p = f[v];
                    i.push(p.x, p.y, 0), s.push(0, 0, 1), o.push(p.x, p.y);
                }
                for (let v = 0, g = x.length; v < g; v++) {
                    let p = x[v],
                        _ = p[0] + u,
                        y = p[1] + u,
                        w = p[2] + u;
                    n.push(_, y, w), (l += 3);
                }
            }
        }
        toJSON() {
            let e = super.toJSON(),
                t = this.parameters.shapes;
            return Sy(t, e);
        }
        static fromJSON(e, t) {
            let n = [];
            for (let i = 0, s = e.shapes.length; i < s; i++) {
                let o = t[e.shapes[i]];
                n.push(o);
            }
            return new r(n, e.curveSegments);
        }
    };
function Sy(r, e) {
    if (((e.shapes = []), Array.isArray(r)))
        for (let t = 0, n = r.length; t < n; t++) {
            let i = r[t];
            e.shapes.push(i.uuid);
        }
    else e.shapes.push(r.uuid);
    return e;
}
var Js = class r extends _e {
        constructor(
            e = 1,
            t = 32,
            n = 16,
            i = 0,
            s = Math.PI * 2,
            o = 0,
            a = Math.PI
        ) {
            super(),
                (this.type = "SphereGeometry"),
                (this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: s,
                    thetaStart: o,
                    thetaLength: a,
                }),
                (t = Math.max(3, Math.floor(t))),
                (n = Math.max(2, Math.floor(n)));
            let l = Math.min(o + a, Math.PI),
                c = 0,
                h = [],
                u = new M(),
                d = new M(),
                f = [],
                m = [],
                x = [],
                v = [];
            for (let g = 0; g <= n; g++) {
                let p = [],
                    _ = g / n,
                    y = 0;
                g == 0 && o == 0
                    ? (y = 0.5 / t)
                    : g == n && l == Math.PI && (y = -0.5 / t);
                for (let w = 0; w <= t; w++) {
                    let A = w / t;
                    (u.x = -e * Math.cos(i + A * s) * Math.sin(o + _ * a)),
                        (u.y = e * Math.cos(o + _ * a)),
                        (u.z = e * Math.sin(i + A * s) * Math.sin(o + _ * a)),
                        m.push(u.x, u.y, u.z),
                        d.copy(u).normalize(),
                        x.push(d.x, d.y, d.z),
                        v.push(A + y, 1 - _),
                        p.push(c++);
                }
                h.push(p);
            }
            for (let g = 0; g < n; g++)
                for (let p = 0; p < t; p++) {
                    let _ = h[g][p + 1],
                        y = h[g][p],
                        w = h[g + 1][p],
                        A = h[g + 1][p + 1];
                    (g !== 0 || o > 0) && f.push(_, y, A),
                        (g !== n - 1 || l < Math.PI) && f.push(y, w, A);
                }
            this.setIndex(f),
                this.setAttribute("position", new de(m, 3)),
                this.setAttribute("normal", new de(x, 3)),
                this.setAttribute("uv", new de(v, 2));
        }
        static fromJSON(e) {
            return new r(
                e.radius,
                e.widthSegments,
                e.heightSegments,
                e.phiStart,
                e.phiLength,
                e.thetaStart,
                e.thetaLength
            );
        }
    },
    mo = class r extends Ln {
        constructor(e = 1, t = 0) {
            let n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            super(n, i, e, t),
                (this.type = "TetrahedronGeometry"),
                (this.parameters = { radius: e, detail: t });
        }
        static fromJSON(e) {
            return new r(e.radius, e.detail);
        }
    },
    go = class r extends _e {
        constructor(e = 1, t = 0.4, n = 8, i = 6, s = Math.PI * 2) {
            super(),
                (this.type = "TorusGeometry"),
                (this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: s,
                }),
                (n = Math.floor(n)),
                (i = Math.floor(i));
            let o = [],
                a = [],
                l = [],
                c = [],
                h = new M(),
                u = new M(),
                d = new M();
            for (let f = 0; f <= n; f++)
                for (let m = 0; m <= i; m++) {
                    let x = (m / i) * s,
                        v = (f / n) * Math.PI * 2;
                    (u.x = (e + t * Math.cos(v)) * Math.cos(x)),
                        (u.y = (e + t * Math.cos(v)) * Math.sin(x)),
                        (u.z = t * Math.sin(v)),
                        a.push(u.x, u.y, u.z),
                        (h.x = e * Math.cos(x)),
                        (h.y = e * Math.sin(x)),
                        d.subVectors(u, h).normalize(),
                        l.push(d.x, d.y, d.z),
                        c.push(m / i),
                        c.push(f / n);
                }
            for (let f = 1; f <= n; f++)
                for (let m = 1; m <= i; m++) {
                    let x = (i + 1) * f + m - 1,
                        v = (i + 1) * (f - 1) + m - 1,
                        g = (i + 1) * (f - 1) + m,
                        p = (i + 1) * f + m;
                    o.push(x, v, p), o.push(v, g, p);
                }
            this.setIndex(o),
                this.setAttribute("position", new de(a, 3)),
                this.setAttribute("normal", new de(l, 3)),
                this.setAttribute("uv", new de(c, 2));
        }
        static fromJSON(e) {
            return new r(
                e.radius,
                e.tube,
                e.radialSegments,
                e.tubularSegments,
                e.arc
            );
        }
    },
    xo = class r extends _e {
        constructor(e = 1, t = 0.4, n = 64, i = 8, s = 2, o = 3) {
            super(),
                (this.type = "TorusKnotGeometry"),
                (this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: i,
                    p: s,
                    q: o,
                }),
                (n = Math.floor(n)),
                (i = Math.floor(i));
            let a = [],
                l = [],
                c = [],
                h = [],
                u = new M(),
                d = new M(),
                f = new M(),
                m = new M(),
                x = new M(),
                v = new M(),
                g = new M();
            for (let _ = 0; _ <= n; ++_) {
                let y = (_ / n) * s * Math.PI * 2;
                p(y, s, o, e, f),
                    p(y + 0.01, s, o, e, m),
                    v.subVectors(m, f),
                    g.addVectors(m, f),
                    x.crossVectors(v, g),
                    g.crossVectors(x, v),
                    x.normalize(),
                    g.normalize();
                for (let w = 0; w <= i; ++w) {
                    let A = (w / i) * Math.PI * 2,
                        C = -t * Math.cos(A),
                        I = t * Math.sin(A);
                    (u.x = f.x + (C * g.x + I * x.x)),
                        (u.y = f.y + (C * g.y + I * x.y)),
                        (u.z = f.z + (C * g.z + I * x.z)),
                        l.push(u.x, u.y, u.z),
                        d.subVectors(u, f).normalize(),
                        c.push(d.x, d.y, d.z),
                        h.push(_ / n),
                        h.push(w / i);
                }
            }
            for (let _ = 1; _ <= n; _++)
                for (let y = 1; y <= i; y++) {
                    let w = (i + 1) * (_ - 1) + (y - 1),
                        A = (i + 1) * _ + (y - 1),
                        C = (i + 1) * _ + y,
                        I = (i + 1) * (_ - 1) + y;
                    a.push(w, A, I), a.push(A, C, I);
                }
            this.setIndex(a),
                this.setAttribute("position", new de(l, 3)),
                this.setAttribute("normal", new de(c, 3)),
                this.setAttribute("uv", new de(h, 2));
            function p(_, y, w, A, C) {
                let I = Math.cos(_),
                    k = Math.sin(_),
                    z = (w / y) * _,
                    P = Math.cos(z);
                (C.x = A * (2 + P) * 0.5 * I),
                    (C.y = A * (2 + P) * k * 0.5),
                    (C.z = A * Math.sin(z) * 0.5);
            }
        }
        static fromJSON(e) {
            return new r(
                e.radius,
                e.tube,
                e.tubularSegments,
                e.radialSegments,
                e.p,
                e.q
            );
        }
    },
    yo = class r extends _e {
        constructor(
            e = new Hs(new M(-1, -1, 0), new M(-1, 1, 0), new M(1, 1, 0)),
            t = 64,
            n = 1,
            i = 8,
            s = !1
        ) {
            super(),
                (this.type = "TubeGeometry"),
                (this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: i,
                    closed: s,
                });
            let o = e.computeFrenetFrames(t, s);
            (this.tangents = o.tangents),
                (this.normals = o.normals),
                (this.binormals = o.binormals);
            let a = new M(),
                l = new M(),
                c = new W(),
                h = new M(),
                u = [],
                d = [],
                f = [],
                m = [];
            x(),
                this.setIndex(m),
                this.setAttribute("position", new de(u, 3)),
                this.setAttribute("normal", new de(d, 3)),
                this.setAttribute("uv", new de(f, 2));
            function x() {
                for (let _ = 0; _ < t; _++) v(_);
                v(s === !1 ? t : 0), p(), g();
            }
            function v(_) {
                h = e.getPointAt(_ / t, h);
                let y = o.normals[_],
                    w = o.binormals[_];
                for (let A = 0; A <= i; A++) {
                    let C = (A / i) * Math.PI * 2,
                        I = Math.sin(C),
                        k = -Math.cos(C);
                    (l.x = k * y.x + I * w.x),
                        (l.y = k * y.y + I * w.y),
                        (l.z = k * y.z + I * w.z),
                        l.normalize(),
                        d.push(l.x, l.y, l.z),
                        (a.x = h.x + n * l.x),
                        (a.y = h.y + n * l.y),
                        (a.z = h.z + n * l.z),
                        u.push(a.x, a.y, a.z);
                }
            }
            function g() {
                for (let _ = 1; _ <= t; _++)
                    for (let y = 1; y <= i; y++) {
                        let w = (i + 1) * (_ - 1) + (y - 1),
                            A = (i + 1) * _ + (y - 1),
                            C = (i + 1) * _ + y,
                            I = (i + 1) * (_ - 1) + y;
                        m.push(w, A, I), m.push(A, C, I);
                    }
            }
            function p() {
                for (let _ = 0; _ <= t; _++)
                    for (let y = 0; y <= i; y++)
                        (c.x = _ / t), (c.y = y / i), f.push(c.x, c.y);
            }
        }
        toJSON() {
            let e = super.toJSON();
            return (e.path = this.parameters.path.toJSON()), e;
        }
        static fromJSON(e) {
            return new r(
                new Hl[e.path.type]().fromJSON(e.path),
                e.tubularSegments,
                e.radius,
                e.radialSegments,
                e.closed
            );
        }
    },
    vo = class extends _e {
        constructor(e = null) {
            if (
                (super(),
                (this.type = "WireframeGeometry"),
                (this.parameters = { geometry: e }),
                e !== null)
            ) {
                let t = [],
                    n = new Set(),
                    i = new M(),
                    s = new M();
                if (e.index !== null) {
                    let o = e.attributes.position,
                        a = e.index,
                        l = e.groups;
                    l.length === 0 &&
                        (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
                    for (let c = 0, h = l.length; c < h; ++c) {
                        let u = l[c],
                            d = u.start,
                            f = u.count;
                        for (let m = d, x = d + f; m < x; m += 3)
                            for (let v = 0; v < 3; v++) {
                                let g = a.getX(m + v),
                                    p = a.getX(m + ((v + 1) % 3));
                                i.fromBufferAttribute(o, g),
                                    s.fromBufferAttribute(o, p),
                                    ch(i, s, n) === !0 &&
                                        (t.push(i.x, i.y, i.z),
                                        t.push(s.x, s.y, s.z));
                            }
                    }
                } else {
                    let o = e.attributes.position;
                    for (let a = 0, l = o.count / 3; a < l; a++)
                        for (let c = 0; c < 3; c++) {
                            let h = 3 * a + c,
                                u = 3 * a + ((c + 1) % 3);
                            i.fromBufferAttribute(o, h),
                                s.fromBufferAttribute(o, u),
                                ch(i, s, n) === !0 &&
                                    (t.push(i.x, i.y, i.z),
                                    t.push(s.x, s.y, s.z));
                        }
                }
                this.setAttribute("position", new de(t, 3));
            }
        }
    };
function ch(r, e, t) {
    let n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,
        i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
    return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n, i), !0);
}
var hh = Object.freeze({
        __proto__: null,
        BoxGeometry: $n,
        BoxBufferGeometry: $n,
        CircleGeometry: so,
        CircleBufferGeometry: so,
        ConeGeometry: ro,
        ConeBufferGeometry: ro,
        CylinderGeometry: Ui,
        CylinderBufferGeometry: Ui,
        DodecahedronGeometry: oo,
        DodecahedronBufferGeometry: oo,
        EdgesGeometry: ao,
        ExtrudeGeometry: In,
        ExtrudeBufferGeometry: In,
        IcosahedronGeometry: uo,
        IcosahedronBufferGeometry: uo,
        LatheGeometry: fo,
        LatheBufferGeometry: fo,
        OctahedronGeometry: qs,
        OctahedronBufferGeometry: qs,
        PlaneGeometry: Rs,
        PlaneBufferGeometry: Rs,
        PolyhedronGeometry: Ln,
        PolyhedronBufferGeometry: Ln,
        RingGeometry: po,
        RingBufferGeometry: po,
        ShapeGeometry: Xs,
        ShapeBufferGeometry: Xs,
        SphereGeometry: Js,
        SphereBufferGeometry: Js,
        TetrahedronGeometry: mo,
        TetrahedronBufferGeometry: mo,
        TorusGeometry: go,
        TorusBufferGeometry: go,
        TorusKnotGeometry: xo,
        TorusKnotBufferGeometry: xo,
        TubeGeometry: yo,
        TubeBufferGeometry: yo,
        WireframeGeometry: vo,
    }),
    _o = class extends ct {
        constructor(e) {
            super(),
                (this.type = "ShadowMaterial"),
                (this.color = new re(0)),
                (this.transparent = !0),
                this.setValues(e);
        }
        copy(e) {
            return super.copy(e), this.color.copy(e.color), this;
        }
    };
_o.prototype.isShadowMaterial = !0;
var Ys = class extends ct {
    constructor(e) {
        super(),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new re(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new re(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Qi),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            this
        );
    }
};
Ys.prototype.isMeshStandardMaterial = !0;
var Mo = class extends Ys {
    constructor(e) {
        super(),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new W(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
                get: function () {
                    return mt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                    this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
            }),
            (this.sheenColor = new re(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 0),
            (this.attenuationColor = new re(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new re(1, 1, 1)),
            (this.specularColorMap = null),
            (this._sheen = 0),
            (this._clearcoat = 0),
            (this._transmission = 0),
            this.setValues(e);
    }
    get sheen() {
        return this._sheen;
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.ior = e.ior),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
        );
    }
};
Mo.prototype.isMeshPhysicalMaterial = !0;
var wo = class extends ct {
    constructor(e) {
        super(),
            (this.type = "MeshPhongMaterial"),
            (this.color = new re(16777215)),
            (this.specular = new re(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new re(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Qi),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Go),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            this
        );
    }
};
wo.prototype.isMeshPhongMaterial = !0;
var bo = class extends ct {
    constructor(e) {
        super(),
            (this.defines = { TOON: "" }),
            (this.type = "MeshToonMaterial"),
            (this.color = new re(16777215)),
            (this.map = null),
            (this.gradientMap = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new re(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Qi),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.gradientMap = e.gradientMap),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            this
        );
    }
};
bo.prototype.isMeshToonMaterial = !0;
var So = class extends ct {
    constructor(e) {
        super(),
            (this.type = "MeshNormalMaterial"),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Qi),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.flatShading = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
        );
    }
};
So.prototype.isMeshNormalMaterial = !0;
var To = class extends ct {
    constructor(e) {
        super(),
            (this.type = "MeshLambertMaterial"),
            (this.color = new re(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new re(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Go),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            this
        );
    }
};
To.prototype.isMeshLambertMaterial = !0;
var Eo = class extends ct {
    constructor(e) {
        super(),
            (this.defines = { MATCAP: "" }),
            (this.type = "MeshMatcapMaterial"),
            (this.color = new re(16777215)),
            (this.matcap = null),
            (this.map = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Qi),
            (this.normalScale = new W(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.alphaMap = null),
            (this.flatShading = !1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.defines = { MATCAP: "" }),
            this.color.copy(e.color),
            (this.matcap = e.matcap),
            (this.map = e.map),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.alphaMap = e.alphaMap),
            (this.flatShading = e.flatShading),
            this
        );
    }
};
Eo.prototype.isMeshMatcapMaterial = !0;
var Ao = class extends ht {
    constructor(e) {
        super(),
            (this.type = "LineDashedMaterial"),
            (this.scale = 1),
            (this.dashSize = 3),
            (this.gapSize = 1),
            this.setValues(e);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.scale = e.scale),
            (this.dashSize = e.dashSize),
            (this.gapSize = e.gapSize),
            this
        );
    }
};
Ao.prototype.isLineDashedMaterial = !0;
var Ty = Object.freeze({
        __proto__: null,
        ShadowMaterial: _o,
        SpriteMaterial: Fs,
        RawShaderMaterial: Qn,
        ShaderMaterial: Zt,
        PointsMaterial: Cn,
        MeshPhysicalMaterial: Mo,
        MeshStandardMaterial: Ys,
        MeshPhongMaterial: wo,
        MeshToonMaterial: bo,
        MeshNormalMaterial: So,
        MeshLambertMaterial: To,
        MeshDepthMaterial: Ls,
        MeshDistanceMaterial: Ps,
        MeshBasicMaterial: Yt,
        MeshMatcapMaterial: Eo,
        LineDashedMaterial: Ao,
        LineBasicMaterial: ht,
        Material: ct,
    }),
    Ze = {
        arraySlice: function (r, e, t) {
            return Ze.isTypedArray(r)
                ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
                : r.slice(e, t);
        },
        convertArray: function (r, e, t) {
            return !r || (!t && r.constructor === e)
                ? r
                : typeof e.BYTES_PER_ELEMENT == "number"
                ? new e(r)
                : Array.prototype.slice.call(r);
        },
        isTypedArray: function (r) {
            return ArrayBuffer.isView(r) && !(r instanceof DataView);
        },
        getKeyframeOrder: function (r) {
            function e(i, s) {
                return r[i] - r[s];
            }
            let t = r.length,
                n = new Array(t);
            for (let i = 0; i !== t; ++i) n[i] = i;
            return n.sort(e), n;
        },
        sortedArray: function (r, e, t) {
            let n = r.length,
                i = new r.constructor(n);
            for (let s = 0, o = 0; o !== n; ++s) {
                let a = t[s] * e;
                for (let l = 0; l !== e; ++l) i[o++] = r[a + l];
            }
            return i;
        },
        flattenJSON: function (r, e, t, n) {
            let i = 1,
                s = r[0];
            for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
            if (s === void 0) return;
            let o = s[n];
            if (o !== void 0)
                if (Array.isArray(o))
                    do
                        (o = s[n]),
                            o !== void 0 &&
                                (e.push(s.time), t.push.apply(t, o)),
                            (s = r[i++]);
                    while (s !== void 0);
                else if (o.toArray !== void 0)
                    do
                        (o = s[n]),
                            o !== void 0 &&
                                (e.push(s.time), o.toArray(t, t.length)),
                            (s = r[i++]);
                    while (s !== void 0);
                else
                    do
                        (o = s[n]),
                            o !== void 0 && (e.push(s.time), t.push(o)),
                            (s = r[i++]);
                    while (s !== void 0);
        },
        subclip: function (r, e, t, n, i = 30) {
            let s = r.clone();
            s.name = e;
            let o = [];
            for (let l = 0; l < s.tracks.length; ++l) {
                let c = s.tracks[l],
                    h = c.getValueSize(),
                    u = [],
                    d = [];
                for (let f = 0; f < c.times.length; ++f) {
                    let m = c.times[f] * i;
                    if (!(m < t || m >= n)) {
                        u.push(c.times[f]);
                        for (let x = 0; x < h; ++x) d.push(c.values[f * h + x]);
                    }
                }
                u.length !== 0 &&
                    ((c.times = Ze.convertArray(u, c.times.constructor)),
                    (c.values = Ze.convertArray(d, c.values.constructor)),
                    o.push(c));
            }
            s.tracks = o;
            let a = 1 / 0;
            for (let l = 0; l < s.tracks.length; ++l)
                a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
            for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
            return s.resetDuration(), s;
        },
        makeClipAdditive: function (r, e = 0, t = r, n = 30) {
            n <= 0 && (n = 30);
            let i = t.tracks.length,
                s = e / n;
            for (let o = 0; o < i; ++o) {
                let a = t.tracks[o],
                    l = a.ValueTypeName;
                if (l === "bool" || l === "string") continue;
                let c = r.tracks.find(function (g) {
                    return g.name === a.name && g.ValueTypeName === l;
                });
                if (c === void 0) continue;
                let h = 0,
                    u = a.getValueSize();
                a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                    (h = u / 3);
                let d = 0,
                    f = c.getValueSize();
                c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                    (d = f / 3);
                let m = a.times.length - 1,
                    x;
                if (s <= a.times[0]) {
                    let g = h,
                        p = u - h;
                    x = Ze.arraySlice(a.values, g, p);
                } else if (s >= a.times[m]) {
                    let g = m * u + h,
                        p = g + u - h;
                    x = Ze.arraySlice(a.values, g, p);
                } else {
                    let g = a.createInterpolant(),
                        p = h,
                        _ = u - h;
                    g.evaluate(s), (x = Ze.arraySlice(g.resultBuffer, p, _));
                }
                l === "quaternion" &&
                    new dt().fromArray(x).normalize().conjugate().toArray(x);
                let v = c.times.length;
                for (let g = 0; g < v; ++g) {
                    let p = g * f + d;
                    if (l === "quaternion")
                        dt.multiplyQuaternionsFlat(
                            c.values,
                            p,
                            x,
                            0,
                            c.values,
                            p
                        );
                    else {
                        let _ = f - d * 2;
                        for (let y = 0; y < _; ++y) c.values[p + y] -= x[y];
                    }
                }
            }
            return (r.blendMode = nu), r;
        },
    },
    jt = class {
        constructor(e, t, n, i) {
            (this.parameterPositions = e),
                (this._cachedIndex = 0),
                (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
                (this.sampleValues = t),
                (this.valueSize = n),
                (this.settings = null),
                (this.DefaultSettings_ = {});
        }
        evaluate(e) {
            let t = this.parameterPositions,
                n = this._cachedIndex,
                i = t[n],
                s = t[n - 1];
            e: {
                t: {
                    let o;
                    n: {
                        i: if (!(e < i)) {
                            for (let a = n + 2; ; ) {
                                if (i === void 0) {
                                    if (e < s) break i;
                                    return (
                                        (n = t.length),
                                        (this._cachedIndex = n),
                                        this.afterEnd_(n - 1, e, s)
                                    );
                                }
                                if (n === a) break;
                                if (((s = i), (i = t[++n]), e < i)) break t;
                            }
                            o = t.length;
                            break n;
                        }
                        if (!(e >= s)) {
                            let a = t[1];
                            e < a && ((n = 2), (s = a));
                            for (let l = n - 2; ; ) {
                                if (s === void 0)
                                    return (
                                        (this._cachedIndex = 0),
                                        this.beforeStart_(0, e, i)
                                    );
                                if (n === l) break;
                                if (((i = s), (s = t[--n - 1]), e >= s))
                                    break t;
                            }
                            (o = n), (n = 0);
                            break n;
                        }
                        break e;
                    }
                    for (; n < o; ) {
                        let a = (n + o) >>> 1;
                        e < t[a] ? (o = a) : (n = a + 1);
                    }
                    if (((i = t[n]), (s = t[n - 1]), s === void 0))
                        return (
                            (this._cachedIndex = 0), this.beforeStart_(0, e, i)
                        );
                    if (i === void 0)
                        return (
                            (n = t.length),
                            (this._cachedIndex = n),
                            this.afterEnd_(n - 1, s, e)
                        );
                }
                (this._cachedIndex = n), this.intervalChanged_(n, s, i);
            }
            return this.interpolate_(n, s, e, i);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
            let t = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                s = e * i;
            for (let o = 0; o !== i; ++o) t[o] = n[s + o];
            return t;
        }
        interpolate_() {
            throw new Error("call to abstract method");
        }
        intervalChanged_() {}
    };
jt.prototype.beforeStart_ = jt.prototype.copySampleValue_;
jt.prototype.afterEnd_ = jt.prototype.copySampleValue_;
var rl = class extends jt {
        constructor(e, t, n, i) {
            super(e, t, n, i),
                (this._weightPrev = -0),
                (this._offsetPrev = -0),
                (this._weightNext = -0),
                (this._offsetNext = -0),
                (this.DefaultSettings_ = { endingStart: bi, endingEnd: bi });
        }
        intervalChanged_(e, t, n) {
            let i = this.parameterPositions,
                s = e - 2,
                o = e + 1,
                a = i[s],
                l = i[o];
            if (a === void 0)
                switch (this.getSettings_().endingStart) {
                    case Si:
                        (s = e), (a = 2 * t - n);
                        break;
                    case Zr:
                        (s = i.length - 2), (a = t + i[s] - i[s + 1]);
                        break;
                    default:
                        (s = e), (a = n);
                }
            if (l === void 0)
                switch (this.getSettings_().endingEnd) {
                    case Si:
                        (o = e), (l = 2 * n - t);
                        break;
                    case Zr:
                        (o = 1), (l = n + i[1] - i[0]);
                        break;
                    default:
                        (o = e - 1), (l = t);
                }
            let c = (n - t) * 0.5,
                h = this.valueSize;
            (this._weightPrev = c / (t - a)),
                (this._weightNext = c / (l - n)),
                (this._offsetPrev = s * h),
                (this._offsetNext = o * h);
        }
        interpolate_(e, t, n, i) {
            let s = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                l = e * a,
                c = l - a,
                h = this._offsetPrev,
                u = this._offsetNext,
                d = this._weightPrev,
                f = this._weightNext,
                m = (n - t) / (i - t),
                x = m * m,
                v = x * m,
                g = -d * v + 2 * d * x - d * m,
                p = (1 + d) * v + (-1.5 - 2 * d) * x + (-0.5 + d) * m + 1,
                _ = (-1 - f) * v + (1.5 + f) * x + 0.5 * m,
                y = f * v - f * x;
            for (let w = 0; w !== a; ++w)
                s[w] =
                    g * o[h + w] + p * o[c + w] + _ * o[l + w] + y * o[u + w];
            return s;
        }
    },
    Ro = class extends jt {
        constructor(e, t, n, i) {
            super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
            let s = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                l = e * a,
                c = l - a,
                h = (n - t) / (i - t),
                u = 1 - h;
            for (let d = 0; d !== a; ++d) s[d] = o[c + d] * u + o[l + d] * h;
            return s;
        }
    },
    ol = class extends jt {
        constructor(e, t, n, i) {
            super(e, t, n, i);
        }
        interpolate_(e) {
            return this.copySampleValue_(e - 1);
        }
    },
    Pt = class {
        constructor(e, t, n, i) {
            if (e === void 0)
                throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (t === void 0 || t.length === 0)
                throw new Error(
                    "THREE.KeyframeTrack: no keyframes in track named " + e
                );
            (this.name = e),
                (this.times = Ze.convertArray(t, this.TimeBufferType)),
                (this.values = Ze.convertArray(n, this.ValueBufferType)),
                this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
            let t = e.constructor,
                n;
            if (t.toJSON !== this.toJSON) n = t.toJSON(e);
            else {
                n = {
                    name: e.name,
                    times: Ze.convertArray(e.times, Array),
                    values: Ze.convertArray(e.values, Array),
                };
                let i = e.getInterpolation();
                i !== e.DefaultInterpolation && (n.interpolation = i);
            }
            return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
            return new ol(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
            return new Ro(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
            return new rl(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
            let t;
            switch (e) {
                case Jr:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Yr:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case Zo:
                    t = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (t === void 0) {
                let n =
                    "unsupported interpolation for " +
                    this.ValueTypeName +
                    " keyframe track named " +
                    this.name;
                if (this.createInterpolant === void 0)
                    if (e !== this.DefaultInterpolation)
                        this.setInterpolation(this.DefaultInterpolation);
                    else throw new Error(n);
                return console.warn("THREE.KeyframeTrack:", n), this;
            }
            return (this.createInterpolant = t), this;
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Jr;
                case this.InterpolantFactoryMethodLinear:
                    return Yr;
                case this.InterpolantFactoryMethodSmooth:
                    return Zo;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        shift(e) {
            if (e !== 0) {
                let t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
            }
            return this;
        }
        scale(e) {
            if (e !== 1) {
                let t = this.times;
                for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
            }
            return this;
        }
        trim(e, t) {
            let n = this.times,
                i = n.length,
                s = 0,
                o = i - 1;
            for (; s !== i && n[s] < e; ) ++s;
            for (; o !== -1 && n[o] > t; ) --o;
            if ((++o, s !== 0 || o !== i)) {
                s >= o && ((o = Math.max(o, 1)), (s = o - 1));
                let a = this.getValueSize();
                (this.times = Ze.arraySlice(n, s, o)),
                    (this.values = Ze.arraySlice(this.values, s * a, o * a));
            }
            return this;
        }
        validate() {
            let e = !0,
                t = this.getValueSize();
            t - Math.floor(t) !== 0 &&
                (console.error(
                    "THREE.KeyframeTrack: Invalid value size in track.",
                    this
                ),
                (e = !1));
            let n = this.times,
                i = this.values,
                s = n.length;
            s === 0 &&
                (console.error("THREE.KeyframeTrack: Track is empty.", this),
                (e = !1));
            let o = null;
            for (let a = 0; a !== s; a++) {
                let l = n[a];
                if (typeof l == "number" && isNaN(l)) {
                    console.error(
                        "THREE.KeyframeTrack: Time is not a valid number.",
                        this,
                        a,
                        l
                    ),
                        (e = !1);
                    break;
                }
                if (o !== null && o > l) {
                    console.error(
                        "THREE.KeyframeTrack: Out of order keys.",
                        this,
                        a,
                        l,
                        o
                    ),
                        (e = !1);
                    break;
                }
                o = l;
            }
            if (i !== void 0 && Ze.isTypedArray(i))
                for (let a = 0, l = i.length; a !== l; ++a) {
                    let c = i[a];
                    if (isNaN(c)) {
                        console.error(
                            "THREE.KeyframeTrack: Value is not a valid number.",
                            this,
                            a,
                            c
                        ),
                            (e = !1);
                        break;
                    }
                }
            return e;
        }
        optimize() {
            let e = Ze.arraySlice(this.times),
                t = Ze.arraySlice(this.values),
                n = this.getValueSize(),
                i = this.getInterpolation() === Zo,
                s = e.length - 1,
                o = 1;
            for (let a = 1; a < s; ++a) {
                let l = !1,
                    c = e[a],
                    h = e[a + 1];
                if (c !== h && (a !== 1 || c !== e[0]))
                    if (i) l = !0;
                    else {
                        let u = a * n,
                            d = u - n,
                            f = u + n;
                        for (let m = 0; m !== n; ++m) {
                            let x = t[u + m];
                            if (x !== t[d + m] || x !== t[f + m]) {
                                l = !0;
                                break;
                            }
                        }
                    }
                if (l) {
                    if (a !== o) {
                        e[o] = e[a];
                        let u = a * n,
                            d = o * n;
                        for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
                    }
                    ++o;
                }
            }
            if (s > 0) {
                e[o] = e[s];
                for (let a = s * n, l = o * n, c = 0; c !== n; ++c)
                    t[l + c] = t[a + c];
                ++o;
            }
            return (
                o !== e.length
                    ? ((this.times = Ze.arraySlice(e, 0, o)),
                      (this.values = Ze.arraySlice(t, 0, o * n)))
                    : ((this.times = e), (this.values = t)),
                this
            );
        }
        clone() {
            let e = Ze.arraySlice(this.times, 0),
                t = Ze.arraySlice(this.values, 0),
                n = this.constructor,
                i = new n(this.name, e, t);
            return (i.createInterpolant = this.createInterpolant), i;
        }
    };
Pt.prototype.TimeBufferType = Float32Array;
Pt.prototype.ValueBufferType = Float32Array;
Pt.prototype.DefaultInterpolation = Yr;
var Dn = class extends Pt {};
Dn.prototype.ValueTypeName = "bool";
Dn.prototype.ValueBufferType = Array;
Dn.prototype.DefaultInterpolation = Jr;
Dn.prototype.InterpolantFactoryMethodLinear = void 0;
Dn.prototype.InterpolantFactoryMethodSmooth = void 0;
var Co = class extends Pt {};
Co.prototype.ValueTypeName = "color";
var Vi = class extends Pt {};
Vi.prototype.ValueTypeName = "number";
var al = class extends jt {
        constructor(e, t, n, i) {
            super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
            let s = this.resultBuffer,
                o = this.sampleValues,
                a = this.valueSize,
                l = (n - t) / (i - t),
                c = e * a;
            for (let h = c + a; c !== h; c += 4)
                dt.slerpFlat(s, 0, o, c - a, o, c, l);
            return s;
        }
    },
    ei = class extends Pt {
        InterpolantFactoryMethodLinear(e) {
            return new al(this.times, this.values, this.getValueSize(), e);
        }
    };
ei.prototype.ValueTypeName = "quaternion";
ei.prototype.DefaultInterpolation = Yr;
ei.prototype.InterpolantFactoryMethodSmooth = void 0;
var Fn = class extends Pt {};
Fn.prototype.ValueTypeName = "string";
Fn.prototype.ValueBufferType = Array;
Fn.prototype.DefaultInterpolation = Jr;
Fn.prototype.InterpolantFactoryMethodLinear = void 0;
Fn.prototype.InterpolantFactoryMethodSmooth = void 0;
var Gi = class extends Pt {};
Gi.prototype.ValueTypeName = "vector";
var Wi = class {
    constructor(e, t = -1, n, i = Nl) {
        (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = Ct()),
            this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
        let t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o) t.push(Ay(n[o]).scale(i));
        let s = new this(e.name, e.duration, t, e.blendMode);
        return (s.uuid = e.uuid), s;
    }
    static toJSON(e) {
        let t = [],
            n = e.tracks,
            i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode,
            };
        for (let s = 0, o = n.length; s !== o; ++s) t.push(Pt.toJSON(n[s]));
        return i;
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        let s = t.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let l = [],
                c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            let h = Ze.getKeyframeOrder(l);
            (l = Ze.sortedArray(l, 1, h)),
                (c = Ze.sortedArray(c, 1, h)),
                !i && l[0] === 0 && (l.push(s), c.push(c[0])),
                o.push(
                    new Vi(
                        ".morphTargetInfluences[" + t[a].name + "]",
                        l,
                        c
                    ).scale(1 / n)
                );
        }
        return new this(e, -1, o);
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            let i = e;
            n = (i.geometry && i.geometry.animations) || i.animations;
        }
        for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
        return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        let i = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            let c = e[a],
                h = c.name.match(s);
            if (h && h.length > 1) {
                let u = h[1],
                    d = i[u];
                d || (i[u] = d = []), d.push(c);
            }
        }
        let o = [];
        for (let a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
        return o;
    }
    static parseAnimation(e, t) {
        if (!e)
            return (
                console.error(
                    "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
            );
        let n = function (u, d, f, m, x) {
                if (f.length !== 0) {
                    let v = [],
                        g = [];
                    Ze.flattenJSON(f, v, g, m),
                        v.length !== 0 && x.push(new u(d, v, g));
                }
            },
            i = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode,
            l = e.length || -1,
            c = e.hierarchy || [];
        for (let u = 0; u < c.length; u++) {
            let d = c[u].keys;
            if (!(!d || d.length === 0))
                if (d[0].morphTargets) {
                    let f = {},
                        m;
                    for (m = 0; m < d.length; m++)
                        if (d[m].morphTargets)
                            for (let x = 0; x < d[m].morphTargets.length; x++)
                                f[d[m].morphTargets[x]] = -1;
                    for (let x in f) {
                        let v = [],
                            g = [];
                        for (let p = 0; p !== d[m].morphTargets.length; ++p) {
                            let _ = d[m];
                            v.push(_.time), g.push(_.morphTarget === x ? 1 : 0);
                        }
                        i.push(
                            new Vi(".morphTargetInfluence[" + x + "]", v, g)
                        );
                    }
                    l = f.length * (o || 1);
                } else {
                    let f = ".bones[" + t[u].name + "]";
                    n(Gi, f + ".position", d, "pos", i),
                        n(ei, f + ".quaternion", d, "rot", i),
                        n(Gi, f + ".scale", d, "scl", i);
                }
        }
        return i.length === 0 ? null : new this(s, l, i, a);
    }
    resetDuration() {
        let e = this.tracks,
            t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            let s = this.tracks[n];
            t = Math.max(t, s.times[s.times.length - 1]);
        }
        return (this.duration = t), this;
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this;
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e;
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
    }
    clone() {
        let e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
        );
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
};
function Ey(r) {
    switch (r.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return Vi;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return Gi;
        case "color":
            return Co;
        case "quaternion":
            return ei;
        case "bool":
        case "boolean":
            return Dn;
        case "string":
            return Fn;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function Ay(r) {
    if (r.type === void 0)
        throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
        );
    let e = Ey(r.type);
    if (r.times === void 0) {
        let t = [],
            n = [];
        Ze.flattenJSON(r.keys, t, n, "value"), (r.times = t), (r.values = n);
    }
    return e.parse !== void 0
        ? e.parse(r)
        : new e(r.name, r.times, r.values, r.interpolation);
}
var qi = {
        enabled: !1,
        files: {},
        add: function (r, e) {
            this.enabled !== !1 && (this.files[r] = e);
        },
        get: function (r) {
            if (this.enabled !== !1) return this.files[r];
        },
        remove: function (r) {
            delete this.files[r];
        },
        clear: function () {
            this.files = {};
        },
    },
    Lo = class {
        constructor(e, t, n) {
            let i = this,
                s = !1,
                o = 0,
                a = 0,
                l,
                c = [];
            (this.onStart = void 0),
                (this.onLoad = e),
                (this.onProgress = t),
                (this.onError = n),
                (this.itemStart = function (h) {
                    a++,
                        s === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
                        (s = !0);
                }),
                (this.itemEnd = function (h) {
                    o++,
                        i.onProgress !== void 0 && i.onProgress(h, o, a),
                        o === a &&
                            ((s = !1), i.onLoad !== void 0 && i.onLoad());
                }),
                (this.itemError = function (h) {
                    i.onError !== void 0 && i.onError(h);
                }),
                (this.resolveURL = function (h) {
                    return l ? l(h) : h;
                }),
                (this.setURLModifier = function (h) {
                    return (l = h), this;
                }),
                (this.addHandler = function (h, u) {
                    return c.push(h, u), this;
                }),
                (this.removeHandler = function (h) {
                    let u = c.indexOf(h);
                    return u !== -1 && c.splice(u, 2), this;
                }),
                (this.getHandler = function (h) {
                    for (let u = 0, d = c.length; u < d; u += 2) {
                        let f = c[u],
                            m = c[u + 1];
                        if ((f.global && (f.lastIndex = 0), f.test(h)))
                            return m;
                    }
                    return null;
                });
        }
    },
    Ry = new Lo(),
    Mt = class {
        constructor(e) {
            (this.manager = e !== void 0 ? e : Ry),
                (this.crossOrigin = "anonymous"),
                (this.withCredentials = !1),
                (this.path = ""),
                (this.resourcePath = ""),
                (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
            let n = this;
            return new Promise(function (i, s) {
                n.load(e, i, t, s);
            });
        }
        parse() {}
        setCrossOrigin(e) {
            return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
            return (this.withCredentials = e), this;
        }
        setPath(e) {
            return (this.path = e), this;
        }
        setResourcePath(e) {
            return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
            return (this.requestHeader = e), this;
        }
    },
    rn = {},
    Ht = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""),
                this.path !== void 0 && (e = this.path + e),
                (e = this.manager.resolveURL(e));
            let s = qi.get(e);
            if (s !== void 0)
                return (
                    this.manager.itemStart(e),
                    setTimeout(() => {
                        t && t(s), this.manager.itemEnd(e);
                    }, 0),
                    s
                );
            if (rn[e] !== void 0) {
                rn[e].push({ onLoad: t, onProgress: n, onError: i });
                return;
            }
            (rn[e] = []), rn[e].push({ onLoad: t, onProgress: n, onError: i });
            let o = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin",
            });
            fetch(o)
                .then((a) => {
                    if (a.status === 200 || a.status === 0) {
                        if (
                            (a.status === 0 &&
                                console.warn(
                                    "THREE.FileLoader: HTTP Status 0 received."
                                ),
                            typeof ReadableStream > "u" ||
                                a.body.getReader === void 0)
                        )
                            return a;
                        let l = rn[e],
                            c = a.body.getReader(),
                            h = a.headers.get("Content-Length"),
                            u = h ? parseInt(h) : 0,
                            d = u !== 0,
                            f = 0,
                            m = new ReadableStream({
                                start(x) {
                                    v();
                                    function v() {
                                        c.read().then(
                                            ({ done: g, value: p }) => {
                                                if (g) x.close();
                                                else {
                                                    f += p.byteLength;
                                                    let _ = new ProgressEvent(
                                                        "progress",
                                                        {
                                                            lengthComputable: d,
                                                            loaded: f,
                                                            total: u,
                                                        }
                                                    );
                                                    for (
                                                        let y = 0, w = l.length;
                                                        y < w;
                                                        y++
                                                    ) {
                                                        let A = l[y];
                                                        A.onProgress &&
                                                            A.onProgress(_);
                                                    }
                                                    x.enqueue(p), v();
                                                }
                                            }
                                        );
                                    }
                                },
                            });
                        return new Response(m);
                    } else
                        throw Error(
                            `fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`
                        );
                })
                .then((a) => {
                    switch (this.responseType) {
                        case "arraybuffer":
                            return a.arrayBuffer();
                        case "blob":
                            return a.blob();
                        case "document":
                            return a
                                .text()
                                .then((l) =>
                                    new DOMParser().parseFromString(
                                        l,
                                        this.mimeType
                                    )
                                );
                        case "json":
                            return a.json();
                        default:
                            return a.text();
                    }
                })
                .then((a) => {
                    qi.add(e, a);
                    let l = rn[e];
                    delete rn[e];
                    for (let c = 0, h = l.length; c < h; c++) {
                        let u = l[c];
                        u.onLoad && u.onLoad(a);
                    }
                })
                .catch((a) => {
                    let l = rn[e];
                    if (l === void 0) throw (this.manager.itemError(e), a);
                    delete rn[e];
                    for (let c = 0, h = l.length; c < h; c++) {
                        let u = l[c];
                        u.onError && u.onError(a);
                    }
                    this.manager.itemError(e);
                })
                .finally(() => {
                    this.manager.itemEnd(e);
                }),
                this.manager.itemStart(e);
        }
        setResponseType(e) {
            return (this.responseType = e), this;
        }
        setMimeType(e) {
            return (this.mimeType = e), this;
        }
    },
    uh = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = this,
                o = new Ht(this.manager);
            o.setPath(this.path),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(
                    e,
                    function (a) {
                        try {
                            t(s.parse(JSON.parse(a)));
                        } catch (l) {
                            i ? i(l) : console.error(l), s.manager.itemError(e);
                        }
                    },
                    n,
                    i
                );
        }
        parse(e) {
            let t = [];
            for (let n = 0; n < e.length; n++) {
                let i = Wi.parse(e[n]);
                t.push(i);
            }
            return t;
        }
    },
    dh = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = this,
                o = [],
                a = new io(),
                l = new Ht(this.manager);
            l.setPath(this.path),
                l.setResponseType("arraybuffer"),
                l.setRequestHeader(this.requestHeader),
                l.setWithCredentials(s.withCredentials);
            let c = 0;
            function h(u) {
                l.load(
                    e[u],
                    function (d) {
                        let f = s.parse(d, !0);
                        (o[u] = {
                            width: f.width,
                            height: f.height,
                            format: f.format,
                            mipmaps: f.mipmaps,
                        }),
                            (c += 1),
                            c === 6 &&
                                (f.mipmapCount === 1 && (a.minFilter = tt),
                                (a.image = o),
                                (a.format = f.format),
                                (a.needsUpdate = !0),
                                t && t(a));
                    },
                    n,
                    i
                );
            }
            if (Array.isArray(e))
                for (let u = 0, d = e.length; u < d; ++u) h(u);
            else
                l.load(
                    e,
                    function (u) {
                        let d = s.parse(u, !0);
                        if (d.isCubemap) {
                            let f = d.mipmaps.length / d.mipmapCount;
                            for (let m = 0; m < f; m++) {
                                o[m] = { mipmaps: [] };
                                for (let x = 0; x < d.mipmapCount; x++)
                                    o[m].mipmaps.push(
                                        d.mipmaps[m * d.mipmapCount + x]
                                    ),
                                        (o[m].format = d.format),
                                        (o[m].width = d.width),
                                        (o[m].height = d.height);
                            }
                            a.image = o;
                        } else
                            (a.image.width = d.width),
                                (a.image.height = d.height),
                                (a.mipmaps = d.mipmaps);
                        d.mipmapCount === 1 && (a.minFilter = tt),
                            (a.format = d.format),
                            (a.needsUpdate = !0),
                            t && t(a);
                    },
                    n,
                    i
                );
            return a;
        }
    },
    Xi = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            this.path !== void 0 && (e = this.path + e),
                (e = this.manager.resolveURL(e));
            let s = this,
                o = qi.get(e);
            if (o !== void 0)
                return (
                    s.manager.itemStart(e),
                    setTimeout(function () {
                        t && t(o), s.manager.itemEnd(e);
                    }, 0),
                    o
                );
            let a = qo("img");
            function l() {
                h(), qi.add(e, this), t && t(this), s.manager.itemEnd(e);
            }
            function c(u) {
                h(), i && i(u), s.manager.itemError(e), s.manager.itemEnd(e);
            }
            function h() {
                a.removeEventListener("load", l, !1),
                    a.removeEventListener("error", c, !1);
            }
            return (
                a.addEventListener("load", l, !1),
                a.addEventListener("error", c, !1),
                e.substr(0, 5) !== "data:" &&
                    this.crossOrigin !== void 0 &&
                    (a.crossOrigin = this.crossOrigin),
                s.manager.itemStart(e),
                (a.src = e),
                a
            );
        }
    },
    ll = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = new jn(),
                o = new Xi(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            let a = 0;
            function l(c) {
                o.load(
                    e[c],
                    function (h) {
                        (s.images[c] = h),
                            a++,
                            a === 6 && ((s.needsUpdate = !0), t && t(s));
                    },
                    void 0,
                    i
                );
            }
            for (let c = 0; c < e.length; ++c) l(c);
            return s;
        }
    },
    cl = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = this,
                o = new Tn(),
                a = new Ht(this.manager);
            return (
                a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setPath(this.path),
                a.setWithCredentials(s.withCredentials),
                a.load(
                    e,
                    function (l) {
                        let c = s.parse(l);
                        c &&
                            (c.image !== void 0
                                ? (o.image = c.image)
                                : c.data !== void 0 &&
                                  ((o.image.width = c.width),
                                  (o.image.height = c.height),
                                  (o.image.data = c.data)),
                            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : yt),
                            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : yt),
                            (o.magFilter =
                                c.magFilter !== void 0 ? c.magFilter : tt),
                            (o.minFilter =
                                c.minFilter !== void 0 ? c.minFilter : tt),
                            (o.anisotropy =
                                c.anisotropy !== void 0 ? c.anisotropy : 1),
                            c.encoding !== void 0 && (o.encoding = c.encoding),
                            c.flipY !== void 0 && (o.flipY = c.flipY),
                            c.format !== void 0 && (o.format = c.format),
                            c.type !== void 0 && (o.type = c.type),
                            c.mipmaps !== void 0 &&
                                ((o.mipmaps = c.mipmaps), (o.minFilter = $i)),
                            c.mipmapCount === 1 && (o.minFilter = tt),
                            c.generateMipmaps !== void 0 &&
                                (o.generateMipmaps = c.generateMipmaps),
                            (o.needsUpdate = !0),
                            t && t(o, c));
                    },
                    n,
                    i
                ),
                o
            );
        }
    },
    hl = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = new ft(),
                o = new Xi(this.manager);
            return (
                o.setCrossOrigin(this.crossOrigin),
                o.setPath(this.path),
                o.load(
                    e,
                    function (a) {
                        (s.image = a),
                            (s.needsUpdate = !0),
                            t !== void 0 && t(s);
                    },
                    n,
                    i
                ),
                s
            );
        }
    },
    It = class extends Be {
        constructor(e, t = 1) {
            super(),
                (this.type = "Light"),
                (this.color = new re(e)),
                (this.intensity = t);
        }
        dispose() {}
        copy(e) {
            return (
                super.copy(e),
                this.color.copy(e.color),
                (this.intensity = e.intensity),
                this
            );
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return (
                (t.object.color = this.color.getHex()),
                (t.object.intensity = this.intensity),
                this.groundColor !== void 0 &&
                    (t.object.groundColor = this.groundColor.getHex()),
                this.distance !== void 0 && (t.object.distance = this.distance),
                this.angle !== void 0 && (t.object.angle = this.angle),
                this.decay !== void 0 && (t.object.decay = this.decay),
                this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
                this.shadow !== void 0 &&
                    (t.object.shadow = this.shadow.toJSON()),
                t
            );
        }
    };
It.prototype.isLight = !0;
var Po = class extends It {
    constructor(e, t, n) {
        super(e, n),
            (this.type = "HemisphereLight"),
            this.position.copy(Be.DefaultUp),
            this.updateMatrix(),
            (this.groundColor = new re(t));
    }
    copy(e) {
        return (
            It.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        );
    }
};
Po.prototype.isHemisphereLight = !0;
var fh = new me(),
    ph = new M(),
    mh = new M(),
    Zs = class {
        constructor(e) {
            (this.camera = e),
                (this.bias = 0),
                (this.normalBias = 0),
                (this.radius = 1),
                (this.blurSamples = 8),
                (this.mapSize = new W(512, 512)),
                (this.map = null),
                (this.mapPass = null),
                (this.matrix = new me()),
                (this.autoUpdate = !0),
                (this.needsUpdate = !1),
                (this._frustum = new Ni()),
                (this._frameExtents = new W(1, 1)),
                (this._viewportCount = 1),
                (this._viewports = [new Ve(0, 0, 1, 1)]);
        }
        getViewportCount() {
            return this._viewportCount;
        }
        getFrustum() {
            return this._frustum;
        }
        updateMatrices(e) {
            let t = this.camera,
                n = this.matrix;
            ph.setFromMatrixPosition(e.matrixWorld),
                t.position.copy(ph),
                mh.setFromMatrixPosition(e.target.matrixWorld),
                t.lookAt(mh),
                t.updateMatrixWorld(),
                fh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(fh),
                n.set(
                    0.5,
                    0,
                    0,
                    0.5,
                    0,
                    0.5,
                    0,
                    0.5,
                    0,
                    0,
                    0.5,
                    0.5,
                    0,
                    0,
                    0,
                    1
                ),
                n.multiply(t.projectionMatrix),
                n.multiply(t.matrixWorldInverse);
        }
        getViewport(e) {
            return this._viewports[e];
        }
        getFrameExtents() {
            return this._frameExtents;
        }
        dispose() {
            this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
            return (
                (this.camera = e.camera.clone()),
                (this.bias = e.bias),
                (this.radius = e.radius),
                this.mapSize.copy(e.mapSize),
                this
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            let e = {};
            return (
                this.bias !== 0 && (e.bias = this.bias),
                this.normalBias !== 0 && (e.normalBias = this.normalBias),
                this.radius !== 1 && (e.radius = this.radius),
                (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
                    (e.mapSize = this.mapSize.toArray()),
                (e.camera = this.camera.toJSON(!1).object),
                delete e.camera.matrix,
                e
            );
        }
    },
    Io = class extends Zs {
        constructor() {
            super(new at(50, 1, 0.5, 500)), (this.focus = 1);
        }
        updateMatrices(e) {
            let t = this.camera,
                n = Ms * 2 * e.angle * this.focus,
                i = this.mapSize.width / this.mapSize.height,
                s = e.distance || t.far;
            (n !== t.fov || i !== t.aspect || s !== t.far) &&
                ((t.fov = n),
                (t.aspect = i),
                (t.far = s),
                t.updateProjectionMatrix()),
                super.updateMatrices(e);
        }
        copy(e) {
            return super.copy(e), (this.focus = e.focus), this;
        }
    };
Io.prototype.isSpotLightShadow = !0;
var Do = class extends It {
    constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 1) {
        super(e, t),
            (this.type = "SpotLight"),
            this.position.copy(Be.DefaultUp),
            this.updateMatrix(),
            (this.target = new Be()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = s),
            (this.decay = o),
            (this.shadow = new Io());
    }
    get power() {
        return this.intensity * Math.PI;
    }
    set power(e) {
        this.intensity = e / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return (
            super.copy(e),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
};
Do.prototype.isSpotLight = !0;
var gh = new me(),
    hs = new M(),
    Ra = new M(),
    Fo = class extends Zs {
        constructor() {
            super(new at(90, 1, 0.5, 500)),
                (this._frameExtents = new W(4, 2)),
                (this._viewportCount = 6),
                (this._viewports = [
                    new Ve(2, 1, 1, 1),
                    new Ve(0, 1, 1, 1),
                    new Ve(3, 1, 1, 1),
                    new Ve(1, 1, 1, 1),
                    new Ve(3, 0, 1, 1),
                    new Ve(1, 0, 1, 1),
                ]),
                (this._cubeDirections = [
                    new M(1, 0, 0),
                    new M(-1, 0, 0),
                    new M(0, 0, 1),
                    new M(0, 0, -1),
                    new M(0, 1, 0),
                    new M(0, -1, 0),
                ]),
                (this._cubeUps = [
                    new M(0, 1, 0),
                    new M(0, 1, 0),
                    new M(0, 1, 0),
                    new M(0, 1, 0),
                    new M(0, 0, 1),
                    new M(0, 0, -1),
                ]);
        }
        updateMatrices(e, t = 0) {
            let n = this.camera,
                i = this.matrix,
                s = e.distance || n.far;
            s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
                hs.setFromMatrixPosition(e.matrixWorld),
                n.position.copy(hs),
                Ra.copy(n.position),
                Ra.add(this._cubeDirections[t]),
                n.up.copy(this._cubeUps[t]),
                n.lookAt(Ra),
                n.updateMatrixWorld(),
                i.makeTranslation(-hs.x, -hs.y, -hs.z),
                gh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(gh);
        }
    };
Fo.prototype.isPointLightShadow = !0;
var No = class extends It {
    constructor(e, t, n = 0, i = 1) {
        super(e, t),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Fo());
    }
    get power() {
        return this.intensity * 4 * Math.PI;
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return (
            super.copy(e),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
};
No.prototype.isPointLight = !0;
var zo = class extends Zs {
    constructor() {
        super(new zi(-5, 5, 5, -5, 0.5, 500));
    }
};
zo.prototype.isDirectionalLightShadow = !0;
var Bo = class extends It {
    constructor(e, t) {
        super(e, t),
            (this.type = "DirectionalLight"),
            this.position.copy(Be.DefaultUp),
            this.updateMatrix(),
            (this.target = new Be()),
            (this.shadow = new zo());
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(e) {
        return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
        );
    }
};
Bo.prototype.isDirectionalLight = !0;
var Uo = class extends It {
    constructor(e, t) {
        super(e, t), (this.type = "AmbientLight");
    }
};
Uo.prototype.isAmbientLight = !0;
var Oo = class extends It {
    constructor(e, t, n = 10, i = 10) {
        super(e, t),
            (this.type = "RectAreaLight"),
            (this.width = n),
            (this.height = i);
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
        return (
            super.copy(e),
            (this.width = e.width),
            (this.height = e.height),
            this
        );
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return (
            (t.object.width = this.width), (t.object.height = this.height), t
        );
    }
};
Oo.prototype.isRectAreaLight = !0;
var Ho = class {
    constructor() {
        this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new M());
    }
    set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this;
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this;
    }
    getAt(e, t) {
        let n = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
        return (
            t.copy(o[0]).multiplyScalar(0.282095),
            t.addScaledVector(o[1], 0.488603 * i),
            t.addScaledVector(o[2], 0.488603 * s),
            t.addScaledVector(o[3], 0.488603 * n),
            t.addScaledVector(o[4], 1.092548 * (n * i)),
            t.addScaledVector(o[5], 1.092548 * (i * s)),
            t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
            t.addScaledVector(o[7], 1.092548 * (n * s)),
            t.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
            t
        );
    }
    getIrradianceAt(e, t) {
        let n = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
        return (
            t.copy(o[0]).multiplyScalar(0.886227),
            t.addScaledVector(o[1], 2 * 0.511664 * i),
            t.addScaledVector(o[2], 2 * 0.511664 * s),
            t.addScaledVector(o[3], 2 * 0.511664 * n),
            t.addScaledVector(o[4], 2 * 0.429043 * n * i),
            t.addScaledVector(o[5], 2 * 0.429043 * i * s),
            t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
            t.addScaledVector(o[7], 2 * 0.429043 * n * s),
            t.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
            t
        );
    }
    add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this;
    }
    addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this;
    }
    scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this;
    }
    lerp(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
        return this;
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0;
    }
    copy(e) {
        return this.set(e.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
        let n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
        return this;
    }
    toArray(e = [], t = 0) {
        let n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
        return e;
    }
    static getBasisAt(e, t) {
        let n = e.x,
            i = e.y,
            s = e.z;
        (t[0] = 0.282095),
            (t[1] = 0.488603 * i),
            (t[2] = 0.488603 * s),
            (t[3] = 0.488603 * n),
            (t[4] = 1.092548 * n * i),
            (t[5] = 1.092548 * i * s),
            (t[6] = 0.315392 * (3 * s * s - 1)),
            (t[7] = 1.092548 * n * s),
            (t[8] = 0.546274 * (n * n - i * i));
    }
};
Ho.prototype.isSphericalHarmonics3 = !0;
var Ji = class extends It {
    constructor(e = new Ho(), t = 1) {
        super(void 0, t), (this.sh = e);
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
        return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return (t.object.sh = this.sh.toArray()), t;
    }
};
Ji.prototype.isLightProbe = !0;
var ul = class extends Mt {
        constructor(e) {
            super(e), (this.textures = {});
        }
        load(e, t, n, i) {
            let s = this,
                o = new Ht(s.manager);
            o.setPath(s.path),
                o.setRequestHeader(s.requestHeader),
                o.setWithCredentials(s.withCredentials),
                o.load(
                    e,
                    function (a) {
                        try {
                            t(s.parse(JSON.parse(a)));
                        } catch (l) {
                            i ? i(l) : console.error(l), s.manager.itemError(e);
                        }
                    },
                    n,
                    i
                );
        }
        parse(e) {
            let t = this.textures;
            function n(s) {
                return (
                    t[s] === void 0 &&
                        console.warn(
                            "THREE.MaterialLoader: Undefined texture",
                            s
                        ),
                    t[s]
                );
            }
            let i = new Ty[e.type]();
            if (
                (e.uuid !== void 0 && (i.uuid = e.uuid),
                e.name !== void 0 && (i.name = e.name),
                e.color !== void 0 &&
                    i.color !== void 0 &&
                    i.color.setHex(e.color),
                e.roughness !== void 0 && (i.roughness = e.roughness),
                e.metalness !== void 0 && (i.metalness = e.metalness),
                e.sheen !== void 0 && (i.sheen = e.sheen),
                e.sheenColor !== void 0 &&
                    (i.sheenColor = new re().setHex(e.sheenColor)),
                e.sheenRoughness !== void 0 &&
                    (i.sheenRoughness = e.sheenRoughness),
                e.emissive !== void 0 &&
                    i.emissive !== void 0 &&
                    i.emissive.setHex(e.emissive),
                e.specular !== void 0 &&
                    i.specular !== void 0 &&
                    i.specular.setHex(e.specular),
                e.specularIntensity !== void 0 &&
                    (i.specularIntensity = e.specularIntensity),
                e.specularColor !== void 0 &&
                    i.specularColor !== void 0 &&
                    i.specularColor.setHex(e.specularColor),
                e.shininess !== void 0 && (i.shininess = e.shininess),
                e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
                e.clearcoatRoughness !== void 0 &&
                    (i.clearcoatRoughness = e.clearcoatRoughness),
                e.transmission !== void 0 && (i.transmission = e.transmission),
                e.thickness !== void 0 && (i.thickness = e.thickness),
                e.attenuationDistance !== void 0 &&
                    (i.attenuationDistance = e.attenuationDistance),
                e.attenuationColor !== void 0 &&
                    i.attenuationColor !== void 0 &&
                    i.attenuationColor.setHex(e.attenuationColor),
                e.fog !== void 0 && (i.fog = e.fog),
                e.flatShading !== void 0 && (i.flatShading = e.flatShading),
                e.blending !== void 0 && (i.blending = e.blending),
                e.combine !== void 0 && (i.combine = e.combine),
                e.side !== void 0 && (i.side = e.side),
                e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
                e.opacity !== void 0 && (i.opacity = e.opacity),
                e.format !== void 0 && (i.format = e.format),
                e.transparent !== void 0 && (i.transparent = e.transparent),
                e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
                e.depthTest !== void 0 && (i.depthTest = e.depthTest),
                e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
                e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
                e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
                e.stencilWriteMask !== void 0 &&
                    (i.stencilWriteMask = e.stencilWriteMask),
                e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
                e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
                e.stencilFuncMask !== void 0 &&
                    (i.stencilFuncMask = e.stencilFuncMask),
                e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
                e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
                e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
                e.wireframe !== void 0 && (i.wireframe = e.wireframe),
                e.wireframeLinewidth !== void 0 &&
                    (i.wireframeLinewidth = e.wireframeLinewidth),
                e.wireframeLinecap !== void 0 &&
                    (i.wireframeLinecap = e.wireframeLinecap),
                e.wireframeLinejoin !== void 0 &&
                    (i.wireframeLinejoin = e.wireframeLinejoin),
                e.rotation !== void 0 && (i.rotation = e.rotation),
                e.linewidth !== 1 && (i.linewidth = e.linewidth),
                e.dashSize !== void 0 && (i.dashSize = e.dashSize),
                e.gapSize !== void 0 && (i.gapSize = e.gapSize),
                e.scale !== void 0 && (i.scale = e.scale),
                e.polygonOffset !== void 0 &&
                    (i.polygonOffset = e.polygonOffset),
                e.polygonOffsetFactor !== void 0 &&
                    (i.polygonOffsetFactor = e.polygonOffsetFactor),
                e.polygonOffsetUnits !== void 0 &&
                    (i.polygonOffsetUnits = e.polygonOffsetUnits),
                e.dithering !== void 0 && (i.dithering = e.dithering),
                e.alphaToCoverage !== void 0 &&
                    (i.alphaToCoverage = e.alphaToCoverage),
                e.premultipliedAlpha !== void 0 &&
                    (i.premultipliedAlpha = e.premultipliedAlpha),
                e.visible !== void 0 && (i.visible = e.visible),
                e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
                e.userData !== void 0 && (i.userData = e.userData),
                e.vertexColors !== void 0 &&
                    (typeof e.vertexColors == "number"
                        ? (i.vertexColors = e.vertexColors > 0)
                        : (i.vertexColors = e.vertexColors)),
                e.uniforms !== void 0)
            )
                for (let s in e.uniforms) {
                    let o = e.uniforms[s];
                    switch (((i.uniforms[s] = {}), o.type)) {
                        case "t":
                            i.uniforms[s].value = n(o.value);
                            break;
                        case "c":
                            i.uniforms[s].value = new re().setHex(o.value);
                            break;
                        case "v2":
                            i.uniforms[s].value = new W().fromArray(o.value);
                            break;
                        case "v3":
                            i.uniforms[s].value = new M().fromArray(o.value);
                            break;
                        case "v4":
                            i.uniforms[s].value = new Ve().fromArray(o.value);
                            break;
                        case "m3":
                            i.uniforms[s].value = new rt().fromArray(o.value);
                            break;
                        case "m4":
                            i.uniforms[s].value = new me().fromArray(o.value);
                            break;
                        default:
                            i.uniforms[s].value = o.value;
                    }
                }
            if (
                (e.defines !== void 0 && (i.defines = e.defines),
                e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
                e.fragmentShader !== void 0 &&
                    (i.fragmentShader = e.fragmentShader),
                e.extensions !== void 0)
            )
                for (let s in e.extensions) i.extensions[s] = e.extensions[s];
            if (
                (e.shading !== void 0 && (i.flatShading = e.shading === 1),
                e.size !== void 0 && (i.size = e.size),
                e.sizeAttenuation !== void 0 &&
                    (i.sizeAttenuation = e.sizeAttenuation),
                e.map !== void 0 && (i.map = n(e.map)),
                e.matcap !== void 0 && (i.matcap = n(e.matcap)),
                e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
                e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
                e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
                e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
                e.normalMapType !== void 0 &&
                    (i.normalMapType = e.normalMapType),
                e.normalScale !== void 0)
            ) {
                let s = e.normalScale;
                Array.isArray(s) === !1 && (s = [s, s]),
                    (i.normalScale = new W().fromArray(s));
            }
            return (
                e.displacementMap !== void 0 &&
                    (i.displacementMap = n(e.displacementMap)),
                e.displacementScale !== void 0 &&
                    (i.displacementScale = e.displacementScale),
                e.displacementBias !== void 0 &&
                    (i.displacementBias = e.displacementBias),
                e.roughnessMap !== void 0 &&
                    (i.roughnessMap = n(e.roughnessMap)),
                e.metalnessMap !== void 0 &&
                    (i.metalnessMap = n(e.metalnessMap)),
                e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
                e.emissiveIntensity !== void 0 &&
                    (i.emissiveIntensity = e.emissiveIntensity),
                e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
                e.specularIntensityMap !== void 0 &&
                    (i.specularIntensityMap = n(e.specularIntensityMap)),
                e.specularColorMap !== void 0 &&
                    (i.specularColorMap = n(e.specularColorMap)),
                e.envMap !== void 0 && (i.envMap = n(e.envMap)),
                e.envMapIntensity !== void 0 &&
                    (i.envMapIntensity = e.envMapIntensity),
                e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
                e.refractionRatio !== void 0 &&
                    (i.refractionRatio = e.refractionRatio),
                e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
                e.lightMapIntensity !== void 0 &&
                    (i.lightMapIntensity = e.lightMapIntensity),
                e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
                e.aoMapIntensity !== void 0 &&
                    (i.aoMapIntensity = e.aoMapIntensity),
                e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
                e.clearcoatMap !== void 0 &&
                    (i.clearcoatMap = n(e.clearcoatMap)),
                e.clearcoatRoughnessMap !== void 0 &&
                    (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
                e.clearcoatNormalMap !== void 0 &&
                    (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
                e.clearcoatNormalScale !== void 0 &&
                    (i.clearcoatNormalScale = new W().fromArray(
                        e.clearcoatNormalScale
                    )),
                e.transmissionMap !== void 0 &&
                    (i.transmissionMap = n(e.transmissionMap)),
                e.thicknessMap !== void 0 &&
                    (i.thicknessMap = n(e.thicknessMap)),
                e.sheenColorMap !== void 0 &&
                    (i.sheenColorMap = n(e.sheenColorMap)),
                e.sheenRoughnessMap !== void 0 &&
                    (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
                i
            );
        }
        setTextures(e) {
            return (this.textures = e), this;
        }
    },
    $s = class {
        static decodeText(e) {
            if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
            let t = "";
            for (let n = 0, i = e.length; n < i; n++)
                t += String.fromCharCode(e[n]);
            try {
                return decodeURIComponent(escape(t));
            } catch {
                return t;
            }
        }
        static extractUrlBase(e) {
            let t = e.lastIndexOf("/");
            return t === -1 ? "./" : e.substr(0, t + 1);
        }
        static resolveURL(e, t) {
            return typeof e != "string" || e === ""
                ? ""
                : (/^https?:\/\//i.test(t) &&
                      /^\//.test(e) &&
                      (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                  /^(https?:)?\/\//i.test(e) ||
                  /^data:.*,.*$/i.test(e) ||
                  /^blob:.*$/i.test(e)
                      ? e
                      : t + e);
        }
    },
    ko = class extends _e {
        constructor() {
            super(),
                (this.type = "InstancedBufferGeometry"),
                (this.instanceCount = 1 / 0);
        }
        copy(e) {
            return super.copy(e), (this.instanceCount = e.instanceCount), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        toJSON() {
            let e = super.toJSON(this);
            return (
                (e.instanceCount = this.instanceCount),
                (e.isInstancedBufferGeometry = !0),
                e
            );
        }
    };
ko.prototype.isInstancedBufferGeometry = !0;
var dl = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = this,
                o = new Ht(s.manager);
            o.setPath(s.path),
                o.setRequestHeader(s.requestHeader),
                o.setWithCredentials(s.withCredentials),
                o.load(
                    e,
                    function (a) {
                        try {
                            t(s.parse(JSON.parse(a)));
                        } catch (l) {
                            i ? i(l) : console.error(l), s.manager.itemError(e);
                        }
                    },
                    n,
                    i
                );
        }
        parse(e) {
            let t = {},
                n = {};
            function i(f, m) {
                if (t[m] !== void 0) return t[m];
                let v = f.interleavedBuffers[m],
                    g = s(f, v.buffer),
                    p = Ti(v.type, g),
                    _ = new An(p, v.stride);
                return (_.uuid = v.uuid), (t[m] = _), _;
            }
            function s(f, m) {
                if (n[m] !== void 0) return n[m];
                let v = f.arrayBuffers[m],
                    g = new Uint32Array(v).buffer;
                return (n[m] = g), g;
            }
            let o = e.isInstancedBufferGeometry ? new ko() : new _e(),
                a = e.data.index;
            if (a !== void 0) {
                let f = Ti(a.type, a.array);
                o.setIndex(new ze(f, 1));
            }
            let l = e.data.attributes;
            for (let f in l) {
                let m = l[f],
                    x;
                if (m.isInterleavedBufferAttribute) {
                    let v = i(e.data, m.data);
                    x = new Kn(v, m.itemSize, m.offset, m.normalized);
                } else {
                    let v = Ti(m.type, m.array),
                        g = m.isInstancedBufferAttribute ? Rn : ze;
                    x = new g(v, m.itemSize, m.normalized);
                }
                m.name !== void 0 && (x.name = m.name),
                    m.usage !== void 0 && x.setUsage(m.usage),
                    m.updateRange !== void 0 &&
                        ((x.updateRange.offset = m.updateRange.offset),
                        (x.updateRange.count = m.updateRange.count)),
                    o.setAttribute(f, x);
            }
            let c = e.data.morphAttributes;
            if (c)
                for (let f in c) {
                    let m = c[f],
                        x = [];
                    for (let v = 0, g = m.length; v < g; v++) {
                        let p = m[v],
                            _;
                        if (p.isInterleavedBufferAttribute) {
                            let y = i(e.data, p.data);
                            _ = new Kn(y, p.itemSize, p.offset, p.normalized);
                        } else {
                            let y = Ti(p.type, p.array);
                            _ = new ze(y, p.itemSize, p.normalized);
                        }
                        p.name !== void 0 && (_.name = p.name), x.push(_);
                    }
                    o.morphAttributes[f] = x;
                }
            e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
            let u = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (u !== void 0)
                for (let f = 0, m = u.length; f !== m; ++f) {
                    let x = u[f];
                    o.addGroup(x.start, x.count, x.materialIndex);
                }
            let d = e.data.boundingSphere;
            if (d !== void 0) {
                let f = new M();
                d.center !== void 0 && f.fromArray(d.center),
                    (o.boundingSphere = new hn(f, d.radius));
            }
            return (
                e.name && (o.name = e.name),
                e.userData && (o.userData = e.userData),
                o
            );
        }
    },
    xh = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = this,
                o = this.path === "" ? $s.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || o;
            let a = new Ht(this.manager);
            a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(
                    e,
                    function (l) {
                        let c = null;
                        try {
                            c = JSON.parse(l);
                        } catch (u) {
                            i !== void 0 && i(u),
                                console.error(
                                    "THREE:ObjectLoader: Can't parse " +
                                        e +
                                        ".",
                                    u.message
                                );
                            return;
                        }
                        let h = c.metadata;
                        if (
                            h === void 0 ||
                            h.type === void 0 ||
                            h.type.toLowerCase() === "geometry"
                        ) {
                            console.error(
                                "THREE.ObjectLoader: Can't load " + e
                            );
                            return;
                        }
                        s.parse(c, t);
                    },
                    n,
                    i
                );
        }
        async loadAsync(e, t) {
            let n = this,
                i = this.path === "" ? $s.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || i;
            let s = new Ht(this.manager);
            s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials);
            let o = await s.loadAsync(e, t),
                a = JSON.parse(o),
                l = a.metadata;
            if (
                l === void 0 ||
                l.type === void 0 ||
                l.type.toLowerCase() === "geometry"
            )
                throw new Error("THREE.ObjectLoader: Can't load " + e);
            return await n.parseAsync(a);
        }
        parse(e, t) {
            let n = this.parseAnimations(e.animations),
                i = this.parseShapes(e.shapes),
                s = this.parseGeometries(e.geometries, i),
                o = this.parseImages(e.images, function () {
                    t !== void 0 && t(c);
                }),
                a = this.parseTextures(e.textures, o),
                l = this.parseMaterials(e.materials, a),
                c = this.parseObject(e.object, s, l, a, n),
                h = this.parseSkeletons(e.skeletons, c);
            if ((this.bindSkeletons(c, h), t !== void 0)) {
                let u = !1;
                for (let d in o)
                    if (o[d] instanceof HTMLImageElement) {
                        u = !0;
                        break;
                    }
                u === !1 && t(c);
            }
            return c;
        }
        async parseAsync(e) {
            let t = this.parseAnimations(e.animations),
                n = this.parseShapes(e.shapes),
                i = this.parseGeometries(e.geometries, n),
                s = await this.parseImagesAsync(e.images),
                o = this.parseTextures(e.textures, s),
                a = this.parseMaterials(e.materials, o),
                l = this.parseObject(e.object, i, a, o, t),
                c = this.parseSkeletons(e.skeletons, l);
            return this.bindSkeletons(l, c), l;
        }
        parseShapes(e) {
            let t = {};
            if (e !== void 0)
                for (let n = 0, i = e.length; n < i; n++) {
                    let s = new Ut().fromJSON(e[n]);
                    t[s.uuid] = s;
                }
            return t;
        }
        parseSkeletons(e, t) {
            let n = {},
                i = {};
            if (
                (t.traverse(function (s) {
                    s.isBone && (i[s.uuid] = s);
                }),
                e !== void 0)
            )
                for (let s = 0, o = e.length; s < o; s++) {
                    let a = new $a().fromJSON(e[s], i);
                    n[a.uuid] = a;
                }
            return n;
        }
        parseGeometries(e, t) {
            let n = {};
            if (e !== void 0) {
                let i = new dl();
                for (let s = 0, o = e.length; s < o; s++) {
                    let a,
                        l = e[s];
                    switch (l.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            a = i.parse(l);
                            break;
                        case "Geometry":
                            console.error(
                                "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
                            );
                            break;
                        default:
                            l.type in hh
                                ? (a = hh[l.type].fromJSON(l, t))
                                : console.warn(
                                      `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                                  );
                    }
                    (a.uuid = l.uuid),
                        l.name !== void 0 && (a.name = l.name),
                        a.isBufferGeometry === !0 &&
                            l.userData !== void 0 &&
                            (a.userData = l.userData),
                        (n[l.uuid] = a);
                }
            }
            return n;
        }
        parseMaterials(e, t) {
            let n = {},
                i = {};
            if (e !== void 0) {
                let s = new ul();
                s.setTextures(t);
                for (let o = 0, a = e.length; o < a; o++) {
                    let l = e[o];
                    if (l.type === "MultiMaterial") {
                        let c = [];
                        for (let h = 0; h < l.materials.length; h++) {
                            let u = l.materials[h];
                            n[u.uuid] === void 0 && (n[u.uuid] = s.parse(u)),
                                c.push(n[u.uuid]);
                        }
                        i[l.uuid] = c;
                    } else
                        n[l.uuid] === void 0 && (n[l.uuid] = s.parse(l)),
                            (i[l.uuid] = n[l.uuid]);
                }
            }
            return i;
        }
        parseAnimations(e) {
            let t = {};
            if (e !== void 0)
                for (let n = 0; n < e.length; n++) {
                    let i = e[n],
                        s = Wi.parse(i);
                    t[s.uuid] = s;
                }
            return t;
        }
        parseImages(e, t) {
            let n = this,
                i = {},
                s;
            function o(l) {
                return (
                    n.manager.itemStart(l),
                    s.load(
                        l,
                        function () {
                            n.manager.itemEnd(l);
                        },
                        void 0,
                        function () {
                            n.manager.itemError(l), n.manager.itemEnd(l);
                        }
                    )
                );
            }
            function a(l) {
                if (typeof l == "string") {
                    let c = l,
                        h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)
                            ? c
                            : n.resourcePath + c;
                    return o(h);
                } else
                    return l.data
                        ? {
                              data: Ti(l.type, l.data),
                              width: l.width,
                              height: l.height,
                          }
                        : null;
            }
            if (e !== void 0 && e.length > 0) {
                let l = new Lo(t);
                (s = new Xi(l)), s.setCrossOrigin(this.crossOrigin);
                for (let c = 0, h = e.length; c < h; c++) {
                    let u = e[c],
                        d = u.url;
                    if (Array.isArray(d)) {
                        i[u.uuid] = [];
                        for (let f = 0, m = d.length; f < m; f++) {
                            let x = d[f],
                                v = a(x);
                            v !== null &&
                                (v instanceof HTMLImageElement
                                    ? i[u.uuid].push(v)
                                    : i[u.uuid].push(
                                          new Tn(v.data, v.width, v.height)
                                      ));
                        }
                    } else {
                        let f = a(u.url);
                        f !== null && (i[u.uuid] = f);
                    }
                }
            }
            return i;
        }
        async parseImagesAsync(e) {
            let t = this,
                n = {},
                i;
            async function s(o) {
                if (typeof o == "string") {
                    let a = o,
                        l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)
                            ? a
                            : t.resourcePath + a;
                    return await i.loadAsync(l);
                } else
                    return o.data
                        ? {
                              data: Ti(o.type, o.data),
                              width: o.width,
                              height: o.height,
                          }
                        : null;
            }
            if (e !== void 0 && e.length > 0) {
                (i = new Xi(this.manager)), i.setCrossOrigin(this.crossOrigin);
                for (let o = 0, a = e.length; o < a; o++) {
                    let l = e[o],
                        c = l.url;
                    if (Array.isArray(c)) {
                        n[l.uuid] = [];
                        for (let h = 0, u = c.length; h < u; h++) {
                            let d = c[h],
                                f = await s(d);
                            f !== null &&
                                (f instanceof HTMLImageElement
                                    ? n[l.uuid].push(f)
                                    : n[l.uuid].push(
                                          new Tn(f.data, f.width, f.height)
                                      ));
                        }
                    } else {
                        let h = await s(l.url);
                        h !== null && (n[l.uuid] = h);
                    }
                }
            }
            return n;
        }
        parseTextures(e, t) {
            function n(s, o) {
                return typeof s == "number"
                    ? s
                    : (console.warn(
                          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                          s
                      ),
                      o[s]);
            }
            let i = {};
            if (e !== void 0)
                for (let s = 0, o = e.length; s < o; s++) {
                    let a = e[s];
                    a.image === void 0 &&
                        console.warn(
                            'THREE.ObjectLoader: No "image" specified for',
                            a.uuid
                        ),
                        t[a.image] === void 0 &&
                            console.warn(
                                "THREE.ObjectLoader: Undefined image",
                                a.image
                            );
                    let l,
                        c = t[a.image];
                    Array.isArray(c)
                        ? ((l = new jn(c)),
                          c.length === 6 && (l.needsUpdate = !0))
                        : (c && c.data
                              ? (l = new Tn(c.data, c.width, c.height))
                              : (l = new ft(c)),
                          c && (l.needsUpdate = !0)),
                        (l.uuid = a.uuid),
                        a.name !== void 0 && (l.name = a.name),
                        a.mapping !== void 0 && (l.mapping = n(a.mapping, Cy)),
                        a.offset !== void 0 && l.offset.fromArray(a.offset),
                        a.repeat !== void 0 && l.repeat.fromArray(a.repeat),
                        a.center !== void 0 && l.center.fromArray(a.center),
                        a.rotation !== void 0 && (l.rotation = a.rotation),
                        a.wrap !== void 0 &&
                            ((l.wrapS = n(a.wrap[0], yh)),
                            (l.wrapT = n(a.wrap[1], yh))),
                        a.format !== void 0 && (l.format = a.format),
                        a.type !== void 0 && (l.type = a.type),
                        a.encoding !== void 0 && (l.encoding = a.encoding),
                        a.minFilter !== void 0 &&
                            (l.minFilter = n(a.minFilter, vh)),
                        a.magFilter !== void 0 &&
                            (l.magFilter = n(a.magFilter, vh)),
                        a.anisotropy !== void 0 &&
                            (l.anisotropy = a.anisotropy),
                        a.flipY !== void 0 && (l.flipY = a.flipY),
                        a.premultiplyAlpha !== void 0 &&
                            (l.premultiplyAlpha = a.premultiplyAlpha),
                        a.unpackAlignment !== void 0 &&
                            (l.unpackAlignment = a.unpackAlignment),
                        a.userData !== void 0 && (l.userData = a.userData),
                        (i[a.uuid] = l);
                }
            return i;
        }
        parseObject(e, t, n, i, s) {
            let o;
            function a(d) {
                return (
                    t[d] === void 0 &&
                        console.warn(
                            "THREE.ObjectLoader: Undefined geometry",
                            d
                        ),
                    t[d]
                );
            }
            function l(d) {
                if (d !== void 0) {
                    if (Array.isArray(d)) {
                        let f = [];
                        for (let m = 0, x = d.length; m < x; m++) {
                            let v = d[m];
                            n[v] === void 0 &&
                                console.warn(
                                    "THREE.ObjectLoader: Undefined material",
                                    v
                                ),
                                f.push(n[v]);
                        }
                        return f;
                    }
                    return (
                        n[d] === void 0 &&
                            console.warn(
                                "THREE.ObjectLoader: Undefined material",
                                d
                            ),
                        n[d]
                    );
                }
            }
            function c(d) {
                return (
                    i[d] === void 0 &&
                        console.warn(
                            "THREE.ObjectLoader: Undefined texture",
                            d
                        ),
                    i[d]
                );
            }
            let h, u;
            switch (e.type) {
                case "Scene":
                    (o = new Ds()),
                        e.background !== void 0 &&
                            (Number.isInteger(e.background)
                                ? (o.background = new re(e.background))
                                : (o.background = c(e.background))),
                        e.environment !== void 0 &&
                            (o.environment = c(e.environment)),
                        e.fog !== void 0 &&
                            (e.fog.type === "Fog"
                                ? (o.fog = new eo(
                                      e.fog.color,
                                      e.fog.near,
                                      e.fog.far
                                  ))
                                : e.fog.type === "FogExp2" &&
                                  (o.fog = new Kr(e.fog.color, e.fog.density)));
                    break;
                case "PerspectiveCamera":
                    (o = new at(e.fov, e.aspect, e.near, e.far)),
                        e.focus !== void 0 && (o.focus = e.focus),
                        e.zoom !== void 0 && (o.zoom = e.zoom),
                        e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
                        e.filmOffset !== void 0 &&
                            (o.filmOffset = e.filmOffset),
                        e.view !== void 0 &&
                            (o.view = Object.assign({}, e.view));
                    break;
                case "OrthographicCamera":
                    (o = new zi(
                        e.left,
                        e.right,
                        e.top,
                        e.bottom,
                        e.near,
                        e.far
                    )),
                        e.zoom !== void 0 && (o.zoom = e.zoom),
                        e.view !== void 0 &&
                            (o.view = Object.assign({}, e.view));
                    break;
                case "AmbientLight":
                    o = new Uo(e.color, e.intensity);
                    break;
                case "DirectionalLight":
                    o = new Bo(e.color, e.intensity);
                    break;
                case "PointLight":
                    o = new No(e.color, e.intensity, e.distance, e.decay);
                    break;
                case "RectAreaLight":
                    o = new Oo(e.color, e.intensity, e.width, e.height);
                    break;
                case "SpotLight":
                    o = new Do(
                        e.color,
                        e.intensity,
                        e.distance,
                        e.angle,
                        e.penumbra,
                        e.decay
                    );
                    break;
                case "HemisphereLight":
                    o = new Po(e.color, e.groundColor, e.intensity);
                    break;
                case "LightProbe":
                    o = new Ji().fromJSON(e);
                    break;
                case "SkinnedMesh":
                    (h = a(e.geometry)),
                        (u = l(e.material)),
                        (o = new zs(h, u)),
                        e.bindMode !== void 0 && (o.bindMode = e.bindMode),
                        e.bindMatrix !== void 0 &&
                            o.bindMatrix.fromArray(e.bindMatrix),
                        e.skeleton !== void 0 && (o.skeleton = e.skeleton);
                    break;
                case "Mesh":
                    (h = a(e.geometry)),
                        (u = l(e.material)),
                        (o = new nt(h, u));
                    break;
                case "InstancedMesh":
                    (h = a(e.geometry)), (u = l(e.material));
                    let d = e.count,
                        f = e.instanceMatrix,
                        m = e.instanceColor;
                    (o = new to(h, u, d)),
                        (o.instanceMatrix = new Rn(
                            new Float32Array(f.array),
                            16
                        )),
                        m !== void 0 &&
                            (o.instanceColor = new Rn(
                                new Float32Array(m.array),
                                m.itemSize
                            ));
                    break;
                case "LOD":
                    o = new Za();
                    break;
                case "Line":
                    o = new $t(a(e.geometry), l(e.material));
                    break;
                case "LineLoop":
                    o = new no(a(e.geometry), l(e.material));
                    break;
                case "LineSegments":
                    o = new bt(a(e.geometry), l(e.material));
                    break;
                case "PointCloud":
                case "Points":
                    o = new Bi(a(e.geometry), l(e.material));
                    break;
                case "Sprite":
                    o = new Ns(l(e.material));
                    break;
                case "Group":
                    o = new _n();
                    break;
                case "Bone":
                    o = new Bs();
                    break;
                default:
                    o = new Be();
            }
            if (
                ((o.uuid = e.uuid),
                e.name !== void 0 && (o.name = e.name),
                e.matrix !== void 0
                    ? (o.matrix.fromArray(e.matrix),
                      e.matrixAutoUpdate !== void 0 &&
                          (o.matrixAutoUpdate = e.matrixAutoUpdate),
                      o.matrixAutoUpdate &&
                          o.matrix.decompose(o.position, o.quaternion, o.scale))
                    : (e.position !== void 0 &&
                          o.position.fromArray(e.position),
                      e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
                      e.quaternion !== void 0 &&
                          o.quaternion.fromArray(e.quaternion),
                      e.scale !== void 0 && o.scale.fromArray(e.scale)),
                e.castShadow !== void 0 && (o.castShadow = e.castShadow),
                e.receiveShadow !== void 0 &&
                    (o.receiveShadow = e.receiveShadow),
                e.shadow &&
                    (e.shadow.bias !== void 0 &&
                        (o.shadow.bias = e.shadow.bias),
                    e.shadow.normalBias !== void 0 &&
                        (o.shadow.normalBias = e.shadow.normalBias),
                    e.shadow.radius !== void 0 &&
                        (o.shadow.radius = e.shadow.radius),
                    e.shadow.mapSize !== void 0 &&
                        o.shadow.mapSize.fromArray(e.shadow.mapSize),
                    e.shadow.camera !== void 0 &&
                        (o.shadow.camera = this.parseObject(e.shadow.camera))),
                e.visible !== void 0 && (o.visible = e.visible),
                e.frustumCulled !== void 0 &&
                    (o.frustumCulled = e.frustumCulled),
                e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
                e.userData !== void 0 && (o.userData = e.userData),
                e.layers !== void 0 && (o.layers.mask = e.layers),
                e.children !== void 0)
            ) {
                let d = e.children;
                for (let f = 0; f < d.length; f++)
                    o.add(this.parseObject(d[f], t, n, i, s));
            }
            if (e.animations !== void 0) {
                let d = e.animations;
                for (let f = 0; f < d.length; f++) {
                    let m = d[f];
                    o.animations.push(s[m]);
                }
            }
            if (e.type === "LOD") {
                e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
                let d = e.levels;
                for (let f = 0; f < d.length; f++) {
                    let m = d[f],
                        x = o.getObjectByProperty("uuid", m.object);
                    x !== void 0 && o.addLevel(x, m.distance);
                }
            }
            return o;
        }
        bindSkeletons(e, t) {
            Object.keys(t).length !== 0 &&
                e.traverse(function (n) {
                    if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                        let i = t[n.skeleton];
                        i === void 0
                            ? console.warn(
                                  "THREE.ObjectLoader: No skeleton found with UUID:",
                                  n.skeleton
                              )
                            : n.bind(i, n.bindMatrix);
                    }
                });
        }
        setTexturePath(e) {
            return (
                console.warn(
                    "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
                ),
                this.setResourcePath(e)
            );
        }
    },
    Cy = {
        UVMapping: Fl,
        CubeReflectionMapping: Yi,
        CubeRefractionMapping: Zi,
        EquirectangularReflectionMapping: Gr,
        EquirectangularRefractionMapping: Wr,
        CubeUVReflectionMapping: js,
        CubeUVRefractionMapping: Wo,
    },
    yh = {
        RepeatWrapping: qr,
        ClampToEdgeWrapping: yt,
        MirroredRepeatWrapping: Xr,
    },
    vh = {
        NearestFilter: st,
        NearestMipmapNearestFilter: Ia,
        NearestMipmapLinearFilter: Da,
        LinearFilter: tt,
        LinearMipmapNearestFilter: tu,
        LinearMipmapLinearFilter: $i,
    },
    fl = class extends Mt {
        constructor(e) {
            super(e),
                typeof createImageBitmap > "u" &&
                    console.warn(
                        "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                    ),
                typeof fetch > "u" &&
                    console.warn(
                        "THREE.ImageBitmapLoader: fetch() not supported."
                    ),
                (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
            return (this.options = e), this;
        }
        load(e, t, n, i) {
            e === void 0 && (e = ""),
                this.path !== void 0 && (e = this.path + e),
                (e = this.manager.resolveURL(e));
            let s = this,
                o = qi.get(e);
            if (o !== void 0)
                return (
                    s.manager.itemStart(e),
                    setTimeout(function () {
                        t && t(o), s.manager.itemEnd(e);
                    }, 0),
                    o
                );
            let a = {};
            (a.credentials =
                this.crossOrigin === "anonymous" ? "same-origin" : "include"),
                (a.headers = this.requestHeader),
                fetch(e, a)
                    .then(function (l) {
                        return l.blob();
                    })
                    .then(function (l) {
                        return createImageBitmap(
                            l,
                            Object.assign(s.options, {
                                colorSpaceConversion: "none",
                            })
                        );
                    })
                    .then(function (l) {
                        qi.add(e, l), t && t(l), s.manager.itemEnd(e);
                    })
                    .catch(function (l) {
                        i && i(l), s.manager.itemError(e), s.manager.itemEnd(e);
                    }),
                s.manager.itemStart(e);
        }
    };
fl.prototype.isImageBitmapLoader = !0;
var Nr,
    bu = {
        getContext: function () {
            return (
                Nr === void 0 &&
                    (Nr = new (window.AudioContext ||
                        window.webkitAudioContext)()),
                Nr
            );
        },
        setContext: function (r) {
            Nr = r;
        },
    },
    pl = class extends Mt {
        constructor(e) {
            super(e);
        }
        load(e, t, n, i) {
            let s = this,
                o = new Ht(this.manager);
            o.setResponseType("arraybuffer"),
                o.setPath(this.path),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(this.withCredentials),
                o.load(
                    e,
                    function (a) {
                        try {
                            let l = a.slice(0);
                            bu.getContext().decodeAudioData(l, function (h) {
                                t(h);
                            });
                        } catch (l) {
                            i ? i(l) : console.error(l), s.manager.itemError(e);
                        }
                    },
                    n,
                    i
                );
        }
    },
    ml = class extends Ji {
        constructor(e, t, n = 1) {
            super(void 0, n);
            let i = new re().set(e),
                s = new re().set(t),
                o = new M(i.r, i.g, i.b),
                a = new M(s.r, s.g, s.b),
                l = Math.sqrt(Math.PI),
                c = l * Math.sqrt(0.75);
            this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
                this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
        }
    };
ml.prototype.isHemisphereLightProbe = !0;
var gl = class extends Ji {
    constructor(e, t = 1) {
        super(void 0, t);
        let n = new re().set(e);
        this.sh.coefficients[0]
            .set(n.r, n.g, n.b)
            .multiplyScalar(2 * Math.sqrt(Math.PI));
    }
};
gl.prototype.isAmbientLightProbe = !0;
var _h = new me(),
    Mh = new me(),
    Hn = new me(),
    wh = class {
        constructor() {
            (this.type = "StereoCamera"),
                (this.aspect = 1),
                (this.eyeSep = 0.064),
                (this.cameraL = new at()),
                this.cameraL.layers.enable(1),
                (this.cameraL.matrixAutoUpdate = !1),
                (this.cameraR = new at()),
                this.cameraR.layers.enable(2),
                (this.cameraR.matrixAutoUpdate = !1),
                (this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null,
                });
        }
        update(e) {
            let t = this._cache;
            if (
                t.focus !== e.focus ||
                t.fov !== e.fov ||
                t.aspect !== e.aspect * this.aspect ||
                t.near !== e.near ||
                t.far !== e.far ||
                t.zoom !== e.zoom ||
                t.eyeSep !== this.eyeSep
            ) {
                (t.focus = e.focus),
                    (t.fov = e.fov),
                    (t.aspect = e.aspect * this.aspect),
                    (t.near = e.near),
                    (t.far = e.far),
                    (t.zoom = e.zoom),
                    (t.eyeSep = this.eyeSep),
                    Hn.copy(e.projectionMatrix);
                let i = t.eyeSep / 2,
                    s = (i * t.near) / t.focus,
                    o = (t.near * Math.tan(Zn * t.fov * 0.5)) / t.zoom,
                    a,
                    l;
                (Mh.elements[12] = -i),
                    (_h.elements[12] = i),
                    (a = -o * t.aspect + s),
                    (l = o * t.aspect + s),
                    (Hn.elements[0] = (2 * t.near) / (l - a)),
                    (Hn.elements[8] = (l + a) / (l - a)),
                    this.cameraL.projectionMatrix.copy(Hn),
                    (a = -o * t.aspect - s),
                    (l = o * t.aspect - s),
                    (Hn.elements[0] = (2 * t.near) / (l - a)),
                    (Hn.elements[8] = (l + a) / (l - a)),
                    this.cameraR.projectionMatrix.copy(Hn);
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Mh),
                this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_h);
        }
    },
    xl = class {
        constructor(e = !0) {
            (this.autoStart = e),
                (this.startTime = 0),
                (this.oldTime = 0),
                (this.elapsedTime = 0),
                (this.running = !1);
        }
        start() {
            (this.startTime = bh()),
                (this.oldTime = this.startTime),
                (this.elapsedTime = 0),
                (this.running = !0);
        }
        stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
            let e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                let t = bh();
                (e = (t - this.oldTime) / 1e3),
                    (this.oldTime = t),
                    (this.elapsedTime += e);
            }
            return e;
        }
    };
function bh() {
    return (typeof performance > "u" ? Date : performance).now();
}
var kn = new M(),
    Sh = new dt(),
    Ly = new M(),
    Vn = new M(),
    Th = class extends Be {
        constructor() {
            super(),
                (this.type = "AudioListener"),
                (this.context = bu.getContext()),
                (this.gain = this.context.createGain()),
                this.gain.connect(this.context.destination),
                (this.filter = null),
                (this.timeDelta = 0),
                (this._clock = new xl());
        }
        getInput() {
            return this.gain;
        }
        removeFilter() {
            return (
                this.filter !== null &&
                    (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination),
                    this.gain.connect(this.context.destination),
                    (this.filter = null)),
                this
            );
        }
        getFilter() {
            return this.filter;
        }
        setFilter(e) {
            return (
                this.filter !== null
                    ? (this.gain.disconnect(this.filter),
                      this.filter.disconnect(this.context.destination))
                    : this.gain.disconnect(this.context.destination),
                (this.filter = e),
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
            );
        }
        getMasterVolume() {
            return this.gain.gain.value;
        }
        setMasterVolume(e) {
            return (
                this.gain.gain.setTargetAtTime(
                    e,
                    this.context.currentTime,
                    0.01
                ),
                this
            );
        }
        updateMatrixWorld(e) {
            super.updateMatrixWorld(e);
            let t = this.context.listener,
                n = this.up;
            if (
                ((this.timeDelta = this._clock.getDelta()),
                this.matrixWorld.decompose(kn, Sh, Ly),
                Vn.set(0, 0, -1).applyQuaternion(Sh),
                t.positionX)
            ) {
                let i = this.context.currentTime + this.timeDelta;
                t.positionX.linearRampToValueAtTime(kn.x, i),
                    t.positionY.linearRampToValueAtTime(kn.y, i),
                    t.positionZ.linearRampToValueAtTime(kn.z, i),
                    t.forwardX.linearRampToValueAtTime(Vn.x, i),
                    t.forwardY.linearRampToValueAtTime(Vn.y, i),
                    t.forwardZ.linearRampToValueAtTime(Vn.z, i),
                    t.upX.linearRampToValueAtTime(n.x, i),
                    t.upY.linearRampToValueAtTime(n.y, i),
                    t.upZ.linearRampToValueAtTime(n.z, i);
            } else
                t.setPosition(kn.x, kn.y, kn.z),
                    t.setOrientation(Vn.x, Vn.y, Vn.z, n.x, n.y, n.z);
        }
    },
    Vo = class extends Be {
        constructor(e) {
            super(),
                (this.type = "Audio"),
                (this.listener = e),
                (this.context = e.context),
                (this.gain = this.context.createGain()),
                this.gain.connect(e.getInput()),
                (this.autoplay = !1),
                (this.buffer = null),
                (this.detune = 0),
                (this.loop = !1),
                (this.loopStart = 0),
                (this.loopEnd = 0),
                (this.offset = 0),
                (this.duration = void 0),
                (this.playbackRate = 1),
                (this.isPlaying = !1),
                (this.hasPlaybackControl = !0),
                (this.source = null),
                (this.sourceType = "empty"),
                (this._startedAt = 0),
                (this._progress = 0),
                (this._connected = !1),
                (this.filters = []);
        }
        getOutput() {
            return this.gain;
        }
        setNodeSource(e) {
            return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "audioNode"),
                (this.source = e),
                this.connect(),
                this
            );
        }
        setMediaElementSource(e) {
            return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "mediaNode"),
                (this.source = this.context.createMediaElementSource(e)),
                this.connect(),
                this
            );
        }
        setMediaStreamSource(e) {
            return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "mediaStreamNode"),
                (this.source = this.context.createMediaStreamSource(e)),
                this.connect(),
                this
            );
        }
        setBuffer(e) {
            return (
                (this.buffer = e),
                (this.sourceType = "buffer"),
                this.autoplay && this.play(),
                this
            );
        }
        play(e = 0) {
            if (this.isPlaying === !0) {
                console.warn("THREE.Audio: Audio is already playing.");
                return;
            }
            if (this.hasPlaybackControl === !1) {
                console.warn(
                    "THREE.Audio: this Audio has no playback control."
                );
                return;
            }
            this._startedAt = this.context.currentTime + e;
            let t = this.context.createBufferSource();
            return (
                (t.buffer = this.buffer),
                (t.loop = this.loop),
                (t.loopStart = this.loopStart),
                (t.loopEnd = this.loopEnd),
                (t.onended = this.onEnded.bind(this)),
                t.start(
                    this._startedAt,
                    this._progress + this.offset,
                    this.duration
                ),
                (this.isPlaying = !0),
                (this.source = t),
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            );
        }
        pause() {
            if (this.hasPlaybackControl === !1) {
                console.warn(
                    "THREE.Audio: this Audio has no playback control."
                );
                return;
            }
            return (
                this.isPlaying === !0 &&
                    ((this._progress +=
                        Math.max(
                            this.context.currentTime - this._startedAt,
                            0
                        ) * this.playbackRate),
                    this.loop === !0 &&
                        (this._progress =
                            this._progress %
                            (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    (this.source.onended = null),
                    (this.isPlaying = !1)),
                this
            );
        }
        stop() {
            if (this.hasPlaybackControl === !1) {
                console.warn(
                    "THREE.Audio: this Audio has no playback control."
                );
                return;
            }
            return (
                (this._progress = 0),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1),
                this
            );
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return (this._connected = !0), this;
        }
        disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(
                    this.getOutput()
                );
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
        }
        getFilters() {
            return this.filters;
        }
        setFilters(e) {
            return (
                e || (e = []),
                this._connected === !0
                    ? (this.disconnect(),
                      (this.filters = e.slice()),
                      this.connect())
                    : (this.filters = e.slice()),
                this
            );
        }
        setDetune(e) {
            if (((this.detune = e), this.source.detune !== void 0))
                return (
                    this.isPlaying === !0 &&
                        this.source.detune.setTargetAtTime(
                            this.detune,
                            this.context.currentTime,
                            0.01
                        ),
                    this
                );
        }
        getDetune() {
            return this.detune;
        }
        getFilter() {
            return this.getFilters()[0];
        }
        setFilter(e) {
            return this.setFilters(e ? [e] : []);
        }
        setPlaybackRate(e) {
            if (this.hasPlaybackControl === !1) {
                console.warn(
                    "THREE.Audio: this Audio has no playback control."
                );
                return;
            }
            return (
                (this.playbackRate = e),
                this.isPlaying === !0 &&
                    this.source.playbackRate.setTargetAtTime(
                        this.playbackRate,
                        this.context.currentTime,
                        0.01
                    ),
                this
            );
        }
        getPlaybackRate() {
            return this.playbackRate;
        }
        onEnded() {
            this.isPlaying = !1;
        }
        getLoop() {
            return this.hasPlaybackControl === !1
                ? (console.warn(
                      "THREE.Audio: this Audio has no playback control."
                  ),
                  !1)
                : this.loop;
        }
        setLoop(e) {
            if (this.hasPlaybackControl === !1) {
                console.warn(
                    "THREE.Audio: this Audio has no playback control."
                );
                return;
            }
            return (
                (this.loop = e),
                this.isPlaying === !0 && (this.source.loop = this.loop),
                this
            );
        }
        setLoopStart(e) {
            return (this.loopStart = e), this;
        }
        setLoopEnd(e) {
            return (this.loopEnd = e), this;
        }
        getVolume() {
            return this.gain.gain.value;
        }
        setVolume(e) {
            return (
                this.gain.gain.setTargetAtTime(
                    e,
                    this.context.currentTime,
                    0.01
                ),
                this
            );
        }
    },
    Gn = new M(),
    Eh = new dt(),
    Py = new M(),
    Wn = new M(),
    Ah = class extends Vo {
        constructor(e) {
            super(e),
                (this.panner = this.context.createPanner()),
                (this.panner.panningModel = "HRTF"),
                this.panner.connect(this.gain);
        }
        getOutput() {
            return this.panner;
        }
        getRefDistance() {
            return this.panner.refDistance;
        }
        setRefDistance(e) {
            return (this.panner.refDistance = e), this;
        }
        getRolloffFactor() {
            return this.panner.rolloffFactor;
        }
        setRolloffFactor(e) {
            return (this.panner.rolloffFactor = e), this;
        }
        getDistanceModel() {
            return this.panner.distanceModel;
        }
        setDistanceModel(e) {
            return (this.panner.distanceModel = e), this;
        }
        getMaxDistance() {
            return this.panner.maxDistance;
        }
        setMaxDistance(e) {
            return (this.panner.maxDistance = e), this;
        }
        setDirectionalCone(e, t, n) {
            return (
                (this.panner.coneInnerAngle = e),
                (this.panner.coneOuterAngle = t),
                (this.panner.coneOuterGain = n),
                this
            );
        }
        updateMatrixWorld(e) {
            if (
                (super.updateMatrixWorld(e),
                this.hasPlaybackControl === !0 && this.isPlaying === !1)
            )
                return;
            this.matrixWorld.decompose(Gn, Eh, Py),
                Wn.set(0, 0, 1).applyQuaternion(Eh);
            let t = this.panner;
            if (t.positionX) {
                let n = this.context.currentTime + this.listener.timeDelta;
                t.positionX.linearRampToValueAtTime(Gn.x, n),
                    t.positionY.linearRampToValueAtTime(Gn.y, n),
                    t.positionZ.linearRampToValueAtTime(Gn.z, n),
                    t.orientationX.linearRampToValueAtTime(Wn.x, n),
                    t.orientationY.linearRampToValueAtTime(Wn.y, n),
                    t.orientationZ.linearRampToValueAtTime(Wn.z, n);
            } else
                t.setPosition(Gn.x, Gn.y, Gn.z),
                    t.setOrientation(Wn.x, Wn.y, Wn.z);
        }
    },
    yl = class {
        constructor(e, t = 2048) {
            (this.analyser = e.context.createAnalyser()),
                (this.analyser.fftSize = t),
                (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
                e.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
            let e = 0,
                t = this.getFrequencyData();
            for (let n = 0; n < t.length; n++) e += t[n];
            return e / t.length;
        }
    },
    vl = class {
        constructor(e, t, n) {
            (this.binding = e), (this.valueSize = n);
            let i, s, o;
            switch (t) {
                case "quaternion":
                    (i = this._slerp),
                        (s = this._slerpAdditive),
                        (o = this._setAdditiveIdentityQuaternion),
                        (this.buffer = new Float64Array(n * 6)),
                        (this._workIndex = 5);
                    break;
                case "string":
                case "bool":
                    (i = this._select),
                        (s = this._select),
                        (o = this._setAdditiveIdentityOther),
                        (this.buffer = new Array(n * 5));
                    break;
                default:
                    (i = this._lerp),
                        (s = this._lerpAdditive),
                        (o = this._setAdditiveIdentityNumeric),
                        (this.buffer = new Float64Array(n * 5));
            }
            (this._mixBufferRegion = i),
                (this._mixBufferRegionAdditive = s),
                (this._setIdentity = o),
                (this._origIndex = 3),
                (this._addIndex = 4),
                (this.cumulativeWeight = 0),
                (this.cumulativeWeightAdditive = 0),
                (this.useCount = 0),
                (this.referenceCount = 0);
        }
        accumulate(e, t) {
            let n = this.buffer,
                i = this.valueSize,
                s = e * i + i,
                o = this.cumulativeWeight;
            if (o === 0) {
                for (let a = 0; a !== i; ++a) n[s + a] = n[a];
                o = t;
            } else {
                o += t;
                let a = t / o;
                this._mixBufferRegion(n, s, 0, a, i);
            }
            this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
            let t = this.buffer,
                n = this.valueSize,
                i = n * this._addIndex;
            this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                this._mixBufferRegionAdditive(t, i, 0, e, n),
                (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
            let t = this.valueSize,
                n = this.buffer,
                i = e * t + t,
                s = this.cumulativeWeight,
                o = this.cumulativeWeightAdditive,
                a = this.binding;
            if (
                ((this.cumulativeWeight = 0),
                (this.cumulativeWeightAdditive = 0),
                s < 1)
            ) {
                let l = t * this._origIndex;
                this._mixBufferRegion(n, i, l, 1 - s, t);
            }
            o > 0 &&
                this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
            for (let l = t, c = t + t; l !== c; ++l)
                if (n[l] !== n[l + t]) {
                    a.setValue(n, i);
                    break;
                }
        }
        saveOriginalState() {
            let e = this.binding,
                t = this.buffer,
                n = this.valueSize,
                i = n * this._origIndex;
            e.getValue(t, i);
            for (let s = n, o = i; s !== o; ++s) t[s] = t[i + (s % n)];
            this._setIdentity(),
                (this.cumulativeWeight = 0),
                (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
            let e = this.valueSize * 3;
            this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
            let e = this._addIndex * this.valueSize,
                t = e + this.valueSize;
            for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
                (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
            let e = this._origIndex * this.valueSize,
                t = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
                this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, s) {
            if (i >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[n + o];
        }
        _slerp(e, t, n, i) {
            dt.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, s) {
            let o = this._workIndex * s;
            dt.multiplyQuaternionsFlat(e, o, e, t, e, n),
                dt.slerpFlat(e, t, e, t, e, o, i);
        }
        _lerp(e, t, n, i, s) {
            let o = 1 - i;
            for (let a = 0; a !== s; ++a) {
                let l = t + a;
                e[l] = e[l] * o + e[n + a] * i;
            }
        }
        _lerpAdditive(e, t, n, i, s) {
            for (let o = 0; o !== s; ++o) {
                let a = t + o;
                e[a] = e[a] + e[n + o] * i;
            }
        }
    },
    kl = "\\[\\]\\.:\\/",
    Iy = new RegExp("[" + kl + "]", "g"),
    Vl = "[^" + kl + "]",
    Dy = "[^" + kl.replace("\\.", "") + "]",
    Fy = /((?:WC+[\/:])*)/.source.replace("WC", Vl),
    Ny = /(WCOD+)?/.source.replace("WCOD", Dy),
    zy = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Vl),
    By = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Vl),
    Uy = new RegExp("^" + Fy + Ny + zy + By + "$"),
    Oy = ["material", "materials", "bones"],
    _l = class {
        constructor(e, t, n) {
            let i = n || We.parseTrackName(t);
            (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
            this.bind();
            let n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            i !== void 0 && i.getValue(e, t);
        }
        setValue(e, t) {
            let n = this._bindings;
            for (
                let i = this._targetGroup.nCachedObjects_, s = n.length;
                i !== s;
                ++i
            )
                n[i].setValue(e, t);
        }
        bind() {
            let e = this._bindings;
            for (
                let t = this._targetGroup.nCachedObjects_, n = e.length;
                t !== n;
                ++t
            )
                e[t].bind();
        }
        unbind() {
            let e = this._bindings;
            for (
                let t = this._targetGroup.nCachedObjects_, n = e.length;
                t !== n;
                ++t
            )
                e[t].unbind();
        }
    },
    We = class r {
        constructor(e, t, n) {
            (this.path = t),
                (this.parsedPath = n || r.parseTrackName(t)),
                (this.node = r.findNode(e, this.parsedPath.nodeName) || e),
                (this.rootNode = e),
                (this.getValue = this._getValue_unbound),
                (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
            return e && e.isAnimationObjectGroup
                ? new r.Composite(e, t, n)
                : new r(e, t, n);
        }
        static sanitizeNodeName(e) {
            return e.replace(/\s/g, "_").replace(Iy, "");
        }
        static parseTrackName(e) {
            let t = Uy.exec(e);
            if (!t)
                throw new Error(
                    "PropertyBinding: Cannot parse trackName: " + e
                );
            let n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6],
                },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (i !== void 0 && i !== -1) {
                let s = n.nodeName.substring(i + 1);
                Oy.indexOf(s) !== -1 &&
                    ((n.nodeName = n.nodeName.substring(0, i)),
                    (n.objectName = s));
            }
            if (n.propertyName === null || n.propertyName.length === 0)
                throw new Error(
                    "PropertyBinding: can not parse propertyName from trackName: " +
                        e
                );
            return n;
        }
        static findNode(e, t) {
            if (
                !t ||
                t === "" ||
                t === "." ||
                t === -1 ||
                t === e.name ||
                t === e.uuid
            )
                return e;
            if (e.skeleton) {
                let n = e.skeleton.getBoneByName(t);
                if (n !== void 0) return n;
            }
            if (e.children) {
                let n = function (s) {
                        for (let o = 0; o < s.length; o++) {
                            let a = s[o];
                            if (a.name === t || a.uuid === t) return a;
                            let l = n(a.children);
                            if (l) return l;
                        }
                        return null;
                    },
                    i = n(e.children);
                if (i) return i;
            }
            return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
            e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
            this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
            this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
            (this.targetObject[this.propertyName] = e[t]),
                (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
            (this.targetObject[this.propertyName] = e[t]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
            this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
            let n = this.resolvedProperty;
            for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
            (this.resolvedProperty[this.propertyIndex] = e[t]),
                (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
            (this.resolvedProperty[this.propertyIndex] = e[t]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
            this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t),
                (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
            this.resolvedProperty.fromArray(e, t),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
            this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
            this.bind(), this.setValue(e, t);
        }
        bind() {
            let e = this.node,
                t = this.parsedPath,
                n = t.objectName,
                i = t.propertyName,
                s = t.propertyIndex;
            if (
                (e ||
                    ((e =
                        r.findNode(this.rootNode, t.nodeName) || this.rootNode),
                    (this.node = e)),
                (this.getValue = this._getValue_unavailable),
                (this.setValue = this._setValue_unavailable),
                !e)
            ) {
                console.error(
                    "THREE.PropertyBinding: Trying to update node for track: " +
                        this.path +
                        " but it wasn't found."
                );
                return;
            }
            if (n) {
                let c = t.objectIndex;
                switch (n) {
                    case "materials":
                        if (!e.material) {
                            console.error(
                                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                                this
                            );
                            return;
                        }
                        if (!e.material.materials) {
                            console.error(
                                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                                this
                            );
                            return;
                        }
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton) {
                            console.error(
                                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                                this
                            );
                            return;
                        }
                        e = e.skeleton.bones;
                        for (let h = 0; h < e.length; h++)
                            if (e[h].name === c) {
                                c = h;
                                break;
                            }
                        break;
                    default:
                        if (e[n] === void 0) {
                            console.error(
                                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                                this
                            );
                            return;
                        }
                        e = e[n];
                }
                if (c !== void 0) {
                    if (e[c] === void 0) {
                        console.error(
                            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                            this,
                            e
                        );
                        return;
                    }
                    e = e[c];
                }
            }
            let o = e[i];
            if (o === void 0) {
                let c = t.nodeName;
                console.error(
                    "THREE.PropertyBinding: Trying to update property for track: " +
                        c +
                        "." +
                        i +
                        " but it wasn't found.",
                    e
                );
                return;
            }
            let a = this.Versioning.None;
            (this.targetObject = e),
                e.needsUpdate !== void 0
                    ? (a = this.Versioning.NeedsUpdate)
                    : e.matrixWorldNeedsUpdate !== void 0 &&
                      (a = this.Versioning.MatrixWorldNeedsUpdate);
            let l = this.BindingType.Direct;
            if (s !== void 0) {
                if (i === "morphTargetInfluences") {
                    if (!e.geometry) {
                        console.error(
                            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                            this
                        );
                        return;
                    }
                    if (e.geometry.isBufferGeometry) {
                        if (!e.geometry.morphAttributes) {
                            console.error(
                                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                                this
                            );
                            return;
                        }
                        e.morphTargetDictionary[s] !== void 0 &&
                            (s = e.morphTargetDictionary[s]);
                    } else {
                        console.error(
                            "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                            this
                        );
                        return;
                    }
                }
                (l = this.BindingType.ArrayElement),
                    (this.resolvedProperty = o),
                    (this.propertyIndex = s);
            } else
                o.fromArray !== void 0 && o.toArray !== void 0
                    ? ((l = this.BindingType.HasFromToArray),
                      (this.resolvedProperty = o))
                    : Array.isArray(o)
                    ? ((l = this.BindingType.EntireArray),
                      (this.resolvedProperty = o))
                    : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[l]),
                (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
        }
        unbind() {
            (this.node = null),
                (this.getValue = this._getValue_unbound),
                (this.setValue = this._setValue_unbound);
        }
    };
We.Composite = _l;
We.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
};
We.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2,
};
We.prototype.GetterByBindingType = [
    We.prototype._getValue_direct,
    We.prototype._getValue_array,
    We.prototype._getValue_arrayElement,
    We.prototype._getValue_toArray,
];
We.prototype.SetterByBindingTypeAndVersioning = [
    [
        We.prototype._setValue_direct,
        We.prototype._setValue_direct_setNeedsUpdate,
        We.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
        We.prototype._setValue_array,
        We.prototype._setValue_array_setNeedsUpdate,
        We.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
        We.prototype._setValue_arrayElement,
        We.prototype._setValue_arrayElement_setNeedsUpdate,
        We.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
        We.prototype._setValue_fromArray,
        We.prototype._setValue_fromArray_setNeedsUpdate,
        We.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
];
var Ml = class {
    constructor() {
        (this.uuid = Ct()),
            (this._objects = Array.prototype.slice.call(arguments)),
            (this.nCachedObjects_ = 0);
        let e = {};
        this._indicesByUUID = e;
        for (let n = 0, i = arguments.length; n !== i; ++n)
            e[arguments[n].uuid] = n;
        (this._paths = []),
            (this._parsedPaths = []),
            (this._bindings = []),
            (this._bindingsIndicesByPath = {});
        let t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length;
                },
                get inUse() {
                    return this.total - t.nCachedObjects_;
                },
            },
            get bindingsPerObject() {
                return t._bindings.length;
            },
        };
    }
    add() {
        let e = this._objects,
            t = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            s = this._bindings,
            o = s.length,
            a,
            l = e.length,
            c = this.nCachedObjects_;
        for (let h = 0, u = arguments.length; h !== u; ++h) {
            let d = arguments[h],
                f = d.uuid,
                m = t[f];
            if (m === void 0) {
                (m = l++), (t[f] = m), e.push(d);
                for (let x = 0, v = o; x !== v; ++x)
                    s[x].push(new We(d, n[x], i[x]));
            } else if (m < c) {
                a = e[m];
                let x = --c,
                    v = e[x];
                (t[v.uuid] = m), (e[m] = v), (t[f] = x), (e[x] = d);
                for (let g = 0, p = o; g !== p; ++g) {
                    let _ = s[g],
                        y = _[x],
                        w = _[m];
                    (_[m] = y),
                        w === void 0 && (w = new We(d, n[g], i[g])),
                        (_[x] = w);
                }
            } else
                e[m] !== a &&
                    console.error(
                        "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                    );
        }
        this.nCachedObjects_ = c;
    }
    remove() {
        let e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length,
            s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            let l = arguments[o],
                c = l.uuid,
                h = t[c];
            if (h !== void 0 && h >= s) {
                let u = s++,
                    d = e[u];
                (t[d.uuid] = h), (e[h] = d), (t[c] = u), (e[u] = l);
                for (let f = 0, m = i; f !== m; ++f) {
                    let x = n[f],
                        v = x[u],
                        g = x[h];
                    (x[h] = v), (x[u] = g);
                }
            }
        }
        this.nCachedObjects_ = s;
    }
    uncache() {
        let e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length,
            s = this.nCachedObjects_,
            o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            let c = arguments[a],
                h = c.uuid,
                u = t[h];
            if (u !== void 0)
                if ((delete t[h], u < s)) {
                    let d = --s,
                        f = e[d],
                        m = --o,
                        x = e[m];
                    (t[f.uuid] = u),
                        (e[u] = f),
                        (t[x.uuid] = d),
                        (e[d] = x),
                        e.pop();
                    for (let v = 0, g = i; v !== g; ++v) {
                        let p = n[v],
                            _ = p[d],
                            y = p[m];
                        (p[u] = _), (p[d] = y), p.pop();
                    }
                } else {
                    let d = --o,
                        f = e[d];
                    d > 0 && (t[f.uuid] = u), (e[u] = f), e.pop();
                    for (let m = 0, x = i; m !== x; ++m) {
                        let v = n[m];
                        (v[u] = v[d]), v.pop();
                    }
                }
        }
        this.nCachedObjects_ = s;
    }
    subscribe_(e, t) {
        let n = this._bindingsIndicesByPath,
            i = n[e],
            s = this._bindings;
        if (i !== void 0) return s[i];
        let o = this._paths,
            a = this._parsedPaths,
            l = this._objects,
            c = l.length,
            h = this.nCachedObjects_,
            u = new Array(c);
        (i = s.length), (n[e] = i), o.push(e), a.push(t), s.push(u);
        for (let d = h, f = l.length; d !== f; ++d) {
            let m = l[d];
            u[d] = new We(m, e, t);
        }
        return u;
    }
    unsubscribe_(e) {
        let t = this._bindingsIndicesByPath,
            n = t[e];
        if (n !== void 0) {
            let i = this._paths,
                s = this._parsedPaths,
                o = this._bindings,
                a = o.length - 1,
                l = o[a],
                c = e[a];
            (t[c] = n),
                (o[n] = l),
                o.pop(),
                (s[n] = s[a]),
                s.pop(),
                (i[n] = i[a]),
                i.pop();
        }
    }
};
Ml.prototype.isAnimationObjectGroup = !0;
var wl = class {
        constructor(e, t, n = null, i = t.blendMode) {
            (this._mixer = e),
                (this._clip = t),
                (this._localRoot = n),
                (this.blendMode = i);
            let s = t.tracks,
                o = s.length,
                a = new Array(o),
                l = { endingStart: bi, endingEnd: bi };
            for (let c = 0; c !== o; ++c) {
                let h = s[c].createInterpolant(null);
                (a[c] = h), (h.settings = l);
            }
            (this._interpolantSettings = l),
                (this._interpolants = a),
                (this._propertyBindings = new Array(o)),
                (this._cacheIndex = null),
                (this._byClipCacheIndex = null),
                (this._timeScaleInterpolant = null),
                (this._weightInterpolant = null),
                (this.loop = Qd),
                (this._loopCount = -1),
                (this._startTime = null),
                (this.time = 0),
                (this.timeScale = 1),
                (this._effectiveTimeScale = 1),
                (this.weight = 1),
                (this._effectiveWeight = 1),
                (this.repetitions = 1 / 0),
                (this.paused = !1),
                (this.enabled = !0),
                (this.clampWhenFinished = !1),
                (this.zeroSlopeAtStart = !0),
                (this.zeroSlopeAtEnd = !0);
        }
        play() {
            return this._mixer._activateAction(this), this;
        }
        stop() {
            return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
            return (
                (this.paused = !1),
                (this.enabled = !0),
                (this.time = 0),
                (this._loopCount = -1),
                (this._startTime = null),
                this.stopFading().stopWarping()
            );
        }
        isRunning() {
            return (
                this.enabled &&
                !this.paused &&
                this.timeScale !== 0 &&
                this._startTime === null &&
                this._mixer._isActiveAction(this)
            );
        }
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(e) {
            return (this._startTime = e), this;
        }
        setLoop(e, t) {
            return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
            return (
                (this.weight = e),
                (this._effectiveWeight = this.enabled ? e : 0),
                this.stopFading()
            );
        }
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(e) {
            return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
            return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
            if ((e.fadeOut(t), this.fadeIn(t), n)) {
                let i = this._clip.duration,
                    s = e._clip.duration,
                    o = s / i,
                    a = i / s;
                e.warp(1, o, t), this.warp(a, 1, t);
            }
            return this;
        }
        crossFadeTo(e, t, n) {
            return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
            let e = this._weightInterpolant;
            return (
                e !== null &&
                    ((this._weightInterpolant = null),
                    this._mixer._takeBackControlInterpolant(e)),
                this
            );
        }
        setEffectiveTimeScale(e) {
            return (
                (this.timeScale = e),
                (this._effectiveTimeScale = this.paused ? 0 : e),
                this.stopWarping()
            );
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(e) {
            return (
                (this.timeScale = this._clip.duration / e), this.stopWarping()
            );
        }
        syncWith(e) {
            return (
                (this.time = e.time),
                (this.timeScale = e.timeScale),
                this.stopWarping()
            );
        }
        halt(e) {
            return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
            let i = this._mixer,
                s = i.time,
                o = this.timeScale,
                a = this._timeScaleInterpolant;
            a === null &&
                ((a = i._lendControlInterpolant()),
                (this._timeScaleInterpolant = a));
            let l = a.parameterPositions,
                c = a.sampleValues;
            return (
                (l[0] = s), (l[1] = s + n), (c[0] = e / o), (c[1] = t / o), this
            );
        }
        stopWarping() {
            let e = this._timeScaleInterpolant;
            return (
                e !== null &&
                    ((this._timeScaleInterpolant = null),
                    this._mixer._takeBackControlInterpolant(e)),
                this
            );
        }
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
            if (!this.enabled) {
                this._updateWeight(e);
                return;
            }
            let s = this._startTime;
            if (s !== null) {
                let l = (e - s) * n;
                if (l < 0 || n === 0) return;
                (this._startTime = null), (t = n * l);
            }
            t *= this._updateTimeScale(e);
            let o = this._updateTime(t),
                a = this._updateWeight(e);
            if (a > 0) {
                let l = this._interpolants,
                    c = this._propertyBindings;
                switch (this.blendMode) {
                    case nu:
                        for (let h = 0, u = l.length; h !== u; ++h)
                            l[h].evaluate(o), c[h].accumulateAdditive(a);
                        break;
                    case Nl:
                    default:
                        for (let h = 0, u = l.length; h !== u; ++h)
                            l[h].evaluate(o), c[h].accumulate(i, a);
                }
            }
        }
        _updateWeight(e) {
            let t = 0;
            if (this.enabled) {
                t = this.weight;
                let n = this._weightInterpolant;
                if (n !== null) {
                    let i = n.evaluate(e)[0];
                    (t *= i),
                        e > n.parameterPositions[1] &&
                            (this.stopFading(), i === 0 && (this.enabled = !1));
                }
            }
            return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
            let t = 0;
            if (!this.paused) {
                t = this.timeScale;
                let n = this._timeScaleInterpolant;
                if (n !== null) {
                    let i = n.evaluate(e)[0];
                    (t *= i),
                        e > n.parameterPositions[1] &&
                            (this.stopWarping(),
                            t === 0
                                ? (this.paused = !0)
                                : (this.timeScale = t));
                }
            }
            return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
            let t = this._clip.duration,
                n = this.loop,
                i = this.time + e,
                s = this._loopCount,
                o = n === Kd;
            if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
            if (n === jd) {
                s === -1 &&
                    ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                e: {
                    if (i >= t) i = t;
                    else if (i < 0) i = 0;
                    else {
                        this.time = i;
                        break e;
                    }
                    this.clampWhenFinished
                        ? (this.paused = !0)
                        : (this.enabled = !1),
                        (this.time = i),
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1,
                        });
                }
            } else {
                if (
                    (s === -1 &&
                        (e >= 0
                            ? ((s = 0),
                              this._setEndings(!0, this.repetitions === 0, o))
                            : this._setEndings(this.repetitions === 0, !0, o)),
                    i >= t || i < 0)
                ) {
                    let a = Math.floor(i / t);
                    (i -= t * a), (s += Math.abs(a));
                    let l = this.repetitions - s;
                    if (l <= 0)
                        this.clampWhenFinished
                            ? (this.paused = !0)
                            : (this.enabled = !1),
                            (i = e > 0 ? t : 0),
                            (this.time = i),
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1,
                            });
                    else {
                        if (l === 1) {
                            let c = e < 0;
                            this._setEndings(c, !c, o);
                        } else this._setEndings(!1, !1, o);
                        (this._loopCount = s),
                            (this.time = i),
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: a,
                            });
                    }
                } else this.time = i;
                if (o && (s & 1) === 1) return t - i;
            }
            return i;
        }
        _setEndings(e, t, n) {
            let i = this._interpolantSettings;
            n
                ? ((i.endingStart = Si), (i.endingEnd = Si))
                : (e
                      ? (i.endingStart = this.zeroSlopeAtStart ? Si : bi)
                      : (i.endingStart = Zr),
                  t
                      ? (i.endingEnd = this.zeroSlopeAtEnd ? Si : bi)
                      : (i.endingEnd = Zr));
        }
        _scheduleFading(e, t, n) {
            let i = this._mixer,
                s = i.time,
                o = this._weightInterpolant;
            o === null &&
                ((o = i._lendControlInterpolant()),
                (this._weightInterpolant = o));
            let a = o.parameterPositions,
                l = o.sampleValues;
            return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = n), this;
        }
    },
    bl = class extends cn {
        constructor(e) {
            super(),
                (this._root = e),
                this._initMemoryManager(),
                (this._accuIndex = 0),
                (this.time = 0),
                (this.timeScale = 1);
        }
        _bindAction(e, t) {
            let n = e._localRoot || this._root,
                i = e._clip.tracks,
                s = i.length,
                o = e._propertyBindings,
                a = e._interpolants,
                l = n.uuid,
                c = this._bindingsByRootAndName,
                h = c[l];
            h === void 0 && ((h = {}), (c[l] = h));
            for (let u = 0; u !== s; ++u) {
                let d = i[u],
                    f = d.name,
                    m = h[f];
                if (m !== void 0) o[u] = m;
                else {
                    if (((m = o[u]), m !== void 0)) {
                        m._cacheIndex === null &&
                            (++m.referenceCount,
                            this._addInactiveBinding(m, l, f));
                        continue;
                    }
                    let x = t && t._propertyBindings[u].binding.parsedPath;
                    (m = new vl(
                        We.create(n, f, x),
                        d.ValueTypeName,
                        d.getValueSize()
                    )),
                        ++m.referenceCount,
                        this._addInactiveBinding(m, l, f),
                        (o[u] = m);
                }
                a[u].resultBuffer = m.buffer;
            }
        }
        _activateAction(e) {
            if (!this._isActiveAction(e)) {
                if (e._cacheIndex === null) {
                    let n = (e._localRoot || this._root).uuid,
                        i = e._clip.uuid,
                        s = this._actionsByClip[i];
                    this._bindAction(e, s && s.knownActions[0]),
                        this._addInactiveAction(e, i, n);
                }
                let t = e._propertyBindings;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    let s = t[n];
                    s.useCount++ === 0 &&
                        (this._lendBinding(s), s.saveOriginalState());
                }
                this._lendAction(e);
            }
        }
        _deactivateAction(e) {
            if (this._isActiveAction(e)) {
                let t = e._propertyBindings;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    let s = t[n];
                    --s.useCount === 0 &&
                        (s.restoreOriginalState(), this._takeBackBinding(s));
                }
                this._takeBackAction(e);
            }
        }
        _initMemoryManager() {
            (this._actions = []),
                (this._nActiveActions = 0),
                (this._actionsByClip = {}),
                (this._bindings = []),
                (this._nActiveBindings = 0),
                (this._bindingsByRootAndName = {}),
                (this._controlInterpolants = []),
                (this._nActiveControlInterpolants = 0);
            let e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length;
                    },
                    get inUse() {
                        return e._nActiveActions;
                    },
                },
                bindings: {
                    get total() {
                        return e._bindings.length;
                    },
                    get inUse() {
                        return e._nActiveBindings;
                    },
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length;
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants;
                    },
                },
            };
        }
        _isActiveAction(e) {
            let t = e._cacheIndex;
            return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
            let i = this._actions,
                s = this._actionsByClip,
                o = s[t];
            if (o === void 0)
                (o = { knownActions: [e], actionByRoot: {} }),
                    (e._byClipCacheIndex = 0),
                    (s[t] = o);
            else {
                let a = o.knownActions;
                (e._byClipCacheIndex = a.length), a.push(e);
            }
            (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
            let t = this._actions,
                n = t[t.length - 1],
                i = e._cacheIndex;
            (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
            let s = e._clip.uuid,
                o = this._actionsByClip,
                a = o[s],
                l = a.knownActions,
                c = l[l.length - 1],
                h = e._byClipCacheIndex;
            (c._byClipCacheIndex = h),
                (l[h] = c),
                l.pop(),
                (e._byClipCacheIndex = null);
            let u = a.actionByRoot,
                d = (e._localRoot || this._root).uuid;
            delete u[d],
                l.length === 0 && delete o[s],
                this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
            let t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                let s = t[n];
                --s.referenceCount === 0 && this._removeInactiveBinding(s);
            }
        }
        _lendAction(e) {
            let t = this._actions,
                n = e._cacheIndex,
                i = this._nActiveActions++,
                s = t[i];
            (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _takeBackAction(e) {
            let t = this._actions,
                n = e._cacheIndex,
                i = --this._nActiveActions,
                s = t[i];
            (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _addInactiveBinding(e, t, n) {
            let i = this._bindingsByRootAndName,
                s = this._bindings,
                o = i[t];
            o === void 0 && ((o = {}), (i[t] = o)),
                (o[n] = e),
                (e._cacheIndex = s.length),
                s.push(e);
        }
        _removeInactiveBinding(e) {
            let t = this._bindings,
                n = e.binding,
                i = n.rootNode.uuid,
                s = n.path,
                o = this._bindingsByRootAndName,
                a = o[i],
                l = t[t.length - 1],
                c = e._cacheIndex;
            (l._cacheIndex = c),
                (t[c] = l),
                t.pop(),
                delete a[s],
                Object.keys(a).length === 0 && delete o[i];
        }
        _lendBinding(e) {
            let t = this._bindings,
                n = e._cacheIndex,
                i = this._nActiveBindings++,
                s = t[i];
            (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _takeBackBinding(e) {
            let t = this._bindings,
                n = e._cacheIndex,
                i = --this._nActiveBindings,
                s = t[i];
            (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
        }
        _lendControlInterpolant() {
            let e = this._controlInterpolants,
                t = this._nActiveControlInterpolants++,
                n = e[t];
            return (
                n === void 0 &&
                    ((n = new Ro(
                        new Float32Array(2),
                        new Float32Array(2),
                        1,
                        this._controlInterpolantsResultBuffer
                    )),
                    (n.__cacheIndex = t),
                    (e[t] = n)),
                n
            );
        }
        _takeBackControlInterpolant(e) {
            let t = this._controlInterpolants,
                n = e.__cacheIndex,
                i = --this._nActiveControlInterpolants,
                s = t[i];
            (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = n), (t[n] = s);
        }
        clipAction(e, t, n) {
            let i = t || this._root,
                s = i.uuid,
                o = typeof e == "string" ? Wi.findByName(i, e) : e,
                a = o !== null ? o.uuid : e,
                l = this._actionsByClip[a],
                c = null;
            if (
                (n === void 0 && (o !== null ? (n = o.blendMode) : (n = Nl)),
                l !== void 0)
            ) {
                let u = l.actionByRoot[s];
                if (u !== void 0 && u.blendMode === n) return u;
                (c = l.knownActions[0]), o === null && (o = c._clip);
            }
            if (o === null) return null;
            let h = new wl(this, o, t, n);
            return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
        }
        existingAction(e, t) {
            let n = t || this._root,
                i = n.uuid,
                s = typeof e == "string" ? Wi.findByName(n, e) : e,
                o = s ? s.uuid : e,
                a = this._actionsByClip[o];
            return (a !== void 0 && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
            let e = this._actions,
                t = this._nActiveActions;
            for (let n = t - 1; n >= 0; --n) e[n].stop();
            return this;
        }
        update(e) {
            e *= this.timeScale;
            let t = this._actions,
                n = this._nActiveActions,
                i = (this.time += e),
                s = Math.sign(e),
                o = (this._accuIndex ^= 1);
            for (let c = 0; c !== n; ++c) t[c]._update(i, e, s, o);
            let a = this._bindings,
                l = this._nActiveBindings;
            for (let c = 0; c !== l; ++c) a[c].apply(o);
            return this;
        }
        setTime(e) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
                this._actions[t].time = 0;
            return this.update(e);
        }
        getRoot() {
            return this._root;
        }
        uncacheClip(e) {
            let t = this._actions,
                n = e.uuid,
                i = this._actionsByClip,
                s = i[n];
            if (s !== void 0) {
                let o = s.knownActions;
                for (let a = 0, l = o.length; a !== l; ++a) {
                    let c = o[a];
                    this._deactivateAction(c);
                    let h = c._cacheIndex,
                        u = t[t.length - 1];
                    (c._cacheIndex = null),
                        (c._byClipCacheIndex = null),
                        (u._cacheIndex = h),
                        (t[h] = u),
                        t.pop(),
                        this._removeInactiveBindingsForAction(c);
                }
                delete i[n];
            }
        }
        uncacheRoot(e) {
            let t = e.uuid,
                n = this._actionsByClip;
            for (let o in n) {
                let a = n[o].actionByRoot,
                    l = a[t];
                l !== void 0 &&
                    (this._deactivateAction(l), this._removeInactiveAction(l));
            }
            let i = this._bindingsByRootAndName,
                s = i[t];
            if (s !== void 0)
                for (let o in s) {
                    let a = s[o];
                    a.restoreOriginalState(), this._removeInactiveBinding(a);
                }
        }
        uncacheAction(e, t) {
            let n = this.existingAction(e, t);
            n !== null &&
                (this._deactivateAction(n), this._removeInactiveAction(n));
        }
    };
bl.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Sl = class r {
        constructor(e) {
            typeof e == "string" &&
                (console.warn(
                    "THREE.Uniform: Type parameter is no longer needed."
                ),
                (e = arguments[1])),
                (this.value = e);
        }
        clone() {
            return new r(
                this.value.clone === void 0 ? this.value : this.value.clone()
            );
        }
    },
    Tl = class extends An {
        constructor(e, t, n = 1) {
            super(e, t), (this.meshPerAttribute = n);
        }
        copy(e) {
            return (
                super.copy(e),
                (this.meshPerAttribute = e.meshPerAttribute),
                this
            );
        }
        clone(e) {
            let t = super.clone(e);
            return (t.meshPerAttribute = this.meshPerAttribute), t;
        }
        toJSON(e) {
            let t = super.toJSON(e);
            return (
                (t.isInstancedInterleavedBuffer = !0),
                (t.meshPerAttribute = this.meshPerAttribute),
                t
            );
        }
    };
Tl.prototype.isInstancedInterleavedBuffer = !0;
var El = class {
    constructor(e, t, n, i, s) {
        (this.buffer = e),
            (this.type = t),
            (this.itemSize = n),
            (this.elementSize = i),
            (this.count = s),
            (this.version = 0);
    }
    set needsUpdate(e) {
        e === !0 && this.version++;
    }
    setBuffer(e) {
        return (this.buffer = e), this;
    }
    setType(e, t) {
        return (this.type = e), (this.elementSize = t), this;
    }
    setItemSize(e) {
        return (this.itemSize = e), this;
    }
    setCount(e) {
        return (this.count = e), this;
    }
};
El.prototype.isGLBufferAttribute = !0;
var Rh = class {
    constructor(e, t, n = 0, i = 1 / 0) {
        (this.ray = new un(e, t)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new bs()),
            (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
            });
    }
    set(e, t) {
        this.ray.set(e, t);
    }
    setFromCamera(e, t) {
        t && t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                  .set(e.x, e.y, 0.5)
                  .unproject(t)
                  .sub(this.ray.origin)
                  .normalize(),
              (this.camera = t))
            : t && t.isOrthographicCamera
            ? (this.ray.origin
                  .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                  .unproject(t),
              this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(t.matrixWorld),
              (this.camera = t))
            : console.error(
                  "THREE.Raycaster: Unsupported camera type: " + t.type
              );
    }
    intersectObject(e, t = !0, n = []) {
        return Al(e, this, n, t), n.sort(Ch), n;
    }
    intersectObjects(e, t = !0, n = []) {
        for (let i = 0, s = e.length; i < s; i++) Al(e[i], this, n, t);
        return n.sort(Ch), n;
    }
};
function Ch(r, e) {
    return r.distance - e.distance;
}
function Al(r, e, t, n) {
    if ((r.layers.test(e.layers) && r.raycast(e, t), n === !0)) {
        let i = r.children;
        for (let s = 0, o = i.length; s < o; s++) Al(i[s], e, t, !0);
    }
}
var Lh = class {
        constructor(e = 1, t = 0, n = 0) {
            return (this.radius = e), (this.phi = t), (this.theta = n), this;
        }
        set(e, t, n) {
            return (this.radius = e), (this.phi = t), (this.theta = n), this;
        }
        copy(e) {
            return (
                (this.radius = e.radius),
                (this.phi = e.phi),
                (this.theta = e.theta),
                this
            );
        }
        makeSafe() {
            return (
                (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
                this
            );
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
            return (
                (this.radius = Math.sqrt(e * e + t * t + n * n)),
                this.radius === 0
                    ? ((this.theta = 0), (this.phi = 0))
                    : ((this.theta = Math.atan2(e, n)),
                      (this.phi = Math.acos(mt(t / this.radius, -1, 1)))),
                this
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
    },
    Ph = class {
        constructor(e = 1, t = 0, n = 0) {
            return (this.radius = e), (this.theta = t), (this.y = n), this;
        }
        set(e, t, n) {
            return (this.radius = e), (this.theta = t), (this.y = n), this;
        }
        copy(e) {
            return (
                (this.radius = e.radius),
                (this.theta = e.theta),
                (this.y = e.y),
                this
            );
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, n) {
            return (
                (this.radius = Math.sqrt(e * e + n * n)),
                (this.theta = Math.atan2(e, n)),
                (this.y = t),
                this
            );
        }
        clone() {
            return new this.constructor().copy(this);
        }
    },
    Ih = new W(),
    ti = class {
        constructor(e = new W(1 / 0, 1 / 0), t = new W(-1 / 0, -1 / 0)) {
            (this.min = e), (this.max = t);
        }
        set(e, t) {
            return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
            return this;
        }
        setFromCenterAndSize(e, t) {
            let n = Ih.copy(t).multiplyScalar(0.5);
            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        clone() {
            return new this.constructor().copy(this);
        }
        copy(e) {
            return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
            return (
                (this.min.x = this.min.y = 1 / 0),
                (this.max.x = this.max.y = -1 / 0),
                this
            );
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
            return this.isEmpty()
                ? e.set(0, 0)
                : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
            return this.isEmpty()
                ? e.set(0, 0)
                : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
            return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
            return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
            return !(
                e.x < this.min.x ||
                e.x > this.max.x ||
                e.y < this.min.y ||
                e.y > this.max.y
            );
        }
        containsBox(e) {
            return (
                this.min.x <= e.min.x &&
                e.max.x <= this.max.x &&
                this.min.y <= e.min.y &&
                e.max.y <= this.max.y
            );
        }
        getParameter(e, t) {
            return t.set(
                (e.x - this.min.x) / (this.max.x - this.min.x),
                (e.y - this.min.y) / (this.max.y - this.min.y)
            );
        }
        intersectsBox(e) {
            return !(
                e.max.x < this.min.x ||
                e.min.x > this.max.x ||
                e.max.y < this.min.y ||
                e.min.y > this.max.y
            );
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
            return Ih.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        intersect(e) {
            return this.min.max(e.min), this.max.min(e.max), this;
        }
        union(e) {
            return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
            return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max);
        }
    };
ti.prototype.isBox2 = !0;
var Dh = new M(),
    zr = new M(),
    Rl = class {
        constructor(e = new M(), t = new M()) {
            (this.start = e), (this.end = t);
        }
        set(e, t) {
            return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
            return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
            return e.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(e) {
            return e.subVectors(this.end, this.start);
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end);
        }
        distance() {
            return this.start.distanceTo(this.end);
        }
        at(e, t) {
            return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
            Dh.subVectors(e, this.start), zr.subVectors(this.end, this.start);
            let n = zr.dot(zr),
                s = zr.dot(Dh) / n;
            return t && (s = mt(s, 0, 1)), s;
        }
        closestPointToPoint(e, t, n) {
            let i = this.closestPointToPointParameter(e, t);
            return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
            return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
            return new this.constructor().copy(this);
        }
    },
    Fh = new M(),
    Nh = class extends Be {
        constructor(e, t) {
            super(),
                (this.light = e),
                this.light.updateMatrixWorld(),
                (this.matrix = e.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = t);
            let n = new _e(),
                i = [
                    0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0,
                    0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
                ];
            for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
                let c = (o / l) * Math.PI * 2,
                    h = (a / l) * Math.PI * 2;
                i.push(
                    Math.cos(c),
                    Math.sin(c),
                    1,
                    Math.cos(h),
                    Math.sin(h),
                    1
                );
            }
            n.setAttribute("position", new de(i, 3));
            let s = new ht({ fog: !1, toneMapped: !1 });
            (this.cone = new bt(n, s)), this.add(this.cone), this.update();
        }
        dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
            this.light.updateMatrixWorld();
            let e = this.light.distance ? this.light.distance : 1e3,
                t = e * Math.tan(this.light.angle);
            this.cone.scale.set(t, t, e),
                Fh.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(Fh),
                this.color !== void 0
                    ? this.cone.material.color.set(this.color)
                    : this.cone.material.color.copy(this.light.color);
        }
    },
    vn = new M(),
    Br = new me(),
    Ca = new me(),
    Cl = class extends bt {
        constructor(e) {
            let t = Su(e),
                n = new _e(),
                i = [],
                s = [],
                o = new re(0, 0, 1),
                a = new re(0, 1, 0);
            for (let c = 0; c < t.length; c++) {
                let h = t[c];
                h.parent &&
                    h.parent.isBone &&
                    (i.push(0, 0, 0),
                    i.push(0, 0, 0),
                    s.push(o.r, o.g, o.b),
                    s.push(a.r, a.g, a.b));
            }
            n.setAttribute("position", new de(i, 3)),
                n.setAttribute("color", new de(s, 3));
            let l = new ht({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
            });
            super(n, l),
                (this.type = "SkeletonHelper"),
                (this.isSkeletonHelper = !0),
                (this.root = e),
                (this.bones = t),
                (this.matrix = e.matrixWorld),
                (this.matrixAutoUpdate = !1);
        }
        updateMatrixWorld(e) {
            let t = this.bones,
                n = this.geometry,
                i = n.getAttribute("position");
            Ca.copy(this.root.matrixWorld).invert();
            for (let s = 0, o = 0; s < t.length; s++) {
                let a = t[s];
                a.parent &&
                    a.parent.isBone &&
                    (Br.multiplyMatrices(Ca, a.matrixWorld),
                    vn.setFromMatrixPosition(Br),
                    i.setXYZ(o, vn.x, vn.y, vn.z),
                    Br.multiplyMatrices(Ca, a.parent.matrixWorld),
                    vn.setFromMatrixPosition(Br),
                    i.setXYZ(o + 1, vn.x, vn.y, vn.z),
                    (o += 2));
            }
            (n.getAttribute("position").needsUpdate = !0),
                super.updateMatrixWorld(e);
        }
    };
function Su(r) {
    let e = [];
    r && r.isBone && e.push(r);
    for (let t = 0; t < r.children.length; t++)
        e.push.apply(e, Su(r.children[t]));
    return e;
}
var zh = class extends nt {
        constructor(e, t, n) {
            let i = new Js(t, 4, 2),
                s = new Yt({ wireframe: !0, fog: !1, toneMapped: !1 });
            super(i, s),
                (this.light = e),
                this.light.updateMatrixWorld(),
                (this.color = n),
                (this.type = "PointLightHelper"),
                (this.matrix = this.light.matrixWorld),
                (this.matrixAutoUpdate = !1),
                this.update();
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
        update() {
            this.color !== void 0
                ? this.material.color.set(this.color)
                : this.material.color.copy(this.light.color);
        }
    },
    Hy = new M(),
    Bh = new re(),
    Uh = new re(),
    Oh = class extends Be {
        constructor(e, t, n) {
            super(),
                (this.light = e),
                this.light.updateMatrixWorld(),
                (this.matrix = e.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n);
            let i = new qs(t);
            i.rotateY(Math.PI * 0.5),
                (this.material = new Yt({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1,
                })),
                this.color === void 0 && (this.material.vertexColors = !0);
            let s = i.getAttribute("position"),
                o = new Float32Array(s.count * 3);
            i.setAttribute("color", new ze(o, 3)),
                this.add(new nt(i, this.material)),
                this.update();
        }
        dispose() {
            this.children[0].geometry.dispose(),
                this.children[0].material.dispose();
        }
        update() {
            let e = this.children[0];
            if (this.color !== void 0) this.material.color.set(this.color);
            else {
                let t = e.geometry.getAttribute("color");
                Bh.copy(this.light.color), Uh.copy(this.light.groundColor);
                for (let n = 0, i = t.count; n < i; n++) {
                    let s = n < i / 2 ? Bh : Uh;
                    t.setXYZ(n, s.r, s.g, s.b);
                }
                t.needsUpdate = !0;
            }
            e.lookAt(Hy.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
    },
    Ll = class extends bt {
        constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
            (n = new re(n)), (i = new re(i));
            let s = t / 2,
                o = e / t,
                a = e / 2,
                l = [],
                c = [];
            for (let d = 0, f = 0, m = -a; d <= t; d++, m += o) {
                l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
                let x = d === s ? n : i;
                x.toArray(c, f),
                    (f += 3),
                    x.toArray(c, f),
                    (f += 3),
                    x.toArray(c, f),
                    (f += 3),
                    x.toArray(c, f),
                    (f += 3);
            }
            let h = new _e();
            h.setAttribute("position", new de(l, 3)),
                h.setAttribute("color", new de(c, 3));
            let u = new ht({ vertexColors: !0, toneMapped: !1 });
            super(h, u), (this.type = "GridHelper");
        }
    },
    Hh = class extends bt {
        constructor(e = 10, t = 16, n = 8, i = 64, s = 4473924, o = 8947848) {
            (s = new re(s)), (o = new re(o));
            let a = [],
                l = [];
            for (let u = 0; u <= t; u++) {
                let d = (u / t) * (Math.PI * 2),
                    f = Math.sin(d) * e,
                    m = Math.cos(d) * e;
                a.push(0, 0, 0), a.push(f, 0, m);
                let x = u & 1 ? s : o;
                l.push(x.r, x.g, x.b), l.push(x.r, x.g, x.b);
            }
            for (let u = 0; u <= n; u++) {
                let d = u & 1 ? s : o,
                    f = e - (e / n) * u;
                for (let m = 0; m < i; m++) {
                    let x = (m / i) * (Math.PI * 2),
                        v = Math.sin(x) * f,
                        g = Math.cos(x) * f;
                    a.push(v, 0, g),
                        l.push(d.r, d.g, d.b),
                        (x = ((m + 1) / i) * (Math.PI * 2)),
                        (v = Math.sin(x) * f),
                        (g = Math.cos(x) * f),
                        a.push(v, 0, g),
                        l.push(d.r, d.g, d.b);
                }
            }
            let c = new _e();
            c.setAttribute("position", new de(a, 3)),
                c.setAttribute("color", new de(l, 3));
            let h = new ht({ vertexColors: !0, toneMapped: !1 });
            super(c, h), (this.type = "PolarGridHelper");
        }
    },
    kh = new M(),
    Ur = new M(),
    Vh = new M(),
    Gh = class extends Be {
        constructor(e, t, n) {
            super(),
                (this.light = e),
                this.light.updateMatrixWorld(),
                (this.matrix = e.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                t === void 0 && (t = 1);
            let i = new _e();
            i.setAttribute(
                "position",
                new de([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
            );
            let s = new ht({ fog: !1, toneMapped: !1 });
            (this.lightPlane = new $t(i, s)),
                this.add(this.lightPlane),
                (i = new _e()),
                i.setAttribute("position", new de([0, 0, 0, 0, 0, 1], 3)),
                (this.targetLine = new $t(i, s)),
                this.add(this.targetLine),
                this.update();
        }
        dispose() {
            this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose();
        }
        update() {
            kh.setFromMatrixPosition(this.light.matrixWorld),
                Ur.setFromMatrixPosition(this.light.target.matrixWorld),
                Vh.subVectors(Ur, kh),
                this.lightPlane.lookAt(Ur),
                this.color !== void 0
                    ? (this.lightPlane.material.color.set(this.color),
                      this.targetLine.material.color.set(this.color))
                    : (this.lightPlane.material.color.copy(this.light.color),
                      this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(Ur),
                (this.targetLine.scale.z = Vh.length());
        }
    },
    Or = new M(),
    Qe = new Fi(),
    Wh = class extends bt {
        constructor(e) {
            let t = new _e(),
                n = new ht({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1,
                }),
                i = [],
                s = [],
                o = {},
                a = new re(16755200),
                l = new re(16711680),
                c = new re(43775),
                h = new re(16777215),
                u = new re(3355443);
            d("n1", "n2", a),
                d("n2", "n4", a),
                d("n4", "n3", a),
                d("n3", "n1", a),
                d("f1", "f2", a),
                d("f2", "f4", a),
                d("f4", "f3", a),
                d("f3", "f1", a),
                d("n1", "f1", a),
                d("n2", "f2", a),
                d("n3", "f3", a),
                d("n4", "f4", a),
                d("p", "n1", l),
                d("p", "n2", l),
                d("p", "n3", l),
                d("p", "n4", l),
                d("u1", "u2", c),
                d("u2", "u3", c),
                d("u3", "u1", c),
                d("c", "t", h),
                d("p", "c", u),
                d("cn1", "cn2", u),
                d("cn3", "cn4", u),
                d("cf1", "cf2", u),
                d("cf3", "cf4", u);
            function d(m, x, v) {
                f(m, v), f(x, v);
            }
            function f(m, x) {
                i.push(0, 0, 0),
                    s.push(x.r, x.g, x.b),
                    o[m] === void 0 && (o[m] = []),
                    o[m].push(i.length / 3 - 1);
            }
            t.setAttribute("position", new de(i, 3)),
                t.setAttribute("color", new de(s, 3)),
                super(t, n),
                (this.type = "CameraHelper"),
                (this.camera = e),
                this.camera.updateProjectionMatrix &&
                    this.camera.updateProjectionMatrix(),
                (this.matrix = e.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.pointMap = o),
                this.update();
        }
        update() {
            let e = this.geometry,
                t = this.pointMap,
                n = 1,
                i = 1;
            Qe.projectionMatrixInverse.copy(
                this.camera.projectionMatrixInverse
            ),
                et("c", t, e, Qe, 0, 0, -1),
                et("t", t, e, Qe, 0, 0, 1),
                et("n1", t, e, Qe, -n, -i, -1),
                et("n2", t, e, Qe, n, -i, -1),
                et("n3", t, e, Qe, -n, i, -1),
                et("n4", t, e, Qe, n, i, -1),
                et("f1", t, e, Qe, -n, -i, 1),
                et("f2", t, e, Qe, n, -i, 1),
                et("f3", t, e, Qe, -n, i, 1),
                et("f4", t, e, Qe, n, i, 1),
                et("u1", t, e, Qe, n * 0.7, i * 1.1, -1),
                et("u2", t, e, Qe, -n * 0.7, i * 1.1, -1),
                et("u3", t, e, Qe, 0, i * 2, -1),
                et("cf1", t, e, Qe, -n, 0, 1),
                et("cf2", t, e, Qe, n, 0, 1),
                et("cf3", t, e, Qe, 0, -i, 1),
                et("cf4", t, e, Qe, 0, i, 1),
                et("cn1", t, e, Qe, -n, 0, -1),
                et("cn2", t, e, Qe, n, 0, -1),
                et("cn3", t, e, Qe, 0, -i, -1),
                et("cn4", t, e, Qe, 0, i, -1),
                (e.getAttribute("position").needsUpdate = !0);
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    };
function et(r, e, t, n, i, s, o) {
    Or.set(i, s, o).unproject(n);
    let a = e[r];
    if (a !== void 0) {
        let l = t.getAttribute("position");
        for (let c = 0, h = a.length; c < h; c++)
            l.setXYZ(a[c], Or.x, Or.y, Or.z);
    }
}
var Hr = new Tt(),
    Pl = class extends bt {
        constructor(e, t = 16776960) {
            let n = new Uint16Array([
                    0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5,
                    2, 6, 3, 7,
                ]),
                i = new Float32Array(8 * 3),
                s = new _e();
            s.setIndex(new ze(n, 1)),
                s.setAttribute("position", new ze(i, 3)),
                super(s, new ht({ color: t, toneMapped: !1 })),
                (this.object = e),
                (this.type = "BoxHelper"),
                (this.matrixAutoUpdate = !1),
                this.update();
        }
        update(e) {
            if (
                (e !== void 0 &&
                    console.warn(
                        "THREE.BoxHelper: .update() has no longer arguments."
                    ),
                this.object !== void 0 && Hr.setFromObject(this.object),
                Hr.isEmpty())
            )
                return;
            let t = Hr.min,
                n = Hr.max,
                i = this.geometry.attributes.position,
                s = i.array;
            (s[0] = n.x),
                (s[1] = n.y),
                (s[2] = n.z),
                (s[3] = t.x),
                (s[4] = n.y),
                (s[5] = n.z),
                (s[6] = t.x),
                (s[7] = t.y),
                (s[8] = n.z),
                (s[9] = n.x),
                (s[10] = t.y),
                (s[11] = n.z),
                (s[12] = n.x),
                (s[13] = n.y),
                (s[14] = t.z),
                (s[15] = t.x),
                (s[16] = n.y),
                (s[17] = t.z),
                (s[18] = t.x),
                (s[19] = t.y),
                (s[20] = t.z),
                (s[21] = n.x),
                (s[22] = t.y),
                (s[23] = t.z),
                (i.needsUpdate = !0),
                this.geometry.computeBoundingSphere();
        }
        setFromObject(e) {
            return (this.object = e), this.update(), this;
        }
        copy(e) {
            return (
                bt.prototype.copy.call(this, e), (this.object = e.object), this
            );
        }
    },
    qh = class extends bt {
        constructor(e, t = 16776960) {
            let n = new Uint16Array([
                    0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5,
                    2, 6, 3, 7,
                ]),
                i = [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                ],
                s = new _e();
            s.setIndex(new ze(n, 1)),
                s.setAttribute("position", new de(i, 3)),
                super(s, new ht({ color: t, toneMapped: !1 })),
                (this.box = e),
                (this.type = "Box3Helper"),
                this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(e) {
            let t = this.box;
            t.isEmpty() ||
                (t.getCenter(this.position),
                t.getSize(this.scale),
                this.scale.multiplyScalar(0.5),
                super.updateMatrixWorld(e));
        }
    },
    Xh = class extends $t {
        constructor(e, t = 1, n = 16776960) {
            let i = n,
                s = [
                    1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
                    1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                ],
                o = new _e();
            o.setAttribute("position", new de(s, 3)),
                o.computeBoundingSphere(),
                super(o, new ht({ color: i, toneMapped: !1 })),
                (this.type = "PlaneHelper"),
                (this.plane = e),
                (this.size = t);
            let a = [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1,
                ],
                l = new _e();
            l.setAttribute("position", new de(a, 3)),
                l.computeBoundingSphere(),
                this.add(
                    new nt(
                        l,
                        new Yt({
                            color: i,
                            opacity: 0.2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1,
                        })
                    )
                );
        }
        updateMatrixWorld(e) {
            let t = -this.plane.constant;
            Math.abs(t) < 1e-8 && (t = 1e-8),
                this.scale.set(0.5 * this.size, 0.5 * this.size, t),
                (this.children[0].material.side = t < 0 ? it : Ci),
                this.lookAt(this.plane.normal),
                super.updateMatrixWorld(e);
        }
    },
    Jh = new M(),
    kr,
    La,
    Yh = class extends Be {
        constructor(
            e = new M(0, 0, 1),
            t = new M(0, 0, 0),
            n = 1,
            i = 16776960,
            s = n * 0.2,
            o = s * 0.2
        ) {
            super(),
                (this.type = "ArrowHelper"),
                kr === void 0 &&
                    ((kr = new _e()),
                    kr.setAttribute("position", new de([0, 0, 0, 0, 1, 0], 3)),
                    (La = new Ui(0, 0.5, 1, 5, 1)),
                    La.translate(0, -0.5, 0)),
                this.position.copy(t),
                (this.line = new $t(kr, new ht({ color: i, toneMapped: !1 }))),
                (this.line.matrixAutoUpdate = !1),
                this.add(this.line),
                (this.cone = new nt(La, new Yt({ color: i, toneMapped: !1 }))),
                (this.cone.matrixAutoUpdate = !1),
                this.add(this.cone),
                this.setDirection(e),
                this.setLength(n, s, o);
        }
        setDirection(e) {
            if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
            else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
            else {
                Jh.set(e.z, 0, -e.x).normalize();
                let t = Math.acos(e.y);
                this.quaternion.setFromAxisAngle(Jh, t);
            }
        }
        setLength(e, t = e * 0.2, n = t * 0.2) {
            this.line.scale.set(1, Math.max(1e-4, e - t), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(n, t, n),
                (this.cone.position.y = e),
                this.cone.updateMatrix();
        }
        setColor(e) {
            this.line.material.color.set(e), this.cone.material.color.set(e);
        }
        copy(e) {
            return (
                super.copy(e, !1),
                this.line.copy(e.line),
                this.cone.copy(e.cone),
                this
            );
        }
    },
    Il = class extends bt {
        constructor(e = 1) {
            let t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                n = [
                    1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1,
                ],
                i = new _e();
            i.setAttribute("position", new de(t, 3)),
                i.setAttribute("color", new de(n, 3));
            let s = new ht({ vertexColors: !0, toneMapped: !1 });
            super(i, s), (this.type = "AxesHelper");
        }
        setColors(e, t, n) {
            let i = new re(),
                s = this.geometry.attributes.color.array;
            return (
                i.set(e),
                i.toArray(s, 0),
                i.toArray(s, 3),
                i.set(t),
                i.toArray(s, 6),
                i.toArray(s, 9),
                i.set(n),
                i.toArray(s, 12),
                i.toArray(s, 15),
                (this.geometry.attributes.color.needsUpdate = !0),
                this
            );
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose();
        }
    },
    Zh = class {
        constructor() {
            (this.type = "ShapePath"),
                (this.color = new re()),
                (this.subPaths = []),
                (this.currentPath = null);
        }
        moveTo(e, t) {
            return (
                (this.currentPath = new ki()),
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(e, t),
                this
            );
        }
        lineTo(e, t) {
            return this.currentPath.lineTo(e, t), this;
        }
        quadraticCurveTo(e, t, n, i) {
            return this.currentPath.quadraticCurveTo(e, t, n, i), this;
        }
        bezierCurveTo(e, t, n, i, s, o) {
            return this.currentPath.bezierCurveTo(e, t, n, i, s, o), this;
        }
        splineThru(e) {
            return this.currentPath.splineThru(e), this;
        }
        toShapes(e, t) {
            function n(p) {
                let _ = [];
                for (let y = 0, w = p.length; y < w; y++) {
                    let A = p[y],
                        C = new Ut();
                    (C.curves = A.curves), _.push(C);
                }
                return _;
            }
            function i(p, _) {
                let y = _.length,
                    w = !1;
                for (let A = y - 1, C = 0; C < y; A = C++) {
                    let I = _[A],
                        k = _[C],
                        z = k.x - I.x,
                        P = k.y - I.y;
                    if (Math.abs(P) > Number.EPSILON) {
                        if (
                            (P < 0 &&
                                ((I = _[C]), (z = -z), (k = _[A]), (P = -P)),
                            p.y < I.y || p.y > k.y)
                        )
                            continue;
                        if (p.y === I.y) {
                            if (p.x === I.x) return !0;
                        } else {
                            let b = P * (p.x - I.x) - z * (p.y - I.y);
                            if (b === 0) return !0;
                            if (b < 0) continue;
                            w = !w;
                        }
                    } else {
                        if (p.y !== I.y) continue;
                        if (
                            (k.x <= p.x && p.x <= I.x) ||
                            (I.x <= p.x && p.x <= k.x)
                        )
                            return !0;
                    }
                }
                return w;
            }
            let s = ln.isClockWise,
                o = this.subPaths;
            if (o.length === 0) return [];
            if (t === !0) return n(o);
            let a,
                l,
                c,
                h = [];
            if (o.length === 1)
                return (
                    (l = o[0]),
                    (c = new Ut()),
                    (c.curves = l.curves),
                    h.push(c),
                    h
                );
            let u = !s(o[0].getPoints());
            u = e ? !u : u;
            let d = [],
                f = [],
                m = [],
                x = 0,
                v;
            (f[x] = void 0), (m[x] = []);
            for (let p = 0, _ = o.length; p < _; p++)
                (l = o[p]),
                    (v = l.getPoints()),
                    (a = s(v)),
                    (a = e ? !a : a),
                    a
                        ? (!u && f[x] && x++,
                          (f[x] = { s: new Ut(), p: v }),
                          (f[x].s.curves = l.curves),
                          u && x++,
                          (m[x] = []))
                        : m[x].push({ h: l, p: v[0] });
            if (!f[0]) return n(o);
            if (f.length > 1) {
                let p = !1,
                    _ = [];
                for (let y = 0, w = f.length; y < w; y++) d[y] = [];
                for (let y = 0, w = f.length; y < w; y++) {
                    let A = m[y];
                    for (let C = 0; C < A.length; C++) {
                        let I = A[C],
                            k = !0;
                        for (let z = 0; z < f.length; z++)
                            i(I.p, f[z].p) &&
                                (y !== z &&
                                    _.push({ froms: y, tos: z, hole: C }),
                                k ? ((k = !1), d[z].push(I)) : (p = !0));
                        k && d[y].push(I);
                    }
                }
                _.length > 0 && (p || (m = d));
            }
            let g;
            for (let p = 0, _ = f.length; p < _; p++) {
                (c = f[p].s), h.push(c), (g = m[p]);
                for (let y = 0, w = g.length; y < w; y++) c.holes.push(g[y].h);
            }
            return h;
        }
    },
    Tu = new Float32Array(1),
    ky = new Int32Array(Tu.buffer),
    $h = class {
        static toHalfFloat(e) {
            e > 65504 &&
                (console.warn(
                    "THREE.DataUtils.toHalfFloat(): value exceeds 65504."
                ),
                (e = 65504)),
                (Tu[0] = e);
            let t = ky[0],
                n = (t >> 16) & 32768,
                i = (t >> 12) & 2047,
                s = (t >> 23) & 255;
            return s < 103
                ? n
                : s > 142
                ? ((n |= 31744), (n |= (s == 255 ? 0 : 1) && t & 8388607), n)
                : s < 113
                ? ((i |= 2048),
                  (n |= (i >> (114 - s)) + ((i >> (113 - s)) & 1)),
                  n)
                : ((n |= ((s - 112) << 10) | (i >> 1)), (n += i & 1), n);
        }
    },
    w0 = 0,
    b0 = 1,
    S0 = 0,
    T0 = 1,
    E0 = 2;
function A0(r) {
    return (
        console.warn(
            "THREE.MeshFaceMaterial has been removed. Use an Array instead."
        ),
        r
    );
}
function R0(r = []) {
    return (
        console.warn(
            "THREE.MultiMaterial has been removed. Use an Array instead."
        ),
        (r.isMultiMaterial = !0),
        (r.materials = r),
        (r.clone = function () {
            return r.slice();
        }),
        r
    );
}
function C0(r, e) {
    return (
        console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new Bi(r, e)
    );
}
function L0(r) {
    return (
        console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new Ns(r)
    );
}
function P0(r, e) {
    return (
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new Bi(r, e)
    );
}
function I0(r) {
    return (
        console.warn(
            "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Cn(r)
    );
}
function D0(r) {
    return (
        console.warn(
            "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Cn(r)
    );
}
function F0(r) {
    return (
        console.warn(
            "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Cn(r)
    );
}
function N0(r, e, t) {
    return (
        console.warn(
            "THREE.Vertex has been removed. Use THREE.Vector3 instead."
        ),
        new M(r, e, t)
    );
}
function z0(r, e) {
    return (
        console.warn(
            "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
        ),
        new ze(r, e).setUsage(_s)
    );
}
function B0(r, e) {
    return (
        console.warn(
            "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
        ),
        new za(r, e)
    );
}
function U0(r, e) {
    return (
        console.warn(
            "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
        ),
        new Ba(r, e)
    );
}
function O0(r, e) {
    return (
        console.warn(
            "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
        ),
        new Ua(r, e)
    );
}
function H0(r, e) {
    return (
        console.warn(
            "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
        ),
        new Oa(r, e)
    );
}
function k0(r, e) {
    return (
        console.warn(
            "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
        ),
        new Ss(r, e)
    );
}
function V0(r, e) {
    return (
        console.warn(
            "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
        ),
        new Ha(r, e)
    );
}
function G0(r, e) {
    return (
        console.warn(
            "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
        ),
        new Ts(r, e)
    );
}
function W0(r, e) {
    return (
        console.warn(
            "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
        ),
        new de(r, e)
    );
}
function q0(r, e) {
    return (
        console.warn(
            "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
        ),
        new Va(r, e)
    );
}
Et.create = function (r, e) {
    return (
        console.log("THREE.Curve.create() has been deprecated"),
        (r.prototype = Object.create(Et.prototype)),
        (r.prototype.constructor = r),
        (r.prototype.getPoint = e),
        r
    );
};
ki.prototype.fromPoints = function (r) {
    return (
        console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
        ),
        this.setFromPoints(r)
    );
};
function X0(r) {
    return (
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new Il(r)
    );
}
function J0(r, e) {
    return (
        console.warn(
            "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
        ),
        new Pl(r, e)
    );
}
function Y0(r, e) {
    return (
        console.warn(
            "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
        ),
        new bt(
            new ao(r.geometry),
            new ht({ color: e !== void 0 ? e : 16777215 })
        )
    );
}
Ll.prototype.setColors = function () {
    console.error(
        "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
};
Cl.prototype.update = function () {
    console.error(
        "THREE.SkeletonHelper: update() no longer needs to be called."
    );
};
function Z0(r, e) {
    return (
        console.warn(
            "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
        ),
        new bt(
            new vo(r.geometry),
            new ht({ color: e !== void 0 ? e : 16777215 })
        )
    );
}
Mt.prototype.extractUrlBase = function (r) {
    return (
        console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
        ),
        $s.extractUrlBase(r)
    );
};
Mt.Handlers = {
    add: function () {
        console.error(
            "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
        );
    },
    get: function () {
        console.error(
            "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
        );
    },
};
function $0(r) {
    return (
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new Ht(r)
    );
}
function j0(r) {
    return (
        console.warn(
            "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
        ),
        new cl(r)
    );
}
ti.prototype.center = function (r) {
    return (
        console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
        this.getCenter(r)
    );
};
ti.prototype.empty = function () {
    return (
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    );
};
ti.prototype.isIntersectionBox = function (r) {
    return (
        console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
        ),
        this.intersectsBox(r)
    );
};
ti.prototype.size = function (r) {
    return (
        console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
        this.getSize(r)
    );
};
Tt.prototype.center = function (r) {
    return (
        console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
        this.getCenter(r)
    );
};
Tt.prototype.empty = function () {
    return (
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    );
};
Tt.prototype.isIntersectionBox = function (r) {
    return (
        console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
        ),
        this.intersectsBox(r)
    );
};
Tt.prototype.isIntersectionSphere = function (r) {
    return (
        console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
        ),
        this.intersectsSphere(r)
    );
};
Tt.prototype.size = function (r) {
    return (
        console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
        this.getSize(r)
    );
};
hn.prototype.empty = function () {
    return (
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    );
};
Ni.prototype.setFromMatrix = function (r) {
    return (
        console.warn(
            "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
        ),
        this.setFromProjectionMatrix(r)
    );
};
Rl.prototype.center = function (r) {
    return (
        console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
        ),
        this.getCenter(r)
    );
};
rt.prototype.flattenToArrayOffset = function (r, e) {
    return (
        console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
        ),
        this.toArray(r, e)
    );
};
rt.prototype.multiplyVector3 = function (r) {
    return (
        console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
        ),
        r.applyMatrix3(this)
    );
};
rt.prototype.multiplyVector3Array = function () {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
rt.prototype.applyToBufferAttribute = function (r) {
    return (
        console.warn(
            "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
        ),
        r.applyMatrix3(this)
    );
};
rt.prototype.applyToVector3Array = function () {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
rt.prototype.getInverse = function (r) {
    return (
        console.warn(
            "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
        ),
        this.copy(r).invert()
    );
};
me.prototype.extractPosition = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
        ),
        this.copyPosition(r)
    );
};
me.prototype.flattenToArrayOffset = function (r, e) {
    return (
        console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
        ),
        this.toArray(r, e)
    );
};
me.prototype.getPosition = function () {
    return (
        console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
        ),
        new M().setFromMatrixColumn(this, 3)
    );
};
me.prototype.setRotationFromQuaternion = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
        ),
        this.makeRotationFromQuaternion(r)
    );
};
me.prototype.multiplyToArray = function () {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
me.prototype.multiplyVector3 = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
        ),
        r.applyMatrix4(this)
    );
};
me.prototype.multiplyVector4 = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
        ),
        r.applyMatrix4(this)
    );
};
me.prototype.multiplyVector3Array = function () {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
me.prototype.rotateAxis = function (r) {
    console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
    ),
        r.transformDirection(this);
};
me.prototype.crossVector = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
        ),
        r.applyMatrix4(this)
    );
};
me.prototype.translate = function () {
    console.error("THREE.Matrix4: .translate() has been removed.");
};
me.prototype.rotateX = function () {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
};
me.prototype.rotateY = function () {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
};
me.prototype.rotateZ = function () {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
me.prototype.rotateByAxis = function () {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
me.prototype.applyToBufferAttribute = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
        ),
        r.applyMatrix4(this)
    );
};
me.prototype.applyToVector3Array = function () {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
me.prototype.makeFrustum = function (r, e, t, n, i, s) {
    return (
        console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
        ),
        this.makePerspective(r, e, n, t, i, s)
    );
};
me.prototype.getInverse = function (r) {
    return (
        console.warn(
            "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
        ),
        this.copy(r).invert()
    );
};
Bt.prototype.isIntersectionLine = function (r) {
    return (
        console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
        ),
        this.intersectsLine(r)
    );
};
dt.prototype.multiplyVector3 = function (r) {
    return (
        console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
        ),
        r.applyQuaternion(this)
    );
};
dt.prototype.inverse = function () {
    return (
        console.warn(
            "THREE.Quaternion: .inverse() has been renamed to invert()."
        ),
        this.invert()
    );
};
un.prototype.isIntersectionBox = function (r) {
    return (
        console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
        ),
        this.intersectsBox(r)
    );
};
un.prototype.isIntersectionPlane = function (r) {
    return (
        console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
        ),
        this.intersectsPlane(r)
    );
};
un.prototype.isIntersectionSphere = function (r) {
    return (
        console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
        ),
        this.intersectsSphere(r)
    );
};
vt.prototype.area = function () {
    return (
        console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
        this.getArea()
    );
};
vt.prototype.barycoordFromPoint = function (r, e) {
    return (
        console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
        ),
        this.getBarycoord(r, e)
    );
};
vt.prototype.midpoint = function (r) {
    return (
        console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
        ),
        this.getMidpoint(r)
    );
};
vt.prototypenormal = function (r) {
    return (
        console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
        ),
        this.getNormal(r)
    );
};
vt.prototype.plane = function (r) {
    return (
        console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane()."
        ),
        this.getPlane(r)
    );
};
vt.barycoordFromPoint = function (r, e, t, n, i) {
    return (
        console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
        ),
        vt.getBarycoord(r, e, t, n, i)
    );
};
vt.normal = function (r, e, t, n) {
    return (
        console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal()."
        ),
        vt.getNormal(r, e, t, n)
    );
};
Ut.prototype.extractAllPoints = function (r) {
    return (
        console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
        ),
        this.extractPoints(r)
    );
};
Ut.prototype.extrude = function (r) {
    return (
        console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
        ),
        new In(this, r)
    );
};
Ut.prototype.makeGeometry = function (r) {
    return (
        console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
        ),
        new Xs(this, r)
    );
};
W.prototype.fromAttribute = function (r, e, t) {
    return (
        console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
        ),
        this.fromBufferAttribute(r, e, t)
    );
};
W.prototype.distanceToManhattan = function (r) {
    return (
        console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
        ),
        this.manhattanDistanceTo(r)
    );
};
W.prototype.lengthManhattan = function () {
    return (
        console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
        ),
        this.manhattanLength()
    );
};
M.prototype.setEulerFromRotationMatrix = function () {
    console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
    );
};
M.prototype.setEulerFromQuaternion = function () {
    console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
    );
};
M.prototype.getPositionFromMatrix = function (r) {
    return (
        console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
        ),
        this.setFromMatrixPosition(r)
    );
};
M.prototype.getScaleFromMatrix = function (r) {
    return (
        console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
        ),
        this.setFromMatrixScale(r)
    );
};
M.prototype.getColumnFromMatrix = function (r, e) {
    return (
        console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
        ),
        this.setFromMatrixColumn(e, r)
    );
};
M.prototype.applyProjection = function (r) {
    return (
        console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
        ),
        this.applyMatrix4(r)
    );
};
M.prototype.fromAttribute = function (r, e, t) {
    return (
        console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
        ),
        this.fromBufferAttribute(r, e, t)
    );
};
M.prototype.distanceToManhattan = function (r) {
    return (
        console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
        ),
        this.manhattanDistanceTo(r)
    );
};
M.prototype.lengthManhattan = function () {
    return (
        console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
        ),
        this.manhattanLength()
    );
};
Ve.prototype.fromAttribute = function (r, e, t) {
    return (
        console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
        ),
        this.fromBufferAttribute(r, e, t)
    );
};
Ve.prototype.lengthManhattan = function () {
    return (
        console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
        ),
        this.manhattanLength()
    );
};
Be.prototype.getChildByName = function (r) {
    return (
        console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
        ),
        this.getObjectByName(r)
    );
};
Be.prototype.renderDepth = function () {
    console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
    );
};
Be.prototype.translate = function (r, e) {
    return (
        console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
        ),
        this.translateOnAxis(e, r)
    );
};
Be.prototype.getWorldRotation = function () {
    console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
    );
};
Be.prototype.applyMatrix = function (r) {
    return (
        console.warn(
            "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(r)
    );
};
Object.defineProperties(Be.prototype, {
    eulerOrder: {
        get: function () {
            return (
                console.warn(
                    "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                this.rotation.order
            );
        },
        set: function (r) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                (this.rotation.order = r);
        },
    },
    useQuaternion: {
        get: function () {
            console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
        },
        set: function () {
            console.warn(
                "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
        },
    },
});
nt.prototype.setDrawMode = function () {
    console.error(
        "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
    );
};
Object.defineProperties(nt.prototype, {
    drawMode: {
        get: function () {
            return (
                console.error(
                    "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                ),
                ef
            );
        },
        set: function () {
            console.error(
                "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
        },
    },
});
zs.prototype.initBones = function () {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
at.prototype.setLens = function (r, e) {
    console.warn(
        "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    ),
        e !== void 0 && (this.filmGauge = e),
        this.setFocalLength(r);
};
Object.defineProperties(It.prototype, {
    onlyShadow: {
        set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        },
    },
    shadowCameraFov: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
                (this.shadow.camera.fov = r);
        },
    },
    shadowCameraLeft: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
                (this.shadow.camera.left = r);
        },
    },
    shadowCameraRight: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
                (this.shadow.camera.right = r);
        },
    },
    shadowCameraTop: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
                (this.shadow.camera.top = r);
        },
    },
    shadowCameraBottom: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
                (this.shadow.camera.bottom = r);
        },
    },
    shadowCameraNear: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
                (this.shadow.camera.near = r);
        },
    },
    shadowCameraFar: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
                (this.shadow.camera.far = r);
        },
    },
    shadowCameraVisible: {
        set: function () {
            console.warn(
                "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
        },
    },
    shadowBias: {
        set: function (r) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                (this.shadow.bias = r);
        },
    },
    shadowDarkness: {
        set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        },
    },
    shadowMapWidth: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
                (this.shadow.mapSize.width = r);
        },
    },
    shadowMapHeight: {
        set: function (r) {
            console.warn(
                "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
                (this.shadow.mapSize.height = r);
        },
    },
});
Object.defineProperties(ze.prototype, {
    length: {
        get: function () {
            return (
                console.warn(
                    "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                ),
                this.array.length
            );
        },
    },
    dynamic: {
        get: function () {
            return (
                console.warn(
                    "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                this.usage === _s
            );
        },
        set: function () {
            console.warn(
                "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
            ),
                this.setUsage(_s);
        },
    },
});
ze.prototype.setDynamic = function (r) {
    return (
        console.warn(
            "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
        ),
        this.setUsage(r === !0 ? _s : vs),
        this
    );
};
(ze.prototype.copyIndicesArray = function () {
    console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
    );
}),
    (ze.prototype.setArray = function () {
        console.error(
            "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
        );
    });
_e.prototype.addIndex = function (r) {
    console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
    ),
        this.setIndex(r);
};
_e.prototype.addAttribute = function (r, e) {
    return (
        console.warn(
            "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
        ),
        !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
            ? (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
              ),
              this.setAttribute(r, new ze(arguments[1], arguments[2])))
            : r === "index"
            ? (console.warn(
                  "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(r, e)
    );
};
_e.prototype.addDrawCall = function (r, e, t) {
    t !== void 0 &&
        console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
        ),
        console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
        ),
        this.addGroup(r, e);
};
_e.prototype.clearDrawCalls = function () {
    console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
    ),
        this.clearGroups();
};
_e.prototype.computeOffsets = function () {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
_e.prototype.removeAttribute = function (r) {
    return (
        console.warn(
            "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
        ),
        this.deleteAttribute(r)
    );
};
_e.prototype.applyMatrix = function (r) {
    return (
        console.warn(
            "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(r)
    );
};
Object.defineProperties(_e.prototype, {
    drawcalls: {
        get: function () {
            return (
                console.error(
                    "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                ),
                this.groups
            );
        },
    },
    offsets: {
        get: function () {
            return (
                console.warn(
                    "THREE.BufferGeometry: .offsets has been renamed to .groups."
                ),
                this.groups
            );
        },
    },
});
An.prototype.setDynamic = function (r) {
    return (
        console.warn(
            "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
        ),
        this.setUsage(r === !0 ? _s : vs),
        this
    );
};
An.prototype.setArray = function () {
    console.error(
        "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
    );
};
In.prototype.getArrays = function () {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
In.prototype.addShapeList = function () {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
In.prototype.addShape = function () {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Ds.prototype.dispose = function () {
    console.error("THREE.Scene: .dispose() has been removed.");
};
Sl.prototype.onUpdate = function () {
    return (
        console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
        ),
        this
    );
};
Object.defineProperties(ct.prototype, {
    wrapAround: {
        get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
        },
    },
    overdraw: {
        get: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function () {
            console.warn("THREE.Material: .overdraw has been removed.");
        },
    },
    wrapRGB: {
        get: function () {
            return (
                console.warn("THREE.Material: .wrapRGB has been removed."),
                new re()
            );
        },
    },
    shading: {
        get: function () {
            console.error(
                "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
            );
        },
        set: function (r) {
            console.warn(
                "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
            ),
                (this.flatShading = r === Qh);
        },
    },
    stencilMask: {
        get: function () {
            return (
                console.warn(
                    "THREE." +
                        this.type +
                        ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                this.stencilFuncMask
            );
        },
        set: function (r) {
            console.warn(
                "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
            ),
                (this.stencilFuncMask = r);
        },
    },
    vertexTangents: {
        get: function () {
            console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
            );
        },
        set: function () {
            console.warn(
                "THREE." + this.type + ": .vertexTangents has been removed."
            );
        },
    },
});
Object.defineProperties(Zt.prototype, {
    derivatives: {
        get: function () {
            return (
                console.warn(
                    "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                this.extensions.derivatives
            );
        },
        set: function (r) {
            console.warn(
                "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
                (this.extensions.derivatives = r);
        },
    },
});
qe.prototype.clearTarget = function (r, e, t, n) {
    console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
    ),
        this.setRenderTarget(r),
        this.clear(e, t, n);
};
qe.prototype.animate = function (r) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
        this.setAnimationLoop(r);
};
qe.prototype.getCurrentRenderTarget = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
        ),
        this.getRenderTarget()
    );
};
qe.prototype.getMaxAnisotropy = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
        ),
        this.capabilities.getMaxAnisotropy()
    );
};
qe.prototype.getPrecision = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
        ),
        this.capabilities.precision
    );
};
qe.prototype.resetGLState = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
        ),
        this.state.reset()
    );
};
qe.prototype.supportsFloatTextures = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
        ),
        this.extensions.get("OES_texture_float")
    );
};
qe.prototype.supportsHalfFloatTextures = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
        ),
        this.extensions.get("OES_texture_half_float")
    );
};
qe.prototype.supportsStandardDerivatives = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
        ),
        this.extensions.get("OES_standard_derivatives")
    );
};
qe.prototype.supportsCompressedTextureS3TC = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
        ),
        this.extensions.get("WEBGL_compressed_texture_s3tc")
    );
};
qe.prototype.supportsCompressedTexturePVRTC = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
        ),
        this.extensions.get("WEBGL_compressed_texture_pvrtc")
    );
};
qe.prototype.supportsBlendMinMax = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
        ),
        this.extensions.get("EXT_blend_minmax")
    );
};
qe.prototype.supportsVertexTextures = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
        ),
        this.capabilities.vertexTextures
    );
};
qe.prototype.supportsInstancedArrays = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
        ),
        this.extensions.get("ANGLE_instanced_arrays")
    );
};
qe.prototype.enableScissorTest = function (r) {
    console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
    ),
        this.setScissorTest(r);
};
qe.prototype.initMaterial = function () {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
qe.prototype.addPrePlugin = function () {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
qe.prototype.addPostPlugin = function () {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
qe.prototype.updateShadowMap = function () {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
qe.prototype.setFaceCulling = function () {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
qe.prototype.allocTextureUnit = function () {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
qe.prototype.setTexture = function () {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
qe.prototype.setTexture2D = function () {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
qe.prototype.setTextureCube = function () {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
qe.prototype.getActiveMipMapLevel = function () {
    return (
        console.warn(
            "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
        ),
        this.getActiveMipmapLevel()
    );
};
Object.defineProperties(qe.prototype, {
    shadowMapEnabled: {
        get: function () {
            return this.shadowMap.enabled;
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
                (this.shadowMap.enabled = r);
        },
    },
    shadowMapType: {
        get: function () {
            return this.shadowMap.type;
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
                (this.shadowMap.type = r);
        },
    },
    shadowMapCullFace: {
        get: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
        },
        set: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
            );
        },
    },
    context: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                ),
                this.getContext()
            );
        },
    },
    vr: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderer: .vr has been renamed to .xr"
                ),
                this.xr
            );
        },
    },
    gammaInput: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                ),
                !1
            );
        },
        set: function () {
            console.warn(
                "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
            );
        },
    },
    gammaOutput: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                !1
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
            ),
                (this.outputEncoding = r === !0 ? ji : Ot);
        },
    },
    toneMappingWhitePoint: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                ),
                1
            );
        },
        set: function () {
            console.warn(
                "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
            );
        },
    },
    gammaFactor: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderer: .gammaFactor has been removed."
                ),
                2
            );
        },
        set: function () {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        },
    },
});
Object.defineProperties(yu.prototype, {
    cullFace: {
        get: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
        },
        set: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
            );
        },
    },
    renderReverseSided: {
        get: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
        },
        set: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
            );
        },
    },
    renderSingleSided: {
        get: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
        },
        set: function () {
            console.warn(
                "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
            );
        },
    },
});
function Q0(r, e, t) {
    return (
        console.warn(
            "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
        ),
        new As(r, t)
    );
}
Object.defineProperties(St.prototype, {
    wrapS: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                this.texture.wrapS
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
                (this.texture.wrapS = r);
        },
    },
    wrapT: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                this.texture.wrapT
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
                (this.texture.wrapT = r);
        },
    },
    magFilter: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                this.texture.magFilter
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
                (this.texture.magFilter = r);
        },
    },
    minFilter: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                this.texture.minFilter
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
                (this.texture.minFilter = r);
        },
    },
    anisotropy: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                this.texture.anisotropy
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
                (this.texture.anisotropy = r);
        },
    },
    offset: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                this.texture.offset
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
                (this.texture.offset = r);
        },
    },
    repeat: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                this.texture.repeat
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
                (this.texture.repeat = r);
        },
    },
    format: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                this.texture.format
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
                (this.texture.format = r);
        },
    },
    type: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                this.texture.type
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
                (this.texture.type = r);
        },
    },
    generateMipmaps: {
        get: function () {
            return (
                console.warn(
                    "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                this.texture.generateMipmaps
            );
        },
        set: function (r) {
            console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
                (this.texture.generateMipmaps = r);
        },
    },
});
Vo.prototype.load = function (r) {
    console.warn(
        "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
    );
    let e = this;
    return (
        new pl().load(r, function (n) {
            e.setBuffer(n);
        }),
        this
    );
};
yl.prototype.getData = function () {
    return (
        console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
        ),
        this.getFrequencyData()
    );
};
Es.prototype.updateCubeMap = function (r, e) {
    return (
        console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(r, e)
    );
};
Es.prototype.clear = function (r, e, t, n) {
    return (
        console.warn(
            "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
        ),
        this.renderTarget.clear(r, e, t, n)
    );
};
En.crossOrigin = void 0;
En.loadTexture = function (r, e, t, n) {
    console.warn(
        "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    let i = new hl();
    i.setCrossOrigin(this.crossOrigin);
    let s = i.load(r, t, void 0, n);
    return e && (s.mapping = e), s;
};
En.loadTextureCube = function (r, e, t, n) {
    console.warn(
        "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    let i = new ll();
    i.setCrossOrigin(this.crossOrigin);
    let s = i.load(r, t, void 0, n);
    return e && (s.mapping = e), s;
};
En.loadCompressedTexture = function () {
    console.error(
        "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
};
En.loadCompressedTextureCube = function () {
    console.error(
        "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
};
function K0() {
    console.error("THREE.CanvasRenderer has been removed");
}
function ev() {
    console.error("THREE.JSONLoader has been removed.");
}
var tv = {
    createMultiMaterialObject: function () {
        console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
        );
    },
    detach: function () {
        console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
        );
    },
    attach: function () {
        console.error(
            "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
        );
    },
};
function nv() {
    console.error(
        "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
    );
}
function iv() {
    return (
        console.error(
            "THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"
        ),
        new _e()
    );
}
function sv() {
    return (
        console.error(
            "THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"
        ),
        new _e()
    );
}
function rv() {
    console.error(
        "THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js"
    );
}
function ov() {
    console.error(
        "THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js"
    );
}
function av() {
    console.error("THREE.ImmediateRenderObject has been removed.");
}
typeof __THREE_DEVTOOLS__ < "u" &&
    __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: Dl } })
    );
typeof window < "u" &&
    (window.__THREE__
        ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
          )
        : (window.__THREE__ = Dl));
export {
    sd as ACESFilmicToneMapping,
    wi as AddEquation,
    ed as AddOperation,
    nu as AdditiveAnimationBlendMode,
    Jl as AdditiveBlending,
    dd as AlphaFormat,
    Ju as AlwaysDepth,
    rf as AlwaysStencilFunc,
    Uo as AmbientLight,
    gl as AmbientLightProbe,
    Wi as AnimationClip,
    uh as AnimationLoader,
    bl as AnimationMixer,
    Ml as AnimationObjectGroup,
    Ze as AnimationUtils,
    lo as ArcCurve,
    Qr as ArrayCamera,
    Yh as ArrowHelper,
    Vo as Audio,
    yl as AudioAnalyser,
    bu as AudioContext,
    Th as AudioListener,
    pl as AudioLoader,
    Il as AxesHelper,
    X0 as AxisHelper,
    it as BackSide,
    tf as BasicDepthPacking,
    qy as BasicShadowMap,
    j0 as BinaryTextureLoader,
    Bs as Bone,
    Dn as BooleanKeyframeTrack,
    J0 as BoundingBoxHelper,
    ti as Box2,
    Tt as Box3,
    qh as Box3Helper,
    $n as BoxBufferGeometry,
    $n as BoxGeometry,
    Pl as BoxHelper,
    ze as BufferAttribute,
    _e as BufferGeometry,
    dl as BufferGeometryLoader,
    od as ByteType,
    qi as Cache,
    Fi as Camera,
    Wh as CameraHelper,
    K0 as CanvasRenderer,
    el as CanvasTexture,
    co as CatmullRomCurve3,
    id as CineonToneMapping,
    so as CircleBufferGeometry,
    so as CircleGeometry,
    yt as ClampToEdgeWrapping,
    xl as Clock,
    re as Color,
    Co as ColorKeyframeTrack,
    io as CompressedTexture,
    dh as CompressedTextureLoader,
    ro as ConeBufferGeometry,
    ro as ConeGeometry,
    Es as CubeCamera,
    Yi as CubeReflectionMapping,
    Zi as CubeRefractionMapping,
    jn as CubeTexture,
    ll as CubeTextureLoader,
    js as CubeUVReflectionMapping,
    Wo as CubeUVRefractionMapping,
    Us as CubicBezierCurve,
    ho as CubicBezierCurve3,
    rl as CubicInterpolant,
    Xl as CullFaceBack,
    Iu as CullFaceFront,
    Wy as CullFaceFrontBack,
    Pu as CullFaceNone,
    Et as Curve,
    nl as CurvePath,
    Fu as CustomBlending,
    rd as CustomToneMapping,
    Ui as CylinderBufferGeometry,
    Ui as CylinderGeometry,
    Ph as Cylindrical,
    Tn as DataTexture,
    Cs as DataTexture2DArray,
    jr as DataTexture3D,
    cl as DataTextureLoader,
    $h as DataUtils,
    n0 as DecrementStencilOp,
    s0 as DecrementWrapStencilOp,
    Ry as DefaultLoadingManager,
    Yn as DepthFormat,
    Pi as DepthStencilFormat,
    Is as DepthTexture,
    Bo as DirectionalLight,
    Gh as DirectionalLightHelper,
    ol as DiscreteInterpolant,
    oo as DodecahedronBufferGeometry,
    oo as DodecahedronGeometry,
    Li as DoubleSide,
    ku as DstAlphaFactor,
    Gu as DstColorFactor,
    z0 as DynamicBufferAttribute,
    y0 as DynamicCopyUsage,
    _s as DynamicDrawUsage,
    m0 as DynamicReadUsage,
    ao as EdgesGeometry,
    Y0 as EdgesHelper,
    Oi as EllipseCurve,
    Zu as EqualDepth,
    l0 as EqualStencilFunc,
    Gr as EquirectangularReflectionMapping,
    Wr as EquirectangularRefractionMapping,
    Ii as Euler,
    cn as EventDispatcher,
    In as ExtrudeBufferGeometry,
    In as ExtrudeGeometry,
    T0 as FaceColors,
    Ht as FileLoader,
    Qh as FlatShading,
    ka as Float16BufferAttribute,
    W0 as Float32Attribute,
    de as Float32BufferAttribute,
    q0 as Float64Attribute,
    Va as Float64BufferAttribute,
    on as FloatType,
    eo as Fog,
    Kr as FogExp2,
    ov as Font,
    rv as FontLoader,
    Ka as FramebufferTexture,
    Ci as FrontSide,
    Ni as Frustum,
    El as GLBufferAttribute,
    _0 as GLSL1,
    lc as GLSL3,
    ju as GreaterDepth,
    $u as GreaterEqualDepth,
    d0 as GreaterEqualStencilFunc,
    h0 as GreaterStencilFunc,
    Ll as GridHelper,
    _n as Group,
    Xn as HalfFloatType,
    Po as HemisphereLight,
    Oh as HemisphereLightHelper,
    ml as HemisphereLightProbe,
    uo as IcosahedronBufferGeometry,
    uo as IcosahedronGeometry,
    fl as ImageBitmapLoader,
    Xi as ImageLoader,
    En as ImageUtils,
    av as ImmediateRenderObject,
    t0 as IncrementStencilOp,
    i0 as IncrementWrapStencilOp,
    Rn as InstancedBufferAttribute,
    ko as InstancedBufferGeometry,
    Tl as InstancedInterleavedBuffer,
    to as InstancedMesh,
    H0 as Int16Attribute,
    Oa as Int16BufferAttribute,
    V0 as Int32Attribute,
    Ha as Int32BufferAttribute,
    B0 as Int8Attribute,
    za as Int8BufferAttribute,
    ld as IntType,
    An as InterleavedBuffer,
    Kn as InterleavedBufferAttribute,
    jt as Interpolant,
    Jr as InterpolateDiscrete,
    Yr as InterpolateLinear,
    Zo as InterpolateSmooth,
    r0 as InvertStencilOp,
    ev as JSONLoader,
    $o as KeepStencilOp,
    Pt as KeyframeTrack,
    Za as LOD,
    fo as LatheBufferGeometry,
    fo as LatheGeometry,
    bs as Layers,
    nv as LensFlare,
    Yu as LessDepth,
    Pa as LessEqualDepth,
    c0 as LessEqualStencilFunc,
    a0 as LessStencilFunc,
    It as Light,
    Ji as LightProbe,
    $t as Line,
    Rl as Line3,
    ht as LineBasicMaterial,
    Hi as LineCurve,
    tl as LineCurve3,
    Ao as LineDashedMaterial,
    no as LineLoop,
    b0 as LinePieces,
    bt as LineSegments,
    w0 as LineStrip,
    Ot as LinearEncoding,
    tt as LinearFilter,
    Ro as LinearInterpolant,
    $y as LinearMipMapLinearFilter,
    Zy as LinearMipMapNearestFilter,
    $i as LinearMipmapLinearFilter,
    tu as LinearMipmapNearestFilter,
    td as LinearToneMapping,
    Mt as Loader,
    $s as LoaderUtils,
    Lo as LoadingManager,
    jd as LoopOnce,
    Kd as LoopPingPong,
    Qd as LoopRepeat,
    pd as LuminanceAlphaFormat,
    fd as LuminanceFormat,
    Vy as MOUSE,
    ct as Material,
    ul as MaterialLoader,
    M0 as Math,
    M0 as MathUtils,
    rt as Matrix3,
    me as Matrix4,
    jl as MaxEquation,
    nt as Mesh,
    Yt as MeshBasicMaterial,
    Ls as MeshDepthMaterial,
    Ps as MeshDistanceMaterial,
    A0 as MeshFaceMaterial,
    To as MeshLambertMaterial,
    Eo as MeshMatcapMaterial,
    So as MeshNormalMaterial,
    wo as MeshPhongMaterial,
    Mo as MeshPhysicalMaterial,
    Ys as MeshStandardMaterial,
    bo as MeshToonMaterial,
    $l as MinEquation,
    Xr as MirroredRepeatWrapping,
    Ku as MixOperation,
    R0 as MultiMaterial,
    Zl as MultiplyBlending,
    Go as MultiplyOperation,
    st as NearestFilter,
    Yy as NearestMipMapLinearFilter,
    Jy as NearestMipMapNearestFilter,
    Da as NearestMipmapLinearFilter,
    Ia as NearestMipmapNearestFilter,
    Xu as NeverDepth,
    o0 as NeverStencilFunc,
    Mn as NoBlending,
    S0 as NoColors,
    wn as NoToneMapping,
    Nl as NormalAnimationBlendMode,
    fs as NormalBlending,
    Qu as NotEqualDepth,
    u0 as NotEqualStencilFunc,
    Vi as NumberKeyframeTrack,
    Be as Object3D,
    xh as ObjectLoader,
    sf as ObjectSpaceNormalMap,
    qs as OctahedronBufferGeometry,
    qs as OctahedronGeometry,
    Uu as OneFactor,
    Vu as OneMinusDstAlphaFactor,
    Wu as OneMinusDstColorFactor,
    eu as OneMinusSrcAlphaFactor,
    Hu as OneMinusSrcColorFactor,
    zi as OrthographicCamera,
    jh as PCFShadowMap,
    Du as PCFSoftShadowMap,
    Ga as PMREMGenerator,
    iv as ParametricGeometry,
    L0 as Particle,
    D0 as ParticleBasicMaterial,
    P0 as ParticleSystem,
    F0 as ParticleSystemMaterial,
    ki as Path,
    at as PerspectiveCamera,
    Bt as Plane,
    Rs as PlaneBufferGeometry,
    Rs as PlaneGeometry,
    Xh as PlaneHelper,
    C0 as PointCloud,
    I0 as PointCloudMaterial,
    No as PointLight,
    zh as PointLightHelper,
    Bi as Points,
    Cn as PointsMaterial,
    Hh as PolarGridHelper,
    Ln as PolyhedronBufferGeometry,
    Ln as PolyhedronGeometry,
    Ah as PositionalAudio,
    We as PropertyBinding,
    vl as PropertyMixer,
    Os as QuadraticBezierCurve,
    Hs as QuadraticBezierCurve3,
    dt as Quaternion,
    ei as QuaternionKeyframeTrack,
    al as QuaternionLinearInterpolant,
    Dl as REVISION,
    nf as RGBADepthPacking,
    lt as RGBAFormat,
    _d as RGBAIntegerFormat,
    Dd as RGBA_ASTC_10x10_Format,
    Ld as RGBA_ASTC_10x5_Format,
    Pd as RGBA_ASTC_10x6_Format,
    Id as RGBA_ASTC_10x8_Format,
    Fd as RGBA_ASTC_12x10_Format,
    Nd as RGBA_ASTC_12x12_Format,
    wd as RGBA_ASTC_4x4_Format,
    bd as RGBA_ASTC_5x4_Format,
    Sd as RGBA_ASTC_5x5_Format,
    Td as RGBA_ASTC_6x5_Format,
    Ed as RGBA_ASTC_6x6_Format,
    Ad as RGBA_ASTC_8x5_Format,
    Rd as RGBA_ASTC_8x6_Format,
    Cd as RGBA_ASTC_8x8_Format,
    zd as RGBA_BPTC_Format,
    ac as RGBA_ETC2_EAC_Format,
    rc as RGBA_PVRTC_2BPPV1_Format,
    sc as RGBA_PVRTC_4BPPV1_Format,
    Kl as RGBA_S3TC_DXT1_Format,
    ec as RGBA_S3TC_DXT3_Format,
    tc as RGBA_S3TC_DXT5_Format,
    Jn as RGBFormat,
    vd as RGBIntegerFormat,
    Md as RGB_ETC1_Format,
    oc as RGB_ETC2_Format,
    ic as RGB_PVRTC_2BPPV1_Format,
    nc as RGB_PVRTC_4BPPV1_Format,
    Ql as RGB_S3TC_DXT1_Format,
    xd as RGFormat,
    yd as RGIntegerFormat,
    Qn as RawShaderMaterial,
    un as Ray,
    Rh as Raycaster,
    Oo as RectAreaLight,
    md as RedFormat,
    gd as RedIntegerFormat,
    nd as ReinhardToneMapping,
    qr as RepeatWrapping,
    e0 as ReplaceStencilOp,
    zu as ReverseSubtractEquation,
    po as RingBufferGeometry,
    po as RingGeometry,
    Yd as SRGB8_ALPHA8_ASTC_10x10_Format,
    qd as SRGB8_ALPHA8_ASTC_10x5_Format,
    Xd as SRGB8_ALPHA8_ASTC_10x6_Format,
    Jd as SRGB8_ALPHA8_ASTC_10x8_Format,
    Zd as SRGB8_ALPHA8_ASTC_12x10_Format,
    $d as SRGB8_ALPHA8_ASTC_12x12_Format,
    Bd as SRGB8_ALPHA8_ASTC_4x4_Format,
    Ud as SRGB8_ALPHA8_ASTC_5x4_Format,
    Od as SRGB8_ALPHA8_ASTC_5x5_Format,
    Hd as SRGB8_ALPHA8_ASTC_6x5_Format,
    kd as SRGB8_ALPHA8_ASTC_6x6_Format,
    Vd as SRGB8_ALPHA8_ASTC_8x5_Format,
    Gd as SRGB8_ALPHA8_ASTC_8x6_Format,
    Wd as SRGB8_ALPHA8_ASTC_8x8_Format,
    Ds as Scene,
    tv as SceneUtils,
    Fe as ShaderChunk,
    Jt as ShaderLib,
    Zt as ShaderMaterial,
    _o as ShadowMaterial,
    Ut as Shape,
    Xs as ShapeBufferGeometry,
    Xs as ShapeGeometry,
    Zh as ShapePath,
    ln as ShapeUtils,
    ad as ShortType,
    $a as Skeleton,
    Cl as SkeletonHelper,
    zs as SkinnedMesh,
    Xy as SmoothShading,
    hn as Sphere,
    Js as SphereBufferGeometry,
    Js as SphereGeometry,
    Lh as Spherical,
    Ho as SphericalHarmonics3,
    ks as SplineCurve,
    Do as SpotLight,
    Nh as SpotLightHelper,
    Ns as Sprite,
    Fs as SpriteMaterial,
    Kh as SrcAlphaFactor,
    qu as SrcAlphaSaturateFactor,
    Ou as SrcColorFactor,
    x0 as StaticCopyUsage,
    vs as StaticDrawUsage,
    p0 as StaticReadUsage,
    wh as StereoCamera,
    v0 as StreamCopyUsage,
    f0 as StreamDrawUsage,
    g0 as StreamReadUsage,
    Fn as StringKeyframeTrack,
    Nu as SubtractEquation,
    Yl as SubtractiveBlending,
    Gy as TOUCH,
    Qi as TangentSpaceNormalMap,
    mo as TetrahedronBufferGeometry,
    mo as TetrahedronGeometry,
    sv as TextGeometry,
    ft as Texture,
    hl as TextureLoader,
    go as TorusBufferGeometry,
    go as TorusGeometry,
    xo as TorusKnotBufferGeometry,
    xo as TorusKnotGeometry,
    vt as Triangle,
    Qy as TriangleFanDrawMode,
    jy as TriangleStripDrawMode,
    ef as TrianglesDrawMode,
    yo as TubeBufferGeometry,
    yo as TubeGeometry,
    Fl as UVMapping,
    k0 as Uint16Attribute,
    Ss as Uint16BufferAttribute,
    G0 as Uint32Attribute,
    Ts as Uint32BufferAttribute,
    U0 as Uint8Attribute,
    Ba as Uint8BufferAttribute,
    O0 as Uint8ClampedAttribute,
    Ua as Uint8ClampedBufferAttribute,
    Sl as Uniform,
    ie as UniformsLib,
    Pf as UniformsUtils,
    an as UnsignedByteType,
    Ai as UnsignedInt248Type,
    Vr as UnsignedIntType,
    cd as UnsignedShort4444Type,
    hd as UnsignedShort5551Type,
    ud as UnsignedShort565Type,
    ys as UnsignedShortType,
    us as VSMShadowMap,
    W as Vector2,
    M as Vector3,
    Ve as Vector4,
    Gi as VectorKeyframeTrack,
    N0 as Vertex,
    E0 as VertexColors,
    Qa as VideoTexture,
    Ya as WebGL1Renderer,
    As as WebGLCubeRenderTarget,
    Na as WebGLMultipleRenderTargets,
    ws as WebGLMultisampleRenderTarget,
    St as WebGLRenderTarget,
    Q0 as WebGLRenderTargetCube,
    qe as WebGLRenderer,
    Xx as WebGLUtils,
    vo as WireframeGeometry,
    Z0 as WireframeHelper,
    Zr as WrapAroundEnding,
    $0 as XHRLoader,
    bi as ZeroCurvatureEnding,
    Bu as ZeroFactor,
    Si as ZeroSlopeEnding,
    Ky as ZeroStencilOp,
    ji as sRGBEncoding,
};
/*! Bundled license information:

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=three.mjs.map
