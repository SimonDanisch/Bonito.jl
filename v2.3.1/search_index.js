var documenterSearchIndex = {"docs":
[{"location":"api.html#Api","page":"Api","title":"Api","text":"","category":"section"},{"location":"api.html#Public-Functions","page":"Api","title":"Public Functions","text":"","category":"section"},{"location":"api.html","page":"Api","title":"Api","text":"Modules = [JSServe]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api.html#JSServe.App","page":"Api","title":"JSServe.App","text":"App(callback_or_dom; title=\"JSServe App\")\nApp((session, request) -> DOM.div(...))\nApp((session::Session) -> DOM.div(...))\nApp((request::HTTP.Request) -> DOM.div(...))\nApp(() -> DOM.div(...))\nApp(DOM.div(...))\n\nUsage:\n\nusing JSServe\napp = App() do\n    return DOM.div(DOM.h1(\"hello world\"), js\"\"\"console.log('hello world')\"\"\")\nend\n\nIf you depend on global observable, make sure to bind it to the session. This is pretty important, since every time you display the app, listeners will get registered to it, that will just continue staying there until your Julia process gets closed. bind_global prevents that by binding the observable to the life cycle of the session and cleaning up the state after the app isn't displayed anymore. If you serve the App via a Server, be aware, that those globals will be shared with everyone visiting the page, so possibly by many users concurrently.\n\nglobal some_observable = Observable(\"global hello world\")\nApp() do session::Session\n    bound_global = bind_global(session, some_observable)\n    return DOM.div(bound_global)\nend\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.Asset","page":"Api","title":"JSServe.Asset","text":"Represent an asset stored at an URL. We try to always have online & local files for assets\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.CodeEditor-Tuple{String}","page":"Api","title":"JSServe.CodeEditor","text":"CodeEditor(language::String; initial_source=\"\", theme=\"chrome\", editor_options...)\n\nDefaults for editor_options:\n\n(\n    autoScrollEditorIntoView = true,\n    copyWithEmptySelection = true,\n    wrapBehavioursEnabled = true,\n    useSoftTabs = true,\n    enableMultiselect = true,\n    showLineNumbers = false,\n    fontSize = 16,\n    wrap = 80,\n    mergeUndoDeltas = \"always\"\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.NoServer","page":"Api","title":"JSServe.NoServer","text":"We don't serve files and include anything directly as raw bytes. Interpolating the same asset many times, will only upload the file to JS one time though.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.Session","page":"Api","title":"JSServe.Session","text":"A web session with a user\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.WebSocketConnection-Tuple{Any, HTTP.WebSockets.WebSocket}","page":"Api","title":"JSServe.WebSocketConnection","text":"handles a new websocket connection to a session\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.Page-Tuple{}","page":"Api","title":"JSServe.Page","text":"Page(;\n    offline=false, exportable=true,\n    connection::Union{Nothing, FrontendConnection}=nothing,\n    server_config...\n)\n\nA Page can be used for resetting the JSServe state in a multi page display outputs, like it's the case for Pluto/IJulia/Documenter. For Documenter, the page needs to be set to exportable=true, offline=true, but doesn't need to, since Page defaults to the most common parameters for known Packages. Exportable has the effect of inlining all data & js dependencies, so that everything can be loaded in a single HTML object. offline=true will make the Page not even try to connect to a running Julia process, which makes sense for the kind of static export we do in Documenter. For convenience, one can also pass additional server configurations, which will directly get put into configure_server!(;server_config...). Have a look at the docs for configure_server! to see the parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.configure_server!-Tuple{}","page":"Api","title":"JSServe.configure_server!","text":"configure_server!(;\n        listen_url::String=SERVER_CONFIGURATION.listen_url[],\n        listen_port::Integer=SERVER_CONFIGURATION.listen_port[],\n        forwarded_port::Integer=listen_port,\n        proxy_url=nothing,\n        content_delivery_url=nothing\n    )\n\nConfigures the parameters for the automatically started server.\n\nParameters:\n\n* listen_url=SERVER_CONFIGURATION.listen_url[]\n    The address the server listens to.\n    must be 0.0.0.0, 127.0.0.1, ::, ::1, or localhost.\n    If not set differently by an ENV variable, will default to 127.0.0.1\n\n* listen_port::Integer=SERVER_CONFIGURATION.listen_port[],\n    The Port to which the default server listens to\n    If not set differently by an ENV variable, will default to 9384\n\n* forwarded_port::Integer=listen_port,\n    if port gets forwarded to some other port, set it here!\n\n* proxy_url=nothing\n    The url from which the server is reachable.\n    If served on \"127.0.0.1\", this will default to http://localhost:forwarded_port\n    if listen_url is \"0.0.0.0\", this will default to http://$(Sockets.getipaddr()):forwarded_port\n    so that the server is reachable inside the local network.\n    If the server should be reachable from some external dns server,\n    this needs to be set here.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.evaljs-Tuple{Session, JSServe.JSCode}","page":"Api","title":"JSServe.evaljs","text":"evaljs(session::Session, jss::JSCode)\n\nEvaluate a javascript script in session.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.evaljs_value-Tuple{Session, Any}","page":"Api","title":"JSServe.evaljs_value","text":"evaljs_value(session::Session, js::JSCode)\n\nEvals js code and returns the jsonified value. Blocks until value is returned. May block indefinitely, when called with a session that doesn't have a connection to the browser.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.linkjs-Tuple{Session, Observable, Observable}","page":"Api","title":"JSServe.linkjs","text":"linkjs(session::Session, a::Observable, b::Observable)\n\nfor an open session, link a and b on the javascript side. This will also Link the observables in Julia, but only as long as the session is active.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.onjs-Tuple{Session, Observable, JSServe.JSCode}","page":"Api","title":"JSServe.onjs","text":"onjs(session::Session, obs::Observable, func::JSCode)\n\nRegister a javascript function with session, that get's called when obs gets a new value. If the observable gets updated from the JS side, the calling of func will be triggered entirely in javascript, without any communication with the Julia session.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Private-Functions","page":"Api","title":"Private Functions","text":"","category":"section"},{"location":"api.html","page":"Api","title":"Api","text":"Modules = [JSServe]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"api.html#JSServe.FrontendConnection","page":"Api","title":"JSServe.FrontendConnection","text":"Inteface for FrontendConnection\n\nstruct MyConnection <: FrontendConnection\nend\n\nNeeds to have a constructor with 0 arguments:\n\nMyConnection()\n\nNeeds to overload Base.write for sending binary data\n\nBase.write(connection::MyConnection, bytes::AbstractVector{UInt8})\n\nNeeds to implement isopen to indicate status of connection\n\nBase.isopen(c::MyConnection)\n\nSetup connection will be called before rendering any dom with session. The return value will be inserted into the DOM of the rendered App and can be used to do the JS part of opening the connection.\n\nJSServe.setup_connection(session::Session{IJuliaConnection})::Union{JSCode, Nothing}\n\nOne can overload use_parent_session, to turn on rendering dom objects inside sub-sessions while keeping one parent session managing the connection alive. This is handy for IJulia/Pluto, since the parent session just needs to be initialized one time and can stay active and globally store objects used multiple times across doms.\n\nJSServe.use_parent_session(::Session{MyConnection}) = false/false\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.JSCode","page":"Api","title":"JSServe.JSCode","text":"Javascript code that supports interpolation of Julia Objects. Construction of JSCode via string macro:\n\njsc = js\"console.log($(some_julia_variable))\"\n\nThis will decompose into:\n\njsc.source == [JSString(\"console.log(\"), some_julia_variable, JSString(\"\"\")]\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.JSException-Tuple{Session, AbstractDict}","page":"Api","title":"JSServe.JSException","text":"Creates a Julia exception from data passed to us by the frondend!\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.JSString","page":"Api","title":"JSServe.JSString","text":"The string part of JSCode.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.JSUpdateObservable","page":"Api","title":"JSServe.JSUpdateObservable","text":"Functor to update JS part when an observable changes. We make this a Functor, so we can clearly identify it and don't sent any updates, if the JS side requires to update an Observable (so we don't get an endless update cycle)\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.Table","page":"Api","title":"JSServe.Table","text":"A simple wrapper for types that conform to the Tables.jl Table interface, which gets rendered nicely!\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.add_cached!-Tuple{Function, Session, Dict{String, Any}, Any}","page":"Api","title":"JSServe.add_cached!","text":"add_cached!(create_cached_object::Function, session::Session, message_cache::Dict{String, Any}, key::String)\n\nChecks if key is already cached by the session or it's root session (we skip any child session between root -> this session). If not cached already, we call create_cached_object to create a serialized form of the object corresponding to key and cache it. We return nothing if already cached, or the serialized object if not cached. We also handle the part of adding things to the message_cache from the serialization context.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.dependency_path-Tuple","page":"Api","title":"JSServe.dependency_path","text":"dependency_path(paths...)\n\nPath to serve downloaded dependencies\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.export_standalone-Tuple{App, String}","page":"Api","title":"JSServe.export_standalone","text":"export_standaloneexport_standalone(\n    app::App, folder::String;\n    clear_folder=false, write_index_html=true,\n    absolute_urls=false, content_delivery_url=\"file://\" * folder * \"/\",\n    single_html=false)\n\nExports the app defined by app::Application with all its assets to folder. Will write the main html out into folder/index.html. Overwrites all existing files! If this gets served behind a proxy, set absolute_urls=true and set content_delivery_url to your proxy url. If clear_folder=true all files in folder will get deleted before exporting again! single_html=true will write out a single html instead of writing out JS depencies as separate files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.getextension-Tuple{AbstractString}","page":"Api","title":"JSServe.getextension","text":"getextension(path)\n\nGet the file extension of the path. The extension is defined to be the bit after the last dot, excluding any query string.\n\nExamples\n\njulia> JSServe.getextension(\"foo.bar.js\")\n\"js\"\njulia> JSServe.getextension(\"https://my-cdn.net/foo.bar.css?version=1\")\n\"css\"\n\nTaken from WebIO.jl\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.is_online-Tuple{AbstractString}","page":"Api","title":"JSServe.is_online","text":"is_online(path)\n\nDetermine whether or not the specified path is a local filesystem path (and not a remote resource that is hosted on, for example, a CDN).\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.jsrender-Tuple{Session, Union{Number, String, Symbol}}","page":"Api","title":"JSServe.jsrender","text":"jsrender([::Session], x::Any)\n\nInternal render method to create a valid dom. Registers used observables with a session And makes sure the dom only contains valid elements. Overload jsrender(::YourType) To enable putting YourType into a dom element/div. You can also overload it to take a session as first argument, to register messages with the current web session (e.g. via onjs).\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.on_document_load-Tuple{Session, JSServe.JSCode}","page":"Api","title":"JSServe.on_document_load","text":"on_document_load(session::Session, js::JSCode)\n\nexecutes javascript after document is loaded\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.onload-Tuple{Session, Hyperscript.Node, JSServe.JSCode}","page":"Api","title":"JSServe.onload","text":"onload(session::Session, node::Node, func::JSCode)\n\ncalls javascript func with node, once node has been displayed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.page_html-Tuple{IO, Session, Union{App, Hyperscript.Node}}","page":"Api","title":"JSServe.page_html","text":"page_html(session::Session, html_body)\n\nEmbeds the html_body in a standalone html document!\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.process_message-Tuple{Session, AbstractVector{UInt8}}","page":"Api","title":"JSServe.process_message","text":"process_message(session::Session, bytes::AbstractVector{UInt8})\n\nHandles the incoming websocket messages from the frontend. Messages are expected to be gzip compressed and packed via MsgPack.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.register_asset_server!-Union{Tuple{C}, Tuple{Function, Type{C}}} where C<:JSServe.AbstractAssetServer","page":"Api","title":"JSServe.register_asset_server!","text":"register_asset_server!(condition::Function, ::Type{<: AbstractAssetServer})\n\nRegisters a new asset server type. condition is a function that should return nothing, if the asset server type shouldn't be used, and an initialized asset server object, if the conditions are right. E.g. The JSServe.NoServer be used inside an IJulia notebook so it's registered like this:\n\nregister_asset_server!(NoServer) do\n    if isdefined(Main, :IJulia)\n        return NoServer()\n    end\n    return nothing\nend\n\nThe last asset server registered takes priority, so if you register a new connection last in your Package, and always return it, You will overwrite the connection type for any other package. If you want to force usage temporary, try:\n\nforce_asset_server(YourAssetServer()) do\n    ...\nend\n# which is the same as:\nforce_asset_server!(YourAssetServer())\n...\nforce_asset_server!()\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.register_connection!-Union{Tuple{C}, Tuple{Function, Type{C}}} where C<:JSServe.FrontendConnection","page":"Api","title":"JSServe.register_connection!","text":"register_connection!(condition::Function, ::Type{<: FrontendConnection})\n\nRegisters a new Connection type.\n\ncondition is a function that should return nothing, if the connection type shouldn't be used, and an initialized Connection, if the conditions are right. E.g. The IJulia connection should only be used inside an IJulia notebook so it's registered like this:\n\nregister_connection!(IJuliaConnection) do\n    if isdefined(Main, :IJulia)\n        return IJuliaConnection()\n    end\n    return nothing\nend\n\nThe last connection registered take priority, so if you register a new connection last in your Package, and always return it, You will overwrite the connection type for any other package. If you want to force usage temporary, try:\n\nforce_connection(YourConnectionType()) do\n    ...\nend\n# which is the same as:\nforce_connection!(YourConnectionType())\n...\nforce_connection!()\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.replace_expressions-Tuple{Session, Any}","page":"Api","title":"JSServe.replace_expressions","text":"replace_expressions(markdown, context)\n\nReplaces all expressions inside markdown savely, by only supporting getindex/getfield expression that will index into context\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.set_cleanup_time!-Tuple{Real}","page":"Api","title":"JSServe.set_cleanup_time!","text":"set_cleanup_time!(time_in_hrs::Real)\n\nSets the time that sessions remain open after the browser tab is closed. This allows reconnecting to the same session. Only works for Websocket connection inside VSCode right now, and will display the same App again from first display. State that isn't stored in Observables inside that app is lost.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.string_to_markdown-Tuple{Session, String}","page":"Api","title":"JSServe.string_to_markdown","text":"string_to_markdown(session::Session, source::String; eval_julia_code=false)\n\nReplaces all interpolation expressions inside markdown savely, by only supporting getindex/getfield expression that will index into context. You can eval Julia code blocks by setting eval_julia_code to a Module, into which the code gets evaluated!\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.update_nocycle!-Tuple{Observable, Any}","page":"Api","title":"JSServe.update_nocycle!","text":"Update the value of an observable, without sending changes to the JS frontend. This will be used to update updates from the forntend.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Sockets.send-Tuple{Session}","page":"Api","title":"Sockets.send","text":"send(session::Session; attributes...)\n\nSend values to the frontend via JSON for now\n\n\n\n\n\n","category":"method"},{"location":"api.html","page":"Api","title":"Api","text":"Modules = [JSServe.HTTPServer]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = true","category":"page"},{"location":"api.html#JSServe.HTTPServer.Server","page":"Api","title":"JSServe.HTTPServer.Server","text":"HTTP server with websocket & http routes\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.HTTPServer.Server-Tuple{String, Int64}","page":"Api","title":"JSServe.HTTPServer.Server","text":"Server(         dom, url::String, port::Int;         verbose = -1     )\n\nCreates an application that manages the global server state!\n\n\n\n\n\n","category":"method"},{"location":"api.html#Base.wait-Tuple{Server}","page":"Api","title":"Base.wait","text":"wait(server::Server)\n\nWait on the server task, i.e. block execution by bringing the server event loop to the foreground.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.HTTPServer.browser_display-Tuple{}","page":"Api","title":"JSServe.HTTPServer.browser_display","text":"browser_display()\n\nForces JSServe.App to be displayed in a browser window that gets opened.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.HTTPServer.local_url-Tuple{Server, Any}","page":"Api","title":"JSServe.HTTPServer.local_url","text":"local_url(server::Server, url)\n\nThe local url to reach the server, on the server\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.HTTPServer.online_url-Tuple{Server, Any}","page":"Api","title":"JSServe.HTTPServer.online_url","text":"online_url(server::Server, url)\n\nThe url to connect to the server from the internet. Needs to have server.proxy_url set to the IP or dns route of the server\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.HTTPServer.tryrun-Tuple{Cmd}","page":"Api","title":"JSServe.HTTPServer.tryrun","text":"tryrun(cmd::Cmd)\n\nTry to run a command. Return true if cmd runs and is successful (exits with a code of 0). Return false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"extending.html#Extending-JSServe","page":"Extending","title":"Extending JSServe","text":"","category":"section"},{"location":"extending.html#Connection","page":"Extending","title":"Connection","text":"","category":"section"},{"location":"extending.html","page":"Extending","title":"Extending","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"extending.html","page":"Extending","title":"Extending","text":"\nstruct MyConnection <: JSServe.FrontendConnection\n    ...\nend\n\nfunction MyConnection(parent::Session)\n    return MyConnection(parent.connection, false)\nend\n\nfunction Base.write(connection::MyConnection, binary)\n    write(connection.connection, binary)\nend\n\nBase.isopen(connection::MyConnection) = connection.isopen\nBase.close(connection::MyConnection) = (connection.isopen = false)\nopen!(connection::MyConnection) = (connection.isopen = true)\n\nfunction setup_connection(session::Session{MyConnection})\n    return js\"\"\"\n    // Javascript needed to connect to\n    const conn = create_connection(...) // implemented by your framework\n    conn.on_msg((msg) => {\n        JSServe.process_message(msg)\n    });\n    // register sending message\n    JSServe.on_connection_open((binary) => {\n        comm.send(binary)\n    }, $(session.compression_enabled));\n    \"\"\"\nend","category":"page"},{"location":"widgets.html#Widgets","page":"Widgets","title":"Widgets","text":"","category":"section"},{"location":"widgets.html#Editor","page":"Widgets","title":"Editor","text":"","category":"section"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"This editor works in pure Javascript, so feel free to try out editing the Javascript and clicking eval to see how the output changes. In JSServe/examples/editor.jl, you will find a version that works with Julia code, but that requires a running Julia server of course.","category":"page"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"using JSServe\nPage()","category":"page"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"using JSServe\nimport JSServe.TailwindDashboard as D\n\nfunction range_slider(orientation)\n    range_slider = RangeSlider(1:100; value=[10, 80])\n    range_slider.tooltips[] = true\n    range_slider.ticks[] = Dict(\n        \"mode\" => \"range\",\n        \"density\" => 3\n    )\n    range_slider.orientation[] = orientation\n    return range_slider\nend\n\nApp() do\n\n    button = D.Button(\"click\")\n    textfield = D.TextField(\"type in your text\")\n    numberinput = D.NumberInput(0.0)\n    file_input = D.FileInput()\n    on(file_input.value) do file\n        @show file\n    end\n    slider = D.Slider(\"Test\", 1:5)\n\n    checkbox = D.Checkbox(\"check this\", true)\n    table = JSServe.Table([(a=22, b=33, c=44), (a=22, b=33, c=44)])\n\n    source = \"\"\"\n    function test(a, b)\n        return a + b\n    end\n    \"\"\"\n    editor = CodeEditor(\"julia\"; initial_source=source, width=250, height=200, scrollPastEnd=false)\n    dropdown = D.Dropdown(\"chose\", [\"option 1\", \"option 2\", \"option 3\"])\n\n    vrange_slider = range_slider(JSServe.WidgetsBase.vertical)\n\n    hrange_slider = range_slider(JSServe.WidgetsBase.horizontal)\n\n\n    return DOM.div(\n        D.Card.([\n            D.FlexRow(\n                D.Card(D.FlexCol(\n                    button,\n                    textfield,\n                    numberinput,\n                    dropdown,\n                    file_input,\n                    slider,\n                    checkbox,\n                    class=\"items-start\"\n                )),\n                D.Card(D.FlexCol(\n                    D.Card(DOM.div(vrange_slider; style=\"height: 200px; padding: 1px 50px\")),\n                    D.Card(DOM.div(hrange_slider; style=\"width: 200px; padding: 50px 1px\"),\n                    )),\n                )),\n            D.FlexRow(\n                D.Card.([\n\n                    D.Card(table; class=\"w-64\")\n                    editor\n                ])\n            ),\n        ])...\n    )\nend","category":"page"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"using JSServe, Observables\nsrc = \"\"\"\n(() => {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext('2d');\n    const width = 500\n    const height = 400\n    canvas.width = width;\n    canvas.height = height;\n    const gradient = context.createRadialGradient(200, 200, 0, 200, 200, 200);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\".25\", \"blue\");\n    gradient.addColorStop(\".50\", \"green\");\n    gradient.addColorStop(\".75\", \"yellow\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return canvas;\n})();\n\"\"\"\nApp() do session::Session\n    editor = CodeEditor(\"javascript\"; initial_source=src, width=800, height=300)\n    eval_button = Button(\"eval\")\n    output = DOM.div(DOM.span())\n    JSServe.onjs(session, eval_button.value, js\"\"\"function (click){\n        const js_src = $(editor.onchange).value;\n        const result = new Function(\"return \" + (js_src))()\n        let dom;\n        if (typeof result === 'object' && result.nodeName) {\n            dom = result\n        } else {\n            const span = document.createElement(\"span\")\n            span.innerText = result;\n            dom = span\n        }\n        JSServe.update_or_replace($(output), dom, false);\n        return\n    }\n    \"\"\")\n    notify(eval_button.value)\n    return DOM.div(editor, eval_button, output)\nend","category":"page"},{"location":"deployment.html#Deployment","page":"Deployment","title":"Deployment","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using JSServe\nexample_app = App(DOM.div(\"hello world\"), title=\"hello world\")","category":"page"},{"location":"deployment.html#Server","page":"Deployment","title":"Server","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"# Depending on your servers setup, you may need to listen on another port or URL\n# But 0.0.0.0:80 is pretty standard for most server setups\nport = 80\nurl = \"0.0.0.0\"\nserver = JSServe.Server(example_app, url, port)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Now, you should see the webpage at http://0.0.0.0:80.","category":"page"},{"location":"deployment.html#Proxy-Julia-Hub","page":"Deployment","title":"Proxy + Julia Hub","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"If the server is behind a proxy, you can set the proxy like this:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"server = JSServe.Server(example_app, \"0.0.0.0\", 8080; proxy_url=\"https://my-domain.de/my-app\");\n# or set it later\n# this can be handy for interactive use cases where one isn't sure which port is open, and let JSServe find a free port (which will then be different from the one created with, but is stored in `server.port`)\nserver.proxy_url = \".../$(server.port)\"","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"JSServe tries to do this for known environments like JuliaHub via get_server(). This will find the most common proxy setup and return a started server:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"server = JSServe.get_server()\n# add a route to the server for root to point to our example app\nroute!(server, \"/\" => example_app)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"The url which this site is now served on can be found via:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"# Here in documenter, this will just return a localhost url\nurl_to_visit = online_url(server, \"/\")","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Like this, one can also add multiple pages:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"page_404 = App() do session, request\n    return DOM.div(\"no page for $(request.target)\")\nend\n# You can use string (paths), or a regex\nroute!(server, r\".*\" => page_404)\nroute!(server, \"/my/nested/page\" => App(DOM.div(\"nested\")))\nurl_to_visit = online_url(server, \"/my/nested/page\")","category":"page"},{"location":"deployment.html#nginx","page":"Deployment","title":"nginx","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"If you need to re-route JSServe (e.g. to host in parallel to PlutoSliderServer, you want a reverse-proxy like nginx. We did some testing with nginx and the following configuration worked for us:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"server {\n    listen 8080;\n    location /jsserve/ {\n        proxy_pass http://localhost:8081/;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n        proxy_set_header Host $host;\n    }\n}","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"and the JSServer with:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"    server = Server(\"127.0.0.1\", 8081;proxy_url=\"https://www.abc.org/jsserve/\")\n    route!(server,\"/\"=>app) # with app an JSServe app\n    # close(server) # useful for debugging ;)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"This would re-route www.abc.org:8080/jsserve/ to your local JSServe-Server.","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"If you get errors in your browser console relating to \"GET\", \"MIME-TYPE\"","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"First make sure that the URL of the assets is \"correct\", that is, there is no // somewhere in the domain, and in principle the client tries to find the correct target (Server(...,verbose=1) might help to see if requests arrive).\nif the app shows up fine, but you get these errors (typically with wss:// in the front, indicating some websocket issue), double check that all the slashes / in your configuration are set correct. That is all these 4 paths should have /'s at the end: location /subfolder/, proxy_pass =.../  Server(...,proxy_url=\".../\") and route!(...,'/'=>app)\nIf it still doesnt work, you might need to look into websocket forwarding - or you might have an intermediate reverse-proxy that blocks the websocket.","category":"page"},{"location":"deployment.html#Heroku","page":"Deployment","title":"Heroku","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Deploying to Heroku with JSServe works pretty similar to this blogpost.","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"mkdir my-app\ncd my-app\njulia --project=. -e 'using Pkg; Pkg.add(\"JSServe\")' # and any other dependency","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"then create 2 files:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"app.jl:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using JSServe\n# The app you want to serve\n#  Note: you can also add more pages with `route!(server, ...)` as explained aboce\nmy_app = App(DOM.div(\"hello world\"))\nport = parse(Int, ENV[\"PORT\"])\n# needs to match `heroku create - a example-app`,\n# which we can ensure by using the env variable\n# which is only available in review app, so one needs to fill this in manually for now\n# https://devcenter.heroku.com/articles/github-integration-review-apps#injected-environment-variables\nmy_app_name = get(ENV, \"HEROKU_APP_NAME\", \"example-app\")\nurl = \"https://$(my_app_name).herokuapp.com/\"\nwait(JSServe.Server(my_app, \"0.0.0.0\", port, proxy_url=url))","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Procfile:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"web: julia --project=. app.jl","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"and then to upload the app install the heroku-cli and run as explained in the heroku git deploy section:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"$ cd my-app\n$ git init\n$ git add .\n$ git commit -m \"first commit\"\n$ heroku create -a example-app\n$ heroku git:remote -a example-app","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Which, after showing you the install logs, should print out the url to visit in the end. You can see the full example here:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"https://github.com/SimonDanisch/JSServe-heroku","category":"page"},{"location":"deployment.html#Terminal","page":"Deployment","title":"Terminal","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"If no HTML display is found in the Julia display stack, JSServe calls JSServe.enable_browser_display() in the __init__ function. This adds a display, that opens a browser window to display the app The loading of the BrowserDisplay happen in any kind of environment without html display, so this should also work in any kind of terminal or when evaluating a script.","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"> using JSSever\n> example_app # just let the display system display it in a browser window","category":"page"},{"location":"deployment.html#VScode","page":"Deployment","title":"VScode","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"VScode with enabled Plot Pane will display any JSServe.App in the HTML plotpane: (Image: )","category":"page"},{"location":"deployment.html#Notebooks","page":"Deployment","title":"Notebooks","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Most common notebook systems should work out of the box.","category":"page"},{"location":"deployment.html#IJulia","page":"Deployment","title":"IJulia","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Jupyterlab","page":"Deployment","title":"Jupyterlab","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Pluto","page":"Deployment","title":"Pluto","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Electron","page":"Deployment","title":"Electron","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using Electron, JSServe\n# Needs to be called after loading Electron\nJSServe.use_electron_display()\n# display(...) can be skipped in e.g. VSCode with disabled plotpane\ndisplay(example_app)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"note: Note\nBy default, JSServe will create the Electron window without showing the Developer Tools panel. You can control this behavior at window creation using the devtools keyword arg:display = JSServe.use_electron_display(devtools = true)Alternatively, you can toggle the Developer Tools at any later time using:Electron.toggle_devtools(display.window)","category":"page"},{"location":"deployment.html#Documenter","page":"Deployment","title":"Documenter","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"JSServe works in Documenter without additional setup. But, one always needs to include a block like this before any other code block displaying JSServe Apps:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using JSServe\nPage()","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"This is needed, since JSServe structures the dependencies and state per Page, which needs to be unique per documentation page. One can use the JSServe documentation source to see an example.","category":"page"},{"location":"deployment.html#Static-export","page":"Deployment","title":"Static export","text":"","category":"section"},{"location":"deployment.html#Anything-else","page":"Deployment","title":"Anything else","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"JSServe overloads the display/show stack for the mime \"text/html\" so any other Software which is able to display html in Julia should work with JSServe. If a use case is not supported, please open an issue. One can also always directly call:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"html_source = sprint(io-> show(io, MIME\"text/html\"(), example_app))","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Do get the html source code as a string (or just write it to the io).","category":"page"},{"location":"assets.html#Assets","page":"Assets","title":"Assets","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"some_file = Asset(\"path/to/local/file\")\n# ES6Module creates an Asset with the flags set appropriately to\n# treat it as a module\njsmodule = ES6Module(\"path/to/local/es6module.js\")::Asset\n\n# These assets can be interpolated into DOM elements and js strings:\njs\"\"\"\n// this will result in importing jsmodule\n// Doing this in many places will only import jsmodule once\n$(jsmodule).then(jsmodule=> {\n    // Do something with the module :)\n})\n// This will give you the raw bytes as a Uint8Array\n$(some_file).then(raw_bytes => {\n    // do something with bytes\n})\n\"\"\"\n\n# This will resolve to a valid URL depending on the used asset server\nDOM.img(src=some_file)\n\n# This will also resolve to a valid URL and load jsmodule as an es6 module\nDOM.sript(src=jsmodule, type=\"module\")\n\n# Assets also work with online sources, which is great for online dependencies!\n# Usage is exactly the same as when using local files\nTHREE = ES6Module(\"https://unpkg.com/three@0.136.0/build/three.js\")\n# Also offer an easy way to use packages from a CDN (currently esm.sh):\nTHREE = CDNSource(\"three\"; version=\"0.137.5\")","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"using JSServe\nPage()","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"# Javascript & CSS dependencies can be declared locally and\n# freely interpolated in the DOM / js string, and will make sure it loads\n# Note, that they will be a `Promise` though, so to use them you need to call `module.then(module=> ...)`.\nconst THREE = ES6Module(\"https://cdn.esm.sh/v66/three@0.136/es2021/three.js\")\n\napp = App() do session, request\n    width = 500; height = 500\n    dom = DOM.div(width = width, height = height)\n    JSServe.onload(session, dom, js\"\"\"\n        function (container){\n            $(THREE).then(THREE=> {\n                var renderer = new THREE.WebGLRenderer({antialias: true});\n                renderer.setSize($width, $height);\n                renderer.setClearColor(\"#ffffff\");\n                container.appendChild(renderer.domElement);\n                var scene = new THREE.Scene();\n                var camera = new THREE.PerspectiveCamera(75, $width / $height, 0.1, 1000);\n                camera.position.z = 4;\n                var ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);\n                scene.add(ambientLight);\n                var pointLight = new THREE.PointLight(0xffffff, 0.8);\n                camera.add(pointLight);\n                scene.add(camera);\n                var geometry = new THREE.SphereGeometry(1.0, 32, 32);\n                var material = new THREE.MeshPhongMaterial({color: 0xffff00});\n                var sphere = new THREE.Mesh(geometry, material);\n                scene.add(sphere);\n                renderer.render(scene, camera);\n            })\n        }\n    \"\"\")\n    return dom\nend","category":"page"},{"location":"plotting.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"using JSServe\nusing WGLMakie\nimport WGLMakie as W\nimport Gadfly as G\nimport PlotlyLight as PL\nimport JSServe.TailwindDashboard as D\n\nPage()\n\nfunction makie_plot()\n    N = 10\n    function xy_data(x, y)\n        r = sqrt(x^2 + y^2)\n        r == 0.0 ? 1.0f0 : (sin(r) / r)\n    end\n    l = range(-10, stop=10, length=N)\n    z = Float32[xy_data(x, y) for x in l, y in l]\n    W.surface(\n        -1 .. 1, -1 .. 1, z,\n        colormap=:Spectral,\n        figure=(; resolution=(500, 500))\n    )\nend\n\n# As far as I can tell, PlotlyLight doesn't handle require inside documenter correctly\n# So we just use JSServe to do it correctly via `Asset`:\nconst Plotly = JSServe.Asset(PL.cdn_url[])\nfunction JSServe.jsrender(session::Session, plot::PL.Plot)\n    # Pretty much copied from the PlotlyLight source to create the JS + div for creating the plot:\n    div = DOM.div(style=\"width: 400px;\")\n    src = js\"\"\"\n        Plotly.newPlot($(div), $(plot.data), $(plot.layout), $(plot.config))\n    \"\"\"\n    return JSServe.jsrender(session, DOM.div(Plotly, div, src))\nend\n\nApp() do\n    p = PL.Plot(x=1:20, y=cumsum(randn(20)), type=\"scatter\", mode=\"lines+markers\")\n    width = \"400px\"\n    G.set_default_plot_size(400G.px, 400G.px)\n    gp = G.plot([sin, cos], 0, 2pi)\n    return DOM.div(D.FlexGrid(\n        D.Card(gp; width),\n        D.Card(p; width),\n        D.Card(makie_plot(); width); style=\"width: 900px\"))\nend","category":"page"},{"location":"animation.html#Animating-things","page":"Animation","title":"Animating things","text":"","category":"section"},{"location":"animation.html","page":"Animation","title":"Animation","text":"Animations in JSServe are done via Observables.jl, much like it's the case for Makie.jl, so the same docs apply:","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"https://docs.makie.org/stable/documentation/nodes/index.html https://docs.makie.org/stable/documentation/animation/index.html","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"But lets quickly get started with a JSServe specific example:","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"using JSServe\nPage()","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"App() do session\n    s = Slider(1:3)\n    value = map(s.value) do x\n        return x ^ 2\n    end\n    return JSServe.record_states(session, DOM.div(s, value))\nend","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"The s.value is an Observable which can be mapp'ed to take on new values, and one can insert observables as an input to DOM.tag or as any attribute. The value of the observable will be renedered via jssrender(session, observable[]), and then updated whenever the value changes. So anything that supports being inserted into the DOM can be inside an observable, and the fallback is to use the display system (so plots etc work as well). This way, one can also return DOM elements as the result of an observable:","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"App() do session\n    s = Slider(1:3)\n    # use map!(result_observable, ...)\n    # To use any as the result type, otherwise you can't return\n    # different types from the map callback\n    value = map!(Observable{Any}(), s.value) do x\n        if x == 1\n            return DOM.h1(\"hello from slider: $(x)\")\n        elseif x == 2\n            return DOM.img(src=\"https://docs.makie.org/stable/assets/makie_logo_transparent.svg\", width=\"200px\")\n        else\n            return x^2\n        end\n    end\n    return JSServe.record_states(session, DOM.div(s, value))\nend","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"In other words, the whole app can just be one big observable:","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"import JSServe.TailwindDashboard as D\nApp() do session\n    s = D.Slider(\"Slider: \", 1:3)\n    checkbox = D.Checkbox(\"Chose:\", true)\n    menu = D.Dropdown(\"Menu: \", [sin, tan, cos])\n    app = map(checkbox.widget.value, s.widget.value, menu.widget.value) do checkboxval, sliderval, menuval\n        DOM.div(checkboxval, sliderval, menuval)\n    end\n    return JSServe.record_states(session, D.FlexRow(\n        D.Card(D.FlexCol(checkbox, s, menu)),\n        D.Card(app)\n    ))\nend","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"Likes this one create interactive examples like this:","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"import JSServe.TailwindDashboard as D\n\nfunction create_svg(sl_nsamples, sl_sample_step, sl_phase, sl_radii, color)\n    width, height = 900, 300\n    cxs_unscaled = [i*sl_sample_step + sl_phase for i in 1:sl_nsamples]\n    cys = sin.(cxs_unscaled) .* height/3 .+ height/2\n    cxs = cxs_unscaled .* width/4pi\n    rr = sl_radii\n    # DOM.div/svg/etc is just a convenience in JSServe for using Hyperscript, but circle isn't wrapped like that yet\n    geom = [SVG.circle(cx=cxs[i], cy=cys[i], r=rr, fill=color(i)) for i in 1:sl_nsamples[]]\n    return SVG.svg(SVG.g(geom...);\n        width=width, height=height\n    )\nend\n\napp = App() do session\n    colors = [\"black\", \"gray\", \"silver\", \"maroon\", \"red\", \"olive\", \"yellow\", \"green\", \"lime\", \"teal\", \"aqua\", \"navy\", \"blue\", \"purple\", \"fuchsia\"]\n    color(i) = colors[i%length(colors)+1]\n    sl_nsamples = D.Slider(\"nsamples\", 1:200, value=100)\n    sl_sample_step = D.Slider(\"sample step\", 0.01:0.01:1.0, value=0.1)\n    sl_phase = D.Slider(\"phase\", 0.0:0.1:6.0, value=0.0)\n    sl_radii = D.Slider(\"radii\", 0.1:0.1:60, value=10.0)\n    svg = map(create_svg, sl_nsamples.value, sl_sample_step.value, sl_phase.value, sl_radii.value, color)\n    return DOM.div(D.FlexRow(D.FlexCol(sl_nsamples, sl_sample_step, sl_phase, sl_radii), svg))\nend","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"As you notice, when exporting this example to the docs which get statically hosted, all interactions requiring Julia ceise to exist. One way to create interactive examples that stay active is to move the parts that need Julia to Javascript:","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"app = App() do session\n    colors = [\"black\", \"gray\", \"silver\", \"maroon\", \"red\", \"olive\", \"yellow\", \"green\", \"lime\", \"teal\", \"aqua\", \"navy\", \"blue\", \"purple\", \"fuchsia\"]\n    nsamples = D.Slider(\"nsamples\", 1:200, value=100)\n    nsamples.widget[] = 100\n    sample_step = D.Slider(\"sample step\", 0.01:0.01:1.0, value=0.1)\n    sample_step.widget[] = 0.1\n    phase = D.Slider(\"phase\", 0.0:0.1:6.0, value=0.0)\n    radii = D.Slider(\"radii\", 0.1:0.1:60, value=10.0)\n    radii.widget[] = 10\n    svg = DOM.div()\n    evaljs(session, js\"\"\"\n        const [width, height] = [900, 300]\n        const colors = $(colors)\n        const observables = $([nsamples.value, sample_step.value, phase.value, radii.value])\n        function update_svg(args) {\n            const [nsamples, sample_step, phase, radii] = args;\n            const svg = (tag, attr) => {\n                const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n                for (const key in attr) {\n                    el.setAttributeNS(null, key, attr[key]);\n                }\n                return el\n            }\n            const color = (i) => colors[i % colors.length]\n            const svg_node = svg('svg', {width: width, height: height});\n            for (let i=0; i<nsamples; i++) {\n                const cxs_unscaled = (i + 1) * sample_step + phase;\n                const cys = Math.sin(cxs_unscaled) * (height / 3.0) + (height / 2.0);\n                const cxs = cxs_unscaled * width / (4 * Math.PI);\n                const circle = svg('circle', {cx: cxs, cy: cys, r: radii, fill: color(i)});\n                svg_node.appendChild(circle);\n            }\n            $(svg).replaceChildren(svg_node);\n        }\n        JSServe.onany(observables, update_svg)\n        update_svg(observables.map(x=> x.value))\n        \"\"\")\n    return DOM.div(D.FlexRow(D.FlexCol(nsamples, sample_step, phase, radii), svg))\nend","category":"page"},{"location":"animation.html","page":"Animation","title":"Animation","text":"This works, because the Javascript side of JSServe, will still update the observables in Javascript (which are mirrored from Julia), and therefore keep working without a running Julia process. You can use js_observable.on(value=> ....) and JSServe.onany(array_of_js_observables, values=> ...) to create interactions, pretty similar to how you would work with Observables in Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe.jl is a pretty simple package allowing to render HTML and serve it from within Julia and build up a communication bridge with the Browser. This allows to combine any of your Julia applications with libraries like WGLMakie and create interactive Dashboards like this:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: dashboard)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe is tightly integrated with WGLMakie, which makes them a great pair for high performance, interactive visualizations. If performance is not a high priority, many other plotting/visualization libraries which overload the Julia display system should work with JSServe.jl as well.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe.jl itself tries to stay out of major choices like the HTML/CSS/Javascript framework to use for creating UIs and Dashboards.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It uses plain HTML widgets for UI elements where it can, and only to give some base convenience, there is JSServe.TailwindDashboard which gives the basic JSServe widgets some nicer look and make it a bit easier to construct complex layouts.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"As you can see in JSServe/src/tailwind-dashboard.jl, it's just a thin wrapper around the basic JSServe.jl widgets, which gives them some class(es) to style them via TailwindCSS. Anyone can do this with their own CSS or HTML/Javascript framework, which should help to create a rich ecosystem of extensions around JSServe.jl.","category":"page"},{"location":"index.html#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"At the core of JSServe you have DOM to create any HTML tag, js\"...\" to run Javascript, and App to wrap your creation and serve it anywhere:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using JSServe\napp = App() do\n    return DOM.div(DOM.h1(\"hello world\"), js\"\"\"console.log('hello world')\"\"\")\nend","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"App has three main signatures:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# The main signatures, all other signatures will end up calling:\nApp((session, request) -> DOM.div(...))\n# Convenience constructors:\nApp((session::Session) -> DOM.div(...))\nApp((request::HTTP.Request) -> DOM.div(...))\nApp(() -> DOM.div(...))\nApp(DOM.div(...))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The app will be displayed by e.g. the VSCode plotpane, Jupyter/Pluto or any other framework that overloads the Julia display system for HTML display. In the REPL or an environment without an HTML ready display, a browser should open to display it (enabled explicitly via JSServe.browser_display()), but one can also serve the App very easily:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"server = Server(app, \"0.0.0.0\", 8080)\n# This is the same as:\nserver = Server(\"0.0.0.0\", 8080)\nroute!(server, \"/\" => app)\n# So you can add many apps to one server, and even regexes are supported:\nroute!(server, r\"*\" => App(DOM.div(\"404, no content for this route\")))\nroute!(server, \"/some-app\" => App(DOM.div(\"app\")))","category":"page"},{"location":"index.html#Easy-integration-with-existing-JS-CSS-libraries","page":"Home","title":"Easy integration with existing JS + CSS libraries","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"It's quite easy to integrate existing Libraries into your JSServe App:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"App() do\n    js = ES6Module(\"https://esm.sh/v133/leaflet@1.9.4/es2022/leaflet.mjs\")\n    css = Asset(\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\")\n    map_div = DOM.div(id=\"map\"; style=\"height: 300px; width: 100%\")\n    return DOM.div(\n        css, map_div,\n        js\"\"\"\n        $(js).then(L=> {\n            const map = L.map('map').setView([51.505, -0.09], 13);\n            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);\n        })\n        \"\"\"\n    )\nend","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Read more about wrapping libraries in Tutorial.","category":"page"},{"location":"index.html#Deploying","page":"Home","title":"Deploying","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe.jl wants to run everywhere, from Notebooks, IDEs, Electron, to being directly inserted into existing web pages.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: JSServe-wales)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Find out more about the different ways to serve your apps in Deployment.","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"leafletjs = JSServe.ES6Module(\"https://esm.sh/v111/leaflet@1.9.3/es2022/leaflet.js\")\nleafletcss = JSServe.Asset(\"https://unpkg.com/leaflet@1.9.3/dist/leaflet.css\")\nstruct LeafletMap\n    position::NTuple{2,Float64}\n    zoom::Int\nend\n\nfunction JSServe.jsrender(session::Session, map::LeafletMap)\n\n    map_div = DOM.div(id=\"map\"; style=\"height: 500px;\")\n\n    return JSServe.jsrender(session, DOM.div(\n        leafletcss,\n        leafletjs,\n        map_div,\n        js\"\"\"\n            $(leafletjs).then(L=> {\n                const map = L.map('map').setView($(map.position), $(map.zoom));\n                L.tileLayer(\n                    'https://tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    maxZoom: 19,\n                    attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>'\n                }).addTo(map);\n            })\n\n        \"\"\"\n    ))\nend\n\n\nApp() do\n    return LeafletMap((51.505, -0.09), 13)\nend","category":"page"}]
}
