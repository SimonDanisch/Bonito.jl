var documenterSearchIndex = {"docs":
[{"location":"api/#Api","page":"Api","title":"Api","text":"","category":"section"},{"location":"api/#Public-Functions","page":"Api","title":"Public Functions","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"Modules = [JSServe]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#JSServe.App","page":"Api","title":"JSServe.App","text":"App(handler)\n\ncalls handler with the session and the http request object. f is expected to return a valid DOM object, so something renderable by jsrender, e.g. DOM.div.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.CodeEditor-Tuple{String}","page":"Api","title":"JSServe.CodeEditor","text":"CodeEditor(language::String; initial_source=\"\", theme=\"chrome\", editor_options...)\n\nDefaults for editor_options:\n\n(\n    autoScrollEditorIntoView = true,\n    copyWithEmptySelection = true,\n    wrapBehavioursEnabled = true,\n    useSoftTabs = true,\n    enableMultiselect = true,\n    showLineNumbers = false,\n    fontSize = 16,\n    wrap = 80,\n    mergeUndoDeltas = \"always\"\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.Session","page":"Api","title":"JSServe.Session","text":"A web session with a user\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.Page-Tuple{}","page":"Api","title":"JSServe.Page","text":"Page(;\n    exportable=true,\n    offline=false,\n    server_config...\n)\n\nA Page can be used for resetting the JSServe state in a multi page display outputs, like it's the case for Pluto/IJulia/Documenter. For Documenter, the page needs to be set to exportable=true, offline=true, but doesn't need to, since Page defaults to the most common parameters for known Packages. Exportable has the effect of inlining all data & js dependencies, so that everything can be loaded in a single HTML object. offline=true will make the Page not even try to connect to a running Julia process, which makes sense for the kind of static export we do in Documenter. For convenience, one can also pass additional server configurations, which will directly get put into configure_server!(;server_config...). Have a look at the docs for configure_server! to see the parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.configure_server!-Tuple{}","page":"Api","title":"JSServe.configure_server!","text":"configure_server!(;\n        listen_url::String=SERVER_CONFIGURATION.listen_url[],\n        listen_port::Integer=SERVER_CONFIGURATION.listen_port[],\n        forwarded_port::Integer=listen_port,\n        external_url=nothing,\n        content_delivery_url=nothing\n    )\n\nConfigures the parameters for the automatically started server.\n\nParameters:\n\n* listen_url=SERVER_CONFIGURATION.listen_url[]\n    The address the server listens to.\n    must be 0.0.0.0, 127.0.0.1, ::, ::1, or localhost.\n    If not set differently by an ENV variable, will default to 127.0.0.1\n\n* listen_port::Integer=SERVER_CONFIGURATION.listen_port[],\n    The Port to which the default server listens to\n    If not set differently by an ENV variable, will default to 9284\n\n* forwarded_port::Integer=listen_port,\n    if port gets forwarded to some other port, set it here!\n\n* external_url=nothing\n    The url from which the server is reachable.\n    If served on \"127.0.0.1\", this will default to http://localhost:forwarded_port\n    if listen_url is \"0.0.0.0\", this will default to http://$(Sockets.getipaddr()):forwarded_port\n    so that the server is reachable inside the local network.\n    If the server should be reachable from some external dns server,\n    this needs to be set here.\n\n* content_delivery_url=nothing\n    You can server files from another server.\n    Make sure any file referenced from Julia is reachable at\n    content_delivery_url * \"/the_file\"\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.evaljs-Tuple{Session, JSServe.JSCode}","page":"Api","title":"JSServe.evaljs","text":"evaljs(session::Session, jss::JSCode)\n\nEvaluate a javascript script in session.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.evaljs_value-Tuple{Session, Any}","page":"Api","title":"JSServe.evaljs_value","text":"evaljs_value(session::Session, js::JSCode)\n\nEvals js code and returns the jsonified value. Blocks until value is returned. May block indefinitely, when called with a session that doesn't have a connection to the browser.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.linkjs-Tuple{Session, Observable, Observable}","page":"Api","title":"JSServe.linkjs","text":"linkjs(session::Session, a::Observable, b::Observable)\n\nfor an open session, link a and b on the javascript side. This will also Link the observables in Julia, but only as long as the session is active.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.onjs-Tuple{Session, Observable, JSServe.JSCode}","page":"Api","title":"JSServe.onjs","text":"onjs(session::Session, obs::Observable, func::JSCode)\n\nRegister a javascript function with session, that get's called when obs gets a new value. If the observable gets updated from the JS side, the calling of func will be triggered entirely in javascript, without any communication with the Julia session.\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-Functions","page":"Api","title":"Private Functions","text":"","category":"section"},{"location":"api/","page":"Api","title":"Api","text":"Modules = [JSServe]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"api/#JSServe.Asset","page":"Api","title":"JSServe.Asset","text":"Represent an asset stored at an URL. We try to always have online & local files for assets\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.FrontendConnection","page":"Api","title":"JSServe.FrontendConnection","text":"Inteface for FrontendConnection\n\nstruct MyConnection <: FrontendConnection\nend\n\nNeeds to have a constructor with 0 arguments:\n\nMyConnection()\n\nNeeds to overload Base.write for sending binary data\n\nBase.write(connection::MyConnection, bytes::AbstractVector{UInt8})\n\nNeeds to implement isopen to indicate status of connection\n\nBase.isopen(c::MyConnection)\n\nSetup connection will be called before rendering any dom with session. The return value will be inserted into the DOM of the rendered App and can be used to do the JS part of opening the connection.\n\nJSServe.setup_connection(session::Session{IJuliaConnection})::Union{JSCode, Nothing}\n\nOne can overload use_parent_session, to turn on rendering dom objects inside sub-sessions while keeping one parent session managing the connection alive. This is handy for IJulia/Pluto, since the parent session just needs to be initialized one time and can stay active and globally store objects used multiple times across doms.\n\nJSServe.use_parent_session(::Session{MyConnection}) = false/false\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.JSCode","page":"Api","title":"JSServe.JSCode","text":"Javascript code that supports interpolation of Julia Objects. Construction of JSCode via string macro:\n\njsc = js\"console.log($(some_julia_variable))\"\n\nThis will decompose into:\n\njsc.source == [JSString(\"console.log(\"), some_julia_variable, JSString(\"\"\")]\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.JSException-Tuple{Session, AbstractDict}","page":"Api","title":"JSServe.JSException","text":"Creates a Julia exception from data passed to us by the frondend!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.JSString","page":"Api","title":"JSServe.JSString","text":"The string part of JSCode.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.JSUpdateObservable","page":"Api","title":"JSServe.JSUpdateObservable","text":"Functor to update JS part when an observable changes. We make this a Functor, so we can clearly identify it and don't sent any updates, if the JS side requires to update an Observable (so we don't get an endless update cycle)\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.NoServer","page":"Api","title":"JSServe.NoServer","text":"We don't serve files and include anything directly as raw bytes. Interpolating the same asset many times, will only upload the file to JS one time though.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.Table","page":"Api","title":"JSServe.Table","text":"A simple wrapper for types that conform to the Tables.jl Table interface, which gets rendered nicely!\n\n\n\n\n\n","category":"type"},{"location":"api/#JSServe.WebSocketConnection-Tuple{Any, HTTP.WebSockets.WebSocket}","page":"Api","title":"JSServe.WebSocketConnection","text":"handles a new websocket connection to a session\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.add_cached!-Tuple{Function, Session, Dict{String, Any}, Any}","page":"Api","title":"JSServe.add_cached!","text":"add_cached!(create_cached_object::Function, session::Session, message_cache::Dict{String, Any}, key::String)\n\nChecks if key is already cached by the session or it's root session (we skip any child session between root -> this session). If not cached already, we call create_cached_object to create a serialized form of the object corresponding to key and cache it. We return nothing if already cached, or the serialized object if not cached. We also handle the part of adding things to the message_cache from the serialization context.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.contextual_eval-Tuple{Any, Any}","page":"Api","title":"JSServe.contextual_eval","text":"contextual_eval(parent, expr)\n\n\"Evals\" expression without eval by only allowing getfield + getindex expressions\n\ncontextual_eval(context, :(lala.blalba)) == context.lala.blabla\ncontextual_eval(context, :(lala.blalba[1])) == context.lala.blabla[1]\ncontextual_eval(context, :(julia_func())) == error\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.dependency_path-Tuple","page":"Api","title":"JSServe.dependency_path","text":"dependency_path(paths...)\n\nPath to serve downloaded dependencies\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.export_standalone-Tuple{App, String}","page":"Api","title":"JSServe.export_standalone","text":"export_standaloneexport_standalone(\n    app::App, folder::String;\n    clear_folder=false, write_index_html=true,\n    absolute_urls=false, content_delivery_url=\"file://\" * folder * \"/\",\n    single_html=false)\n\nExports the app defined by app::Application with all its assets to folder. Will write the main html out into folder/index.html. Overwrites all existing files! If this gets served behind a proxy, set absolute_urls=true and set content_delivery_url to your proxy url. If clear_folder=true all files in folder will get deleted before exporting again! single_html=true will write out a single html instead of writing out JS depencies as separate files.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.getextension-Tuple{AbstractString}","page":"Api","title":"JSServe.getextension","text":"getextension(path)\n\nGet the file extension of the path. The extension is defined to be the bit after the last dot, excluding any query string.\n\nExamples\n\njulia> JSServe.getextension(\"foo.bar.js\")\n\"js\"\njulia> JSServe.getextension(\"https://my-cdn.net/foo.bar.css?version=1\")\n\"css\"\n\nTaken from WebIO.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.is_online-Tuple{AbstractString}","page":"Api","title":"JSServe.is_online","text":"is_online(path)\n\nDetermine whether or not the specified path is a local filesystem path (and not a remote resource that is hosted on, for example, a CDN).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.jsrender-Tuple{Session, Any}","page":"Api","title":"JSServe.jsrender","text":"jsrender([::Session], x::Any)\n\nInternal render method to create a valid dom. Registers used observables with a session And makes sure the dom only contains valid elements. Overload jsrender(::YourType) To enable putting YourType into a dom element/div. You can also overload it to take a session as first argument, to register messages with the current web session (e.g. via onjs).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.on_document_load-Tuple{Session, JSServe.JSCode}","page":"Api","title":"JSServe.on_document_load","text":"on_document_load(session::Session, js::JSCode)\n\nexecutes javascript after document is loaded\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.onload-Tuple{Session, Hyperscript.Node, JSServe.JSCode}","page":"Api","title":"JSServe.onload","text":"onload(session::Session, node::Node, func::JSCode)\n\ncalls javascript func with node, once node has been displayed.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.page_html-Tuple{IO, Session, Union{App, Hyperscript.Node}}","page":"Api","title":"JSServe.page_html","text":"page_html(session::Session, html_body)\n\nEmbeds the html_body in a standalone html document!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.process_message-Tuple{Session, AbstractVector{UInt8}}","page":"Api","title":"JSServe.process_message","text":"process_message(session::Session, bytes::AbstractVector{UInt8})\n\nHandles the incoming websocket messages from the frontend. Messages are expected to be gzip compressed and packed via MsgPack.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.register_asset_server!-Union{Tuple{C}, Tuple{Function, Type{C}}} where C<:JSServe.AbstractAssetServer","page":"Api","title":"JSServe.register_asset_server!","text":"register_asset_server!(condition::Function, ::Type{<: AbstractAssetServer})\n\nRegisters a new asset server type. condition is a function that should return nothing, if the asset server type shouldn't be used, and an initialized asset server object, if the conditions are right. E.g. The JSServe.NoServer be used inside an IJulia notebook so it's registered like this:\n\nregister_asset_server!(NoServer) do\n    if isdefined(Main, :IJulia)\n        return NoServer()\n    end\n    return nothing\nend\n\nThe last asset server registered takes priority, so if you register a new connection last in your Package, and always return it, You will overwrite the connection type for any other package. If you want to force usage temporary, try:\n\nforce_asset_server(YourAssetServer()) do\n    ...\nend\n# which is the same as:\nforce_asset_server!(YourAssetServer())\n...\nforce_asset_server!()\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.register_connection!-Union{Tuple{C}, Tuple{Function, Type{C}}} where C<:JSServe.FrontendConnection","page":"Api","title":"JSServe.register_connection!","text":"register_connection!(condition::Function, ::Type{<: FrontendConnection})\n\nRegisters a new Connection type.\n\ncondition is a function that should return nothing, if the connection type shouldn't be used, and an initialized Connection, if the conditions are right. E.g. The IJulia connection should only be used inside an IJulia notebook so it's registered like this:\n\nregister_connection!(IJuliaConnection) do\n    if isdefined(Main, :IJulia)\n        return IJuliaConnection()\n    end\n    return nothing\nend\n\nThe last connection registered take priority, so if you register a new connection last in your Package, and always return it, You will overwrite the connection type for any other package. If you want to force usage temporary, try:\n\nforce_connection(YourConnectionType()) do\n    ...\nend\n# which is the same as:\nforce_connection!(YourConnectionType())\n...\nforce_connection!()\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.replace_expressions-Tuple{Any, Any}","page":"Api","title":"JSServe.replace_expressions","text":"replace_expressions(markdown, context)\n\nReplaces all expressions inside markdown savely, by only supporting getindex/getfield expression that will index into context\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.string_to_markdown-Tuple{String, Any}","page":"Api","title":"JSServe.string_to_markdown","text":"string_to_markdown(source::String, context; eval_julia_code=false)\n\nReplaces all interpolation expressions inside markdown savely, by only supporting getindex/getfield expression that will index into context. You can eval Julia code blocks by setting eval_julia_code to a Module, into which the code gets evaluated!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSServe.update_nocycle!-Tuple{Observable, Any}","page":"Api","title":"JSServe.update_nocycle!","text":"Update the value of an observable, without sending changes to the JS frontend. This will be used to update updates from the forntend.\n\n\n\n\n\n","category":"method"},{"location":"api/#Sockets.send-Tuple{Session}","page":"Api","title":"Sockets.send","text":"send(session::Session; attributes...)\n\nSend values to the frontend via JSON for now\n\n\n\n\n\n","category":"method"},{"location":"extending/#Extending-JSServe","page":"Extending JSServe","title":"Extending JSServe","text":"","category":"section"},{"location":"extending/#Connection","page":"Extending JSServe","title":"Connection","text":"","category":"section"},{"location":"extending/","page":"Extending JSServe","title":"Extending JSServe","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"extending/","page":"Extending JSServe","title":"Extending JSServe","text":"\nstruct MyConnection <: JSServe.FrontendConnection\n    ...\nend\n\nfunction MyConnection(parent::Session)\n    return MyConnection(parent.connection, false)\nend\n\nfunction Base.write(connection::MyConnection, binary)\n    write(connection.connection, binary)\nend\n\nBase.isopen(connection::MyConnection) = connection.isopen\nBase.close(connection::MyConnection) = (connection.isopen = false)\nopen!(connection::MyConnection) = (connection.isopen = true)\n\nfunction setup_connection(session::Session{MyConnection})\n    return js\"\"\"\n    // Javascript needed to connect to\n    const conn = create_connection(...) // implemented by your framework\n    conn.on_msg((msg) => {\n        JSServe.process_message(msg)\n    });\n    // register sending message\n    JSServe.on_connection_open((binary) => {\n        comm.send(binary)\n    });\n    \"\"\"\nend","category":"page"},{"location":"widgets/#Widgets","page":"Widgets","title":"Widgets","text":"","category":"section"},{"location":"widgets/#Editor","page":"Widgets","title":"Editor","text":"","category":"section"},{"location":"widgets/","page":"Widgets","title":"Widgets","text":"This editor works in pure Javascript, so feel free to try out editing the Javascript and clicking eval to see how the output changes. In JSServe/examples/editor.jl, you will find a version that works with Julia code, but that requires a running Julia server of course.","category":"page"},{"location":"widgets/","page":"Widgets","title":"Widgets","text":"using JSServe\nPage()","category":"page"},{"location":"widgets/","page":"Widgets","title":"Widgets","text":"using JSServe, Observables\nsrc = \"\"\"\n(() => {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext('2d');\n    const width = 500\n    const height = 400\n    canvas.width = width;\n    canvas.height = height;\n    const gradient = context.createRadialGradient(200, 200, 0, 200, 200, 200);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\".25\", \"blue\");\n    gradient.addColorStop(\".50\", \"green\");\n    gradient.addColorStop(\".75\", \"yellow\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return canvas;\n})();\n\"\"\"\nApp() do session::Session\n    editor = CodeEditor(\"javascript\"; initial_source=src, width=800, height=300)\n    eval_button = Button(\"eval\")\n    output = DOM.div(DOM.span())\n    JSServe.onjs(session, eval_button.value, js\"\"\"function (click){\n        const js_src = $(editor.onchange).value;\n        const result = new Function(\"return \" + (js_src))()\n        let dom;\n        if (typeof result === 'object' && result.nodeName) {\n            dom = result\n        } else {\n            const span = document.createElement(\"span\")\n            span.innerText = result;\n            dom = span\n        }\n        JSServe.update_or_replace($(output), dom, false);\n        return\n    }\n    \"\"\")\n    notify(eval_button.value)\n    return DOM.div(editor, eval_button, output)\nend","category":"page"},{"location":"assets/#Assets","page":"Assets","title":"Assets","text":"","category":"section"},{"location":"assets/","page":"Assets","title":"Assets","text":"some_file = Asset(\"path/to/local/file\")\r\n# ES6Module creates an Asset with the flags set appropriately to\r\n# treat it as a module\r\njsmodule = ES6Module(\"path/to/local/es6module.js\")::Asset\r\n\r\n# These assets can be interpolated into DOM elements and js strings:\r\njs\"\"\"\r\n// this will result in importing jsmodule\r\n// Doing this in many places will only import jsmodule once\r\n$(jsmodule).then(jsmodule=> {\r\n    // Do something with the module :)\r\n})\r\n// This will give you the raw bytes as a Uint8Array\r\n$(some_file).then(raw_bytes => {\r\n    // do something with bytes\r\n})\r\n\"\"\"\r\n\r\n# This will resolve to a valid URL depending on the used asset server\r\nDOM.img(src=some_file)\r\n\r\n# This will also resolve to a valid URL and load jsmodule as an es6 module\r\nDOM.sript(src=jsmodule, type=\"module\")\r\n\r\n# Assets also work with online sources, which is great for online dependencies!\r\n# Usage is exactly the same as when using local files\r\nTHREE = ES6Module(\"https://unpkg.com/three@0.136.0/build/three.js\")\r\n# Also offer an easy way to use packages from a CDN (currently esm.sh):\r\nTHREE = CDNSource(\"three\"; version=\"0.137.5\")","category":"page"},{"location":"#JSServe-Introduction","page":"JSServe Introduction","title":"JSServe Introduction","text":"","category":"section"},{"location":"","page":"JSServe Introduction","title":"JSServe Introduction","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"","page":"JSServe Introduction","title":"JSServe Introduction","text":"using JSServe\n\nApp() do\n    DOM.h1(\"hello world\")\nend","category":"page"},{"location":"","page":"JSServe Introduction","title":"JSServe Introduction","text":"# Javascript & CSS dependencies can be declared locally and\n# freely interpolated in the DOM / js string, and will make sure it loads\n# Note, that they will be a `Promise` though, so to use them you need to call `module.then(module=> ...)`.\nconst THREE = ES6Module(\"https://cdn.esm.sh/v66/three@0.136/es2021/three.js\")\n\napp = App() do session, request\n    width = 500; height = 500\n    dom = DOM.div(width = width, height = height)\n    JSServe.onload(session, dom, js\"\"\"\n        function (container){\n            $(THREE).then(THREE=> {\n                var renderer = new THREE.WebGLRenderer({antialias: true});\n                renderer.setSize($width, $height);\n                renderer.setClearColor(\"#ffffff\");\n                container.appendChild(renderer.domElement);\n                var scene = new THREE.Scene();\n                var camera = new THREE.PerspectiveCamera(75, $width / $height, 0.1, 1000);\n                camera.position.z = 4;\n                var ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);\n                scene.add(ambientLight);\n                var pointLight = new THREE.PointLight(0xffffff, 0.8);\n                camera.add(pointLight);\n                scene.add(camera);\n                var geometry = new THREE.SphereGeometry(1.0, 32, 32);\n                var material = new THREE.MeshPhongMaterial({color: 0xffff00});\n                var sphere = new THREE.Mesh(geometry, material);\n                scene.add(sphere);\n                renderer.render(scene, camera);\n            })\n        }\n    \"\"\")\n    return dom\nend","category":"page"}]
}
