var documenterSearchIndex = {"docs":
[{"location":"api.html#Api","page":"Api","title":"Api","text":"","category":"section"},{"location":"api.html#Public-Functions","page":"Api","title":"Public Functions","text":"","category":"section"},{"location":"api.html","page":"Api","title":"Api","text":"Modules = [JSServe]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api.html#JSServe.App","page":"Api","title":"JSServe.App","text":"App(handler)\n\ncalls handler with the session and the http request object. f is expected to return a valid DOM object, so something renderable by jsrender, e.g. DOM.div.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.CodeEditor-Tuple{String}","page":"Api","title":"JSServe.CodeEditor","text":"CodeEditor(language::String; initial_source=\"\", theme=\"chrome\", editor_options...)\n\nDefaults for editor_options:\n\n(\n    autoScrollEditorIntoView = true,\n    copyWithEmptySelection = true,\n    wrapBehavioursEnabled = true,\n    useSoftTabs = true,\n    enableMultiselect = true,\n    showLineNumbers = false,\n    fontSize = 16,\n    wrap = 80,\n    mergeUndoDeltas = \"always\"\n)\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.NoServer","page":"Api","title":"JSServe.NoServer","text":"We don't serve files and include anything directly as raw bytes. Interpolating the same asset many times, will only upload the file to JS one time though.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.Session","page":"Api","title":"JSServe.Session","text":"A web session with a user\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.WebSocketConnection-Tuple{Any, HTTP.WebSockets.WebSocket}","page":"Api","title":"JSServe.WebSocketConnection","text":"handles a new websocket connection to a session\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.Page-Tuple{}","page":"Api","title":"JSServe.Page","text":"Page(;\n    offline=false, exportable=true,\n    connection::Union{Nothing, FrontendConnection}=nothing,\n    server_config...\n)\n\nA Page can be used for resetting the JSServe state in a multi page display outputs, like it's the case for Pluto/IJulia/Documenter. For Documenter, the page needs to be set to exportable=true, offline=true, but doesn't need to, since Page defaults to the most common parameters for known Packages. Exportable has the effect of inlining all data & js dependencies, so that everything can be loaded in a single HTML object. offline=true will make the Page not even try to connect to a running Julia process, which makes sense for the kind of static export we do in Documenter. For convenience, one can also pass additional server configurations, which will directly get put into configure_server!(;server_config...). Have a look at the docs for configure_server! to see the parameters.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.configure_server!-Tuple{}","page":"Api","title":"JSServe.configure_server!","text":"configure_server!(;\n        listen_url::String=SERVER_CONFIGURATION.listen_url[],\n        listen_port::Integer=SERVER_CONFIGURATION.listen_port[],\n        forwarded_port::Integer=listen_port,\n        external_url=nothing,\n        content_delivery_url=nothing\n    )\n\nConfigures the parameters for the automatically started server.\n\nParameters:\n\n* listen_url=SERVER_CONFIGURATION.listen_url[]\n    The address the server listens to.\n    must be 0.0.0.0, 127.0.0.1, ::, ::1, or localhost.\n    If not set differently by an ENV variable, will default to 127.0.0.1\n\n* listen_port::Integer=SERVER_CONFIGURATION.listen_port[],\n    The Port to which the default server listens to\n    If not set differently by an ENV variable, will default to 9284\n\n* forwarded_port::Integer=listen_port,\n    if port gets forwarded to some other port, set it here!\n\n* external_url=nothing\n    The url from which the server is reachable.\n    If served on \"127.0.0.1\", this will default to http://localhost:forwarded_port\n    if listen_url is \"0.0.0.0\", this will default to http://$(Sockets.getipaddr()):forwarded_port\n    so that the server is reachable inside the local network.\n    If the server should be reachable from some external dns server,\n    this needs to be set here.\n\n* content_delivery_url=nothing\n    You can server files from another server.\n    Make sure any file referenced from Julia is reachable at\n    content_delivery_url * \"/the_file\"\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.evaljs-Tuple{Session, JSServe.JSCode}","page":"Api","title":"JSServe.evaljs","text":"evaljs(session::Session, jss::JSCode)\n\nEvaluate a javascript script in session.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.evaljs_value-Tuple{Session, Any}","page":"Api","title":"JSServe.evaljs_value","text":"evaljs_value(session::Session, js::JSCode)\n\nEvals js code and returns the jsonified value. Blocks until value is returned. May block indefinitely, when called with a session that doesn't have a connection to the browser.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.linkjs-Tuple{Session, Observable, Observable}","page":"Api","title":"JSServe.linkjs","text":"linkjs(session::Session, a::Observable, b::Observable)\n\nfor an open session, link a and b on the javascript side. This will also Link the observables in Julia, but only as long as the session is active.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.onjs-Tuple{Session, Observable, JSServe.JSCode}","page":"Api","title":"JSServe.onjs","text":"onjs(session::Session, obs::Observable, func::JSCode)\n\nRegister a javascript function with session, that get's called when obs gets a new value. If the observable gets updated from the JS side, the calling of func will be triggered entirely in javascript, without any communication with the Julia session.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Private-Functions","page":"Api","title":"Private Functions","text":"","category":"section"},{"location":"api.html","page":"Api","title":"Api","text":"Modules = [JSServe]\nOrder   = [:module, :constant, :type, :function, :macro]\nPublic  = false\nPrivate = true","category":"page"},{"location":"api.html#JSServe.Asset","page":"Api","title":"JSServe.Asset","text":"Represent an asset stored at an URL. We try to always have online & local files for assets\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.FrontendConnection","page":"Api","title":"JSServe.FrontendConnection","text":"Inteface for FrontendConnection\n\nstruct MyConnection <: FrontendConnection\nend\n\nNeeds to have a constructor with 0 arguments:\n\nMyConnection()\n\nNeeds to overload Base.write for sending binary data\n\nBase.write(connection::MyConnection, bytes::AbstractVector{UInt8})\n\nNeeds to implement isopen to indicate status of connection\n\nBase.isopen(c::MyConnection)\n\nSetup connection will be called before rendering any dom with session. The return value will be inserted into the DOM of the rendered App and can be used to do the JS part of opening the connection.\n\nJSServe.setup_connection(session::Session{IJuliaConnection})::Union{JSCode, Nothing}\n\nOne can overload use_parent_session, to turn on rendering dom objects inside sub-sessions while keeping one parent session managing the connection alive. This is handy for IJulia/Pluto, since the parent session just needs to be initialized one time and can stay active and globally store objects used multiple times across doms.\n\nJSServe.use_parent_session(::Session{MyConnection}) = false/false\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.JSCode","page":"Api","title":"JSServe.JSCode","text":"Javascript code that supports interpolation of Julia Objects. Construction of JSCode via string macro:\n\njsc = js\"console.log($(some_julia_variable))\"\n\nThis will decompose into:\n\njsc.source == [JSString(\"console.log(\"), some_julia_variable, JSString(\"\"\")]\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.JSException-Tuple{Session, AbstractDict}","page":"Api","title":"JSServe.JSException","text":"Creates a Julia exception from data passed to us by the frondend!\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.JSString","page":"Api","title":"JSServe.JSString","text":"The string part of JSCode.\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.JSUpdateObservable","page":"Api","title":"JSServe.JSUpdateObservable","text":"Functor to update JS part when an observable changes. We make this a Functor, so we can clearly identify it and don't sent any updates, if the JS side requires to update an Observable (so we don't get an endless update cycle)\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.Table","page":"Api","title":"JSServe.Table","text":"A simple wrapper for types that conform to the Tables.jl Table interface, which gets rendered nicely!\n\n\n\n\n\n","category":"type"},{"location":"api.html#JSServe.add_cached!-Tuple{Function, Session, Dict{String, Any}, Any}","page":"Api","title":"JSServe.add_cached!","text":"add_cached!(create_cached_object::Function, session::Session, message_cache::Dict{String, Any}, key::String)\n\nChecks if key is already cached by the session or it's root session (we skip any child session between root -> this session). If not cached already, we call create_cached_object to create a serialized form of the object corresponding to key and cache it. We return nothing if already cached, or the serialized object if not cached. We also handle the part of adding things to the message_cache from the serialization context.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.contextual_eval-Tuple{Any, Any}","page":"Api","title":"JSServe.contextual_eval","text":"contextual_eval(parent, expr)\n\n\"Evals\" expression without eval by only allowing getfield + getindex expressions\n\ncontextual_eval(context, :(lala.blalba)) == context.lala.blabla\ncontextual_eval(context, :(lala.blalba[1])) == context.lala.blabla[1]\ncontextual_eval(context, :(julia_func())) == error\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.dependency_path-Tuple","page":"Api","title":"JSServe.dependency_path","text":"dependency_path(paths...)\n\nPath to serve downloaded dependencies\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.export_standalone-Tuple{App, String}","page":"Api","title":"JSServe.export_standalone","text":"export_standaloneexport_standalone(\n    app::App, folder::String;\n    clear_folder=false, write_index_html=true,\n    absolute_urls=false, content_delivery_url=\"file://\" * folder * \"/\",\n    single_html=false)\n\nExports the app defined by app::Application with all its assets to folder. Will write the main html out into folder/index.html. Overwrites all existing files! If this gets served behind a proxy, set absolute_urls=true and set content_delivery_url to your proxy url. If clear_folder=true all files in folder will get deleted before exporting again! single_html=true will write out a single html instead of writing out JS depencies as separate files.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.getextension-Tuple{AbstractString}","page":"Api","title":"JSServe.getextension","text":"getextension(path)\n\nGet the file extension of the path. The extension is defined to be the bit after the last dot, excluding any query string.\n\nExamples\n\njulia> JSServe.getextension(\"foo.bar.js\")\n\"js\"\njulia> JSServe.getextension(\"https://my-cdn.net/foo.bar.css?version=1\")\n\"css\"\n\nTaken from WebIO.jl\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.is_online-Tuple{AbstractString}","page":"Api","title":"JSServe.is_online","text":"is_online(path)\n\nDetermine whether or not the specified path is a local filesystem path (and not a remote resource that is hosted on, for example, a CDN).\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.jsrender-Tuple{Session, Any}","page":"Api","title":"JSServe.jsrender","text":"jsrender([::Session], x::Any)\n\nInternal render method to create a valid dom. Registers used observables with a session And makes sure the dom only contains valid elements. Overload jsrender(::YourType) To enable putting YourType into a dom element/div. You can also overload it to take a session as first argument, to register messages with the current web session (e.g. via onjs).\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.on_document_load-Tuple{Session, JSServe.JSCode}","page":"Api","title":"JSServe.on_document_load","text":"on_document_load(session::Session, js::JSCode)\n\nexecutes javascript after document is loaded\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.onload-Tuple{Session, Hyperscript.Node, JSServe.JSCode}","page":"Api","title":"JSServe.onload","text":"onload(session::Session, node::Node, func::JSCode)\n\ncalls javascript func with node, once node has been displayed.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.page_html-Tuple{IO, Session, Union{App, Hyperscript.Node}}","page":"Api","title":"JSServe.page_html","text":"page_html(session::Session, html_body)\n\nEmbeds the html_body in a standalone html document!\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.process_message-Tuple{Session, AbstractVector{UInt8}}","page":"Api","title":"JSServe.process_message","text":"process_message(session::Session, bytes::AbstractVector{UInt8})\n\nHandles the incoming websocket messages from the frontend. Messages are expected to be gzip compressed and packed via MsgPack.\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.register_asset_server!-Union{Tuple{C}, Tuple{Function, Type{C}}} where C<:JSServe.AbstractAssetServer","page":"Api","title":"JSServe.register_asset_server!","text":"register_asset_server!(condition::Function, ::Type{<: AbstractAssetServer})\n\nRegisters a new asset server type. condition is a function that should return nothing, if the asset server type shouldn't be used, and an initialized asset server object, if the conditions are right. E.g. The JSServe.NoServer be used inside an IJulia notebook so it's registered like this:\n\nregister_asset_server!(NoServer) do\n    if isdefined(Main, :IJulia)\n        return NoServer()\n    end\n    return nothing\nend\n\nThe last asset server registered takes priority, so if you register a new connection last in your Package, and always return it, You will overwrite the connection type for any other package. If you want to force usage temporary, try:\n\nforce_asset_server(YourAssetServer()) do\n    ...\nend\n# which is the same as:\nforce_asset_server!(YourAssetServer())\n...\nforce_asset_server!()\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.register_connection!-Union{Tuple{C}, Tuple{Function, Type{C}}} where C<:JSServe.FrontendConnection","page":"Api","title":"JSServe.register_connection!","text":"register_connection!(condition::Function, ::Type{<: FrontendConnection})\n\nRegisters a new Connection type.\n\ncondition is a function that should return nothing, if the connection type shouldn't be used, and an initialized Connection, if the conditions are right. E.g. The IJulia connection should only be used inside an IJulia notebook so it's registered like this:\n\nregister_connection!(IJuliaConnection) do\n    if isdefined(Main, :IJulia)\n        return IJuliaConnection()\n    end\n    return nothing\nend\n\nThe last connection registered take priority, so if you register a new connection last in your Package, and always return it, You will overwrite the connection type for any other package. If you want to force usage temporary, try:\n\nforce_connection(YourConnectionType()) do\n    ...\nend\n# which is the same as:\nforce_connection!(YourConnectionType())\n...\nforce_connection!()\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.replace_expressions-Tuple{Any, Any}","page":"Api","title":"JSServe.replace_expressions","text":"replace_expressions(markdown, context)\n\nReplaces all expressions inside markdown savely, by only supporting getindex/getfield expression that will index into context\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.string_to_markdown-Tuple{String, Any}","page":"Api","title":"JSServe.string_to_markdown","text":"string_to_markdown(source::String, context; eval_julia_code=false)\n\nReplaces all interpolation expressions inside markdown savely, by only supporting getindex/getfield expression that will index into context. You can eval Julia code blocks by setting eval_julia_code to a Module, into which the code gets evaluated!\n\n\n\n\n\n","category":"method"},{"location":"api.html#JSServe.update_nocycle!-Tuple{Observable, Any}","page":"Api","title":"JSServe.update_nocycle!","text":"Update the value of an observable, without sending changes to the JS frontend. This will be used to update updates from the forntend.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Sockets.send-Tuple{Session}","page":"Api","title":"Sockets.send","text":"send(session::Session; attributes...)\n\nSend values to the frontend via JSON for now\n\n\n\n\n\n","category":"method"},{"location":"extending.html#Extending-JSServe","page":"Extending","title":"Extending JSServe","text":"","category":"section"},{"location":"extending.html#Connection","page":"Extending","title":"Connection","text":"","category":"section"},{"location":"extending.html","page":"Extending","title":"Extending","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"extending.html","page":"Extending","title":"Extending","text":"\nstruct MyConnection <: JSServe.FrontendConnection\n    ...\nend\n\nfunction MyConnection(parent::Session)\n    return MyConnection(parent.connection, false)\nend\n\nfunction Base.write(connection::MyConnection, binary)\n    write(connection.connection, binary)\nend\n\nBase.isopen(connection::MyConnection) = connection.isopen\nBase.close(connection::MyConnection) = (connection.isopen = false)\nopen!(connection::MyConnection) = (connection.isopen = true)\n\nfunction setup_connection(session::Session{MyConnection})\n    return js\"\"\"\n    // Javascript needed to connect to\n    const conn = create_connection(...) // implemented by your framework\n    conn.on_msg((msg) => {\n        JSServe.process_message(msg)\n    });\n    // register sending message\n    JSServe.on_connection_open((binary) => {\n        comm.send(binary)\n    }, $(session.compression_enabled));\n    \"\"\"\nend","category":"page"},{"location":"widgets.html#Widgets","page":"Widgets","title":"Widgets","text":"","category":"section"},{"location":"widgets.html#Editor","page":"Widgets","title":"Editor","text":"","category":"section"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"This editor works in pure Javascript, so feel free to try out editing the Javascript and clicking eval to see how the output changes. In JSServe/examples/editor.jl, you will find a version that works with Julia code, but that requires a running Julia server of course.","category":"page"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"using JSServe\nPage()","category":"page"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"using JSServe\nimport JSServe.TailwindDashboard as D\n\nfunction range_slider(orientation)\n    range_slider = RangeSlider(1:100; value=[10, 80])\n    range_slider.tooltips[] = true\n    range_slider.ticks[] = Dict(\n        \"mode\" => \"range\",\n        \"density\" => 3\n    )\n    range_slider.orientation[] = orientation\n    return range_slider\nend\n\nApp() do\n\n    button = D.Button(\"click\")\n    textfield = D.TextField(\"type in your text\")\n    numberinput = D.NumberInput(0.0)\n    file_input = D.FileInput()\n    on(file_input.value) do file\n        @show file\n    end\n    slider = D.Slider(\"Test\", 1:5)\n\n    checkbox = D.Checkbox(\"check this\", true)\n    table = JSServe.Table([(a=22, b=33, c=44), (a=22, b=33, c=44)])\n\n    source = \"\"\"\n    function test(a, b)\n        return a + b\n    end\n    \"\"\"\n    editor = CodeEditor(\"julia\"; initial_source=source, width=250, height=200, scrollPastEnd=false)\n    dropdown = D.Dropdown(\"chose\", [\"option 1\", \"option 2\", \"option 3\"])\n\n    vrange_slider = range_slider(JSServe.WidgetsBase.vertical)\n\n    hrange_slider = range_slider(JSServe.WidgetsBase.horizontal)\n\n\n    return DOM.div(\n        D.Card.([\n            D.FlexRow(\n                D.Card(D.FlexCol(\n                    button,\n                    textfield,\n                    numberinput,\n                    dropdown,\n                    file_input,\n                    slider,\n                    checkbox,\n                    class=\"items-start\"\n                )),\n                D.Card(table; class=\"w-64\")),\n            D.FlexRow(\n                D.Card.([\n                    DOM.div(vrange_slider; style=\"height: 200px; padding: 1px 50px\"),\n                    DOM.div(hrange_slider; style=\"width: 200px; padding: 50px 1px\"),\n                    editor\n                ])\n            ),\n        ])...\n    )\nend","category":"page"},{"location":"widgets.html","page":"Widgets","title":"Widgets","text":"using JSServe, Observables\nsrc = \"\"\"\n(() => {\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext('2d');\n    const width = 500\n    const height = 400\n    canvas.width = width;\n    canvas.height = height;\n    const gradient = context.createRadialGradient(200, 200, 0, 200, 200, 200);\n    gradient.addColorStop(\"0\", \"magenta\");\n    gradient.addColorStop(\".25\", \"blue\");\n    gradient.addColorStop(\".50\", \"green\");\n    gradient.addColorStop(\".75\", \"yellow\");\n    gradient.addColorStop(\"1.0\", \"red\");\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return canvas;\n})();\n\"\"\"\nApp() do session::Session\n    editor = CodeEditor(\"javascript\"; initial_source=src, width=800, height=300)\n    eval_button = Button(\"eval\")\n    output = DOM.div(DOM.span())\n    JSServe.onjs(session, eval_button.value, js\"\"\"function (click){\n        const js_src = $(editor.onchange).value;\n        const result = new Function(\"return \" + (js_src))()\n        let dom;\n        if (typeof result === 'object' && result.nodeName) {\n            dom = result\n        } else {\n            const span = document.createElement(\"span\")\n            span.innerText = result;\n            dom = span\n        }\n        JSServe.update_or_replace($(output), dom, false);\n        return\n    }\n    \"\"\")\n    notify(eval_button.value)\n    return DOM.div(editor, eval_button, output)\nend","category":"page"},{"location":"deployment.html#Deployment","page":"Deployment","title":"Deployment","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using JSServe\nexample_app = App(DOM.div(\"hello world\"), title=\"hello world\")","category":"page"},{"location":"deployment.html#Server","page":"Deployment","title":"Server","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"# Depending on your servers setup, you may need to listen on another port or URL\n# But 0.0.0.0:80 is pretty standard for most server setups\nport = 80\nurl = \"0.0.0.0\"\nserver = JSServe.Server(example_app, url, port)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Now, you should see the webpage at http://0.0.0.0:80.","category":"page"},{"location":"deployment.html#Proxy-Julia-Hub","page":"Deployment","title":"Proxy + Julia Hub","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"If the server is behind a proxy, you can set the proxy like this:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"server = JSServe.Server(example_app, \"0.0.0.0\", 8080; proxy_url=\"https://my-domain.de/my-app\");\n# or set it later\n# this can be handy for interactive use cases where one isn't sure which port is open, and let JSServe find a free port (which will then be different from the one created with, but is stored in `server.port`)\nserver.proxy_url = \".../$(server.port)\"","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"JSServe tries to do this for known environments like JuliaHub via get_server(). This will find the most common proxy setup and return a started server:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"server = JSServe.get_server()\n# add a route to the server for root to point to our example app\nroute!(server, \"/\" => example_app)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"The url which this site is now served on can be found via:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"# Here in documenter, this will just return a localhost url\nurl_to_visit = online_url(server, \"/\")","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Like this, one can also add multiple pages:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"page_404 = App() do session, request\n    return DOM.div(\"no page for $(request.target)\")\nend\n# You can use string (paths), or a regex\nroute!(server, r\".*\" => page_404)\nroute!(server, r\"my/nested/page\" => App(DOM.div(\"nested\")))\nurl_to_visit = online_url(server, \"/my/nested/page\")","category":"page"},{"location":"deployment.html#Heroku","page":"Deployment","title":"Heroku","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Deploying to Heroku with JSServe works pretty similar to this blogpost.","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"mkdir my-app\ncd my-app\njulia --project=. -e 'using Pkg; Pkg.add(\"JSServe\")' # and any other dependency","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"then create 2 files:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"app.jl:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using JSServe\n# The app you want to serve\n#  Note: you can also add more pages with `route!(server, ...)` as explained aboce\nmy_app = App(DOM.div(\"hello world\"))\nport = parse(Int, ENV[\"PORT\"])\n# needs to match `heroku create - a example-app`,\n# which we can ensure by using the env variable\n# which is only available in review app, so one needs to fill this in manually for now\n# https://devcenter.heroku.com/articles/github-integration-review-apps#injected-environment-variables\nmy_app_name = get(ENV, \"HEROKU_APP_NAME\", \"example-app\")\nurl = \"https://$(my_app_name).herokuapp.com/\"\nwait(JSServe.Server(my_app, \"0.0.0.0\", port, proxy_url=url))","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Procfile:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"web: julia --project=. app.jl","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"and then to upload the app install the heroku-cli and run as explained in the heroku git deploy section:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"$ cd my-app\n$ git init\n$ git add .\n$ git commit -m \"first commit\"\n$ heroku create -a example-app\n$ heroku git:remote -a example-app","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Which, after showing you the install logs, should print out the url to visit in the end. You can see the full example here:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"https://github.com/SimonDanisch/JSServe-heroku","category":"page"},{"location":"deployment.html#Terminal","page":"Deployment","title":"Terminal","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"If no HTML display is found in the Julia display stack, JSServe calls JSServe.enable_browser_display() in the __init__ function. This adds a display, that opens a browser window to display the app The loading of the BrowserDisplay happen in any kind of environment without html display, so this should also work in any kind of terminal or when evaluating a script.","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"> using JSSever\n> example_app # just let the display system display it in a browser window","category":"page"},{"location":"deployment.html#VScode","page":"Deployment","title":"VScode","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"VScode with enabled Plot Pane will display any JSServe.App in the HTML plotpane: (Image: )","category":"page"},{"location":"deployment.html#Notebooks","page":"Deployment","title":"Notebooks","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Most common notebook systems should work out of the box.","category":"page"},{"location":"deployment.html#IJulia","page":"Deployment","title":"IJulia","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Jupyterlab","page":"Deployment","title":"Jupyterlab","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Pluto","page":"Deployment","title":"Pluto","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Electron","page":"Deployment","title":"Electron","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using Electron, JSServe\n# Needs to be called after loading Electron\nJSServe.use_electron_display()\n# display(...) can be skipped in e.g. VSCode with disabled plotpane\ndisplay(example_app)","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"(Image: )","category":"page"},{"location":"deployment.html#Documenter","page":"Deployment","title":"Documenter","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"JSServe works in Documenter without additional setup. But, one always needs to include a block like this before any other code block displaying JSServe Apps:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"using JSServe\nPage()","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"This is needed, since JSServe structures the dependencies and state per Page, which needs to be unique per documentation page. One can use the JSServe documentation source to see an example.","category":"page"},{"location":"deployment.html#Static-export","page":"Deployment","title":"Static export","text":"","category":"section"},{"location":"deployment.html#Anything-else","page":"Deployment","title":"Anything else","text":"","category":"section"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"JSServe overloads the display/show stack for the mime \"text/html\" so any other Software which is able to display html in Julia should work with JSServe. If a use case is not supported, please open an issue. One can also always directly call:","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"html_source = sprint(io-> show(io, MIME\"text/html\"(), example_app))","category":"page"},{"location":"deployment.html","page":"Deployment","title":"Deployment","text":"Do get the html source code as a string (or just write it to the io).","category":"page"},{"location":"assets.html#Assets","page":"Assets","title":"Assets","text":"","category":"section"},{"location":"assets.html","page":"Assets","title":"Assets","text":"some_file = Asset(\"path/to/local/file\")\r\n# ES6Module creates an Asset with the flags set appropriately to\r\n# treat it as a module\r\njsmodule = ES6Module(\"path/to/local/es6module.js\")::Asset\r\n\r\n# These assets can be interpolated into DOM elements and js strings:\r\njs\"\"\"\r\n// this will result in importing jsmodule\r\n// Doing this in many places will only import jsmodule once\r\n$(jsmodule).then(jsmodule=> {\r\n    // Do something with the module :)\r\n})\r\n// This will give you the raw bytes as a Uint8Array\r\n$(some_file).then(raw_bytes => {\r\n    // do something with bytes\r\n})\r\n\"\"\"\r\n\r\n# This will resolve to a valid URL depending on the used asset server\r\nDOM.img(src=some_file)\r\n\r\n# This will also resolve to a valid URL and load jsmodule as an es6 module\r\nDOM.sript(src=jsmodule, type=\"module\")\r\n\r\n# Assets also work with online sources, which is great for online dependencies!\r\n# Usage is exactly the same as when using local files\r\nTHREE = ES6Module(\"https://unpkg.com/three@0.136.0/build/three.js\")\r\n# Also offer an easy way to use packages from a CDN (currently esm.sh):\r\nTHREE = CDNSource(\"three\"; version=\"0.137.5\")","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"using JSServe\r\nPage()","category":"page"},{"location":"assets.html","page":"Assets","title":"Assets","text":"# Javascript & CSS dependencies can be declared locally and\r\n# freely interpolated in the DOM / js string, and will make sure it loads\r\n# Note, that they will be a `Promise` though, so to use them you need to call `module.then(module=> ...)`.\r\nconst THREE = ES6Module(\"https://cdn.esm.sh/v66/three@0.136/es2021/three.js\")\r\n\r\napp = App() do session, request\r\n    width = 500; height = 500\r\n    dom = DOM.div(width = width, height = height)\r\n    JSServe.onload(session, dom, js\"\"\"\r\n        function (container){\r\n            $(THREE).then(THREE=> {\r\n                var renderer = new THREE.WebGLRenderer({antialias: true});\r\n                renderer.setSize($width, $height);\r\n                renderer.setClearColor(\"#ffffff\");\r\n                container.appendChild(renderer.domElement);\r\n                var scene = new THREE.Scene();\r\n                var camera = new THREE.PerspectiveCamera(75, $width / $height, 0.1, 1000);\r\n                camera.position.z = 4;\r\n                var ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);\r\n                scene.add(ambientLight);\r\n                var pointLight = new THREE.PointLight(0xffffff, 0.8);\r\n                camera.add(pointLight);\r\n                scene.add(camera);\r\n                var geometry = new THREE.SphereGeometry(1.0, 32, 32);\r\n                var material = new THREE.MeshPhongMaterial({color: 0xffff00});\r\n                var sphere = new THREE.Mesh(geometry, material);\r\n                scene.add(sphere);\r\n                renderer.render(scene, camera);\r\n            })\r\n        }\r\n    \"\"\")\r\n    return dom\r\nend","category":"page"},{"location":"plotting.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting.html","page":"Plotting","title":"Plotting","text":"using JSServe\nusing WGLMakie\nimport WGLMakie as W\nimport Plots as P\nimport PlotlyLight as PL\nimport JSServe.TailwindDashboard as D\nPage()\nfunction makie_plot()\n    N = 60\n    function xy_data(x, y)\n        r = sqrt(x^2 + y^2)\n        r == 0.0 ? 1.0f0 : (sin(r) / r)\n    end\n    l = range(-10, stop=10, length=N)\n    z = Float32[xy_data(x, y) for x in l, y in l]\n    W.surface(\n        -1 .. 1, -1 .. 1, z,\n        colormap=:Spectral,\n        figure=(; resolution=(500, 500))\n    )\nend\n\n# As far as I can tell, PlotlyLight doesn't handle require inside documenter correctly\n# So we just use JSServe to do it correctly via `Asset`:\nconst Plotly = JSServe.Asset(PL.cdn_url)\nfunction JSServe.jsrender(session::Session, plot::PL.Plot)\n    # Pretty much copied from the PlotlyLight source to create the JS + div for creating the plot:\n    div = DOM.div(DOM.div(id=plot.id, style=\"width: 100%; height: 100%\"), id=\"parent-of-$(plot.id)\"; style=\"width: 400px; height: 300px\")\n    src = js\"\"\"\n        Plotly.newPlot($(plot.id), $(plot.data), $(plot.layout), $(plot.config))\n    \"\"\"\n    return JSServe.jsrender(session, DOM.div(Plotly, div, src))\nend\n\nApp() do\n    p = PL.Plot(x=1:20, y=cumsum(randn(20)), type=\"scatter\", mode=\"lines+markers\")\n    width = \"400px\"\n    return D.FlexRow(\n        D.Card(P.scatter(1:4; windowsize=(200, 200)); width),\n        D.Card(p; width),\n        D.Card(makie_plot()); width)\nend","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe.jl is a pretty simple package allowing to render HTML and serve it from within Julia and build up a communication bridge with the Browser. This allows to combine any of your Julia applications with libraries like WGLMakie and create interactive Dashboards like this:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: dashboard)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe is tightly integrated with WGLMakie, which makes them a great pair for high performance, interactive visualizations. If performance is not a high priority, many other plotting/visualization libraries which overload the Julia display system should work with JSServe.jl as well.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe.jl itself is very un-opiniated and tries to stay out of major choices like the HTML/CSS/Javascript framework to use for creating UIs and Dashboards.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It uses plain HTML widgets for UI elements where it can, and only to give some base convenience, there is JSServe.TailwindDashboard which gives the basic JSServe widgets some nicer look and make it a bit easier to construct complex layouts.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"As you can see in JSServe/src/tailwind-dashboard.jl, it's just a thin wrapper around the basic JSServe.jl widgets, which gives them some class(es) to style them via TailwindCSS. Anyone can do this with their own CSS or HTML/Javascript framework, which should help to create a rich ecosystem of extensions around JSServe.jl.","category":"page"},{"location":"index.html#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using JSServe\nJSServe.Page()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"At the core of JSServe you have DOM to create any HTML tag, js\"...\" to run Javascript, and App to wrap your creation and serve it anywhere:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using JSServe\nApp() do\n    return DOM.div(DOM.h1(\"hello world\"), js\"\"\"console.log('hello world')\"\"\")\nend","category":"page"},{"location":"index.html#Deploying","page":"Home","title":"Deploying","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"JSServe.jl wants to run everywhere, from Notebooks, IDEs, Electron, to being directly inserted into existing web pages.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: JSServe-wales)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Find out more about the different ways to serve your apps in Deployment.","category":"page"}]
}
